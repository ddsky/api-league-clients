"""
    API League

    API League is a Hub for World Class APIs.  # noqa: E501

    The version of the OpenAPI document: 1.0
    Contact: mail@apileague.com
    Generated by: https://openapi-generator.tech
"""


import re  # noqa: F401
import sys  # noqa: F401

from openapi_client.api_client import ApiClient, Endpoint as _Endpoint
from openapi_client.model_utils import (  # noqa: F401
    check_allowed_values,
    check_validations,
    date,
    datetime,
    file_type,
    none_type,
    validate_and_convert_types
)
from openapi_client.model.inline_response20016 import InlineResponse20016
from openapi_client.model.inline_response20017 import InlineResponse20017
from openapi_client.model.inline_response20018 import InlineResponse20018
from openapi_client.model.inline_response20019 import InlineResponse20019
from openapi_client.model.inline_response20020 import InlineResponse20020
from openapi_client.model.inline_response20021 import InlineResponse20021
from openapi_client.model.inline_response20022 import InlineResponse20022
from openapi_client.model.inline_response20023 import InlineResponse20023
from openapi_client.model.inline_response20024 import InlineResponse20024
from openapi_client.model.inline_response20025 import InlineResponse20025
from openapi_client.model.inline_response20026 import InlineResponse20026
from openapi_client.model.inline_response20027 import InlineResponse20027


class TextApi(object):
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client
        self.correct_spelling_endpoint = _Endpoint(
            settings={
                'response_type': (InlineResponse20016,),
                'auth': [
                    'apiKey',
                    'headerApiKey'
                ],
                'endpoint_path': '/correct-spelling',
                'operation_id': 'correct_spelling',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'text',
                    'language',
                ],
                'required': [
                    'text',
                    'language',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                    'text',
                    'language',
                ]
            },
            root_map={
                'validations': {
                    ('text',): {
                        'max_length': 10000,
                        'regex': {
                            'pattern': r'.',  # noqa: E501
                        },
                    },
                    ('language',): {
                        'max_length': 2,
                        'regex': {
                            'pattern': r'.',  # noqa: E501
                        },
                    },
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'text':
                        (str,),
                    'language':
                        (str,),
                },
                'attribute_map': {
                    'text': 'text',
                    'language': 'language',
                },
                'location_map': {
                    'text': 'query',
                    'language': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.detect_language_endpoint = _Endpoint(
            settings={
                'response_type': ([InlineResponse20017],),
                'auth': [
                    'apiKey',
                    'headerApiKey'
                ],
                'endpoint_path': '/detect-language',
                'operation_id': 'detect_language',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'text',
                ],
                'required': [
                    'text',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                    'text',
                ]
            },
            root_map={
                'validations': {
                    ('text',): {
                        'max_length': 10000,
                        'regex': {
                            'pattern': r'.',  # noqa: E501
                        },
                    },
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'text':
                        (str,),
                },
                'attribute_map': {
                    'text': 'text',
                },
                'location_map': {
                    'text': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.detect_sentiment_endpoint = _Endpoint(
            settings={
                'response_type': (InlineResponse20018,),
                'auth': [
                    'apiKey',
                    'headerApiKey'
                ],
                'endpoint_path': '/detect-sentiment',
                'operation_id': 'detect_sentiment',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'text',
                ],
                'required': [
                    'text',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                    'text',
                ]
            },
            root_map={
                'validations': {
                    ('text',): {
                        'max_length': 10000,
                        'regex': {
                            'pattern': r'.',  # noqa: E501
                        },
                    },
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'text':
                        (str,),
                },
                'attribute_map': {
                    'text': 'text',
                },
                'location_map': {
                    'text': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.extract_dates_endpoint = _Endpoint(
            settings={
                'response_type': (InlineResponse20021,),
                'auth': [
                    'apiKey',
                    'headerApiKey'
                ],
                'endpoint_path': '/extract-dates',
                'operation_id': 'extract_dates',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'text',
                ],
                'required': [
                    'text',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                    'text',
                ]
            },
            root_map={
                'validations': {
                    ('text',): {
                        'max_length': 10000,
                        'regex': {
                            'pattern': r'.',  # noqa: E501
                        },
                    },
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'text':
                        (str,),
                },
                'attribute_map': {
                    'text': 'text',
                },
                'location_map': {
                    'text': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.extract_entities_endpoint = _Endpoint(
            settings={
                'response_type': (InlineResponse20027,),
                'auth': [
                    'apiKey',
                    'headerApiKey'
                ],
                'endpoint_path': '/extract-entities',
                'operation_id': 'extract_entities',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'text',
                ],
                'required': [
                    'text',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                    'text',
                ]
            },
            root_map={
                'validations': {
                    ('text',): {
                        'max_length': 10000,
                        'regex': {
                            'pattern': r'.',  # noqa: E501
                        },
                    },
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'text':
                        (str,),
                },
                'attribute_map': {
                    'text': 'text',
                },
                'location_map': {
                    'text': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.list_word_synonyms_endpoint = _Endpoint(
            settings={
                'response_type': (InlineResponse20022,),
                'auth': [
                    'apiKey',
                    'headerApiKey'
                ],
                'endpoint_path': '/list-synonyms',
                'operation_id': 'list_word_synonyms',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'word',
                ],
                'required': [
                    'word',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                    'word',
                ]
            },
            root_map={
                'validations': {
                    ('word',): {
                        'max_length': 50,
                        'regex': {
                            'pattern': r'.',  # noqa: E501
                        },
                    },
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'word':
                        (str,),
                },
                'attribute_map': {
                    'word': 'word',
                },
                'location_map': {
                    'word': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.part_of_speech_tagging_endpoint = _Endpoint(
            settings={
                'response_type': (InlineResponse20023,),
                'auth': [
                    'apiKey',
                    'headerApiKey'
                ],
                'endpoint_path': '/tag-pos',
                'operation_id': 'part_of_speech_tagging',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'text',
                ],
                'required': [
                    'text',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                    'text',
                ]
            },
            root_map={
                'validations': {
                    ('text',): {
                        'max_length': 10000,
                        'regex': {
                            'pattern': r'.',  # noqa: E501
                        },
                    },
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'text':
                        (str,),
                },
                'attribute_map': {
                    'text': 'text',
                },
                'location_map': {
                    'text': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.pluralize_word_endpoint = _Endpoint(
            settings={
                'response_type': (InlineResponse20026,),
                'auth': [
                    'apiKey',
                    'headerApiKey'
                ],
                'endpoint_path': '/pluralize-word',
                'operation_id': 'pluralize_word',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'word',
                ],
                'required': [
                    'word',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                    'word',
                ]
            },
            root_map={
                'validations': {
                    ('word',): {
                        'max_length': 50,
                        'regex': {
                            'pattern': r'.',  # noqa: E501
                        },
                    },
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'word':
                        (str,),
                },
                'attribute_map': {
                    'word': 'word',
                },
                'location_map': {
                    'word': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.score_readability_endpoint = _Endpoint(
            settings={
                'response_type': (InlineResponse20020,),
                'auth': [
                    'apiKey',
                    'headerApiKey'
                ],
                'endpoint_path': '/score-readability',
                'operation_id': 'score_readability',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'text',
                ],
                'required': [
                    'text',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                    'text',
                ]
            },
            root_map={
                'validations': {
                    ('text',): {
                        'max_length': 10000,
                        'regex': {
                            'pattern': r'.',  # noqa: E501
                        },
                    },
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'text':
                        (str,),
                },
                'attribute_map': {
                    'text': 'text',
                },
                'location_map': {
                    'text': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.score_text_endpoint = _Endpoint(
            settings={
                'response_type': (InlineResponse20019,),
                'auth': [
                    'apiKey',
                    'headerApiKey'
                ],
                'endpoint_path': '/score-text',
                'operation_id': 'score_text',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'title',
                    'text',
                ],
                'required': [
                    'title',
                    'text',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                    'title',
                    'text',
                ]
            },
            root_map={
                'validations': {
                    ('title',): {
                        'max_length': 10000,
                        'regex': {
                            'pattern': r'.',  # noqa: E501
                        },
                    },
                    ('text',): {
                        'max_length': 10000,
                        'regex': {
                            'pattern': r'.',  # noqa: E501
                        },
                    },
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'title':
                        (str,),
                    'text':
                        (str,),
                },
                'attribute_map': {
                    'title': 'title',
                    'text': 'text',
                },
                'location_map': {
                    'title': 'query',
                    'text': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.singularize_word_endpoint = _Endpoint(
            settings={
                'response_type': (InlineResponse20025,),
                'auth': [
                    'apiKey',
                    'headerApiKey'
                ],
                'endpoint_path': '/singularize-word',
                'operation_id': 'singularize_word',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'word',
                ],
                'required': [
                    'word',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                    'word',
                ]
            },
            root_map={
                'validations': {
                    ('word',): {
                        'max_length': 50,
                        'regex': {
                            'pattern': r'.',  # noqa: E501
                        },
                    },
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'word':
                        (str,),
                },
                'attribute_map': {
                    'word': 'word',
                },
                'location_map': {
                    'word': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.text_stemming_endpoint = _Endpoint(
            settings={
                'response_type': (InlineResponse20024,),
                'auth': [
                    'apiKey',
                    'headerApiKey'
                ],
                'endpoint_path': '/stem-text',
                'operation_id': 'text_stemming',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'text',
                ],
                'required': [
                    'text',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                    'text',
                ]
            },
            root_map={
                'validations': {
                    ('text',): {
                        'max_length': 10000,
                        'regex': {
                            'pattern': r'.',  # noqa: E501
                        },
                    },
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'text':
                        (str,),
                },
                'attribute_map': {
                    'text': 'text',
                },
                'location_map': {
                    'text': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )

    def correct_spelling(
        self,
        text,
        language,
        **kwargs
    ):
        """Correct Spelling  # noqa: E501

        The API corrects spelling mistakes in a given text. It returns the corrected text or the original text if nothing was corrected. This API supports text in the following languages: English (en), French (fr), German (de), Italian (it), and Spanish (es).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.correct_spelling(text, language, async_req=True)
        >>> result = thread.get()

        Args:
            text (str): The text to be corrected.
            language (str): The language of the text, one of en, de, es, fr, or it.

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            InlineResponse20016
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['text'] = \
            text
        kwargs['language'] = \
            language
        return self.correct_spelling_endpoint.call_with_http_info(**kwargs)

    def detect_language(
        self,
        text,
        **kwargs
    ):
        """Detect Language  # noqa: E501

        Detect the language of the given text. The API returns a list of languages and their confidence scores. The confidence score is a value between 0 and 1, where 1 means the language was detected with 100% confidence. The API supports text in 22 languages.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.detect_language(text, async_req=True)
        >>> result = thread.get()

        Args:
            text (str): The text for which the language should be detected.

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            [InlineResponse20017]
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['text'] = \
            text
        return self.detect_language_endpoint.call_with_http_info(**kwargs)

    def detect_sentiment(
        self,
        text,
        **kwargs
    ):
        """Detect Sentiment  # noqa: E501

        Detect the sentiment (positive or negative) of a given text. The entire document is scored and also each individual sentence.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.detect_sentiment(text, async_req=True)
        >>> result = thread.get()

        Args:
            text (str): The text for which the sentiment should be detected.

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            InlineResponse20018
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['text'] = \
            text
        return self.detect_sentiment_endpoint.call_with_http_info(**kwargs)

    def extract_dates(
        self,
        text,
        **kwargs
    ):
        """Extract Dates  # noqa: E501

        Extract dates from a given text. The API will return a list of dates with their positions in the text and the normalized form of the date. A large list of date formats is supported. For example, the text could contain dates in the form of \"April 5th, 2035\", \"04/05/2035\", or \"05.04.2035\". The normalized date is the date in the form of a timestamp (milliseconds since 1970).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.extract_dates(text, async_req=True)
        >>> result = thread.get()

        Args:
            text (str): The text from which dates should be extracted.

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            InlineResponse20021
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['text'] = \
            text
        return self.extract_dates_endpoint.call_with_http_info(**kwargs)

    def extract_entities(
        self,
        text,
        **kwargs
    ):
        """Extract Entities  # noqa: E501

        Extract entities from a text. An entity is a word or a group of words that represent a concept. For example, the word \"Canada\" represents the concept of a country. The word \"Jim Carrey\" represents the concept of a person. The word \"Tesla\" represents the concept of a company. The API will return a list of entities found in the text. The entities are classified into different types such as person, location, organization, etc.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.extract_entities(text, async_req=True)
        >>> result = thread.get()

        Args:
            text (str): The text from which entities should be extracted.

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            InlineResponse20027
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['text'] = \
            text
        return self.extract_entities_endpoint.call_with_http_info(**kwargs)

    def list_word_synonyms(
        self,
        word,
        **kwargs
    ):
        """List Word Synonyms  # noqa: E501

        Return synonyms of a word.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.list_word_synonyms(word, async_req=True)
        >>> result = thread.get()

        Args:
            word (str): The (noun) word for which a list of synonyms should be returned.

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            InlineResponse20022
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['word'] = \
            word
        return self.list_word_synonyms_endpoint.call_with_http_info(**kwargs)

    def part_of_speech_tagging(
        self,
        text,
        **kwargs
    ):
        """Part of Speech Tagging  # noqa: E501

        Part of speech tagging is the process of marking up a word in a text as corresponding to a particular part of speech, based on both its definition and its context. This is a simple API that takes a text and returns the tagged text.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.part_of_speech_tagging(text, async_req=True)
        >>> result = thread.get()

        Args:
            text (str): The text to tag the part of speech.

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            InlineResponse20023
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['text'] = \
            text
        return self.part_of_speech_tagging_endpoint.call_with_http_info(**kwargs)

    def pluralize_word(
        self,
        word,
        **kwargs
    ):
        """Pluralize Word  # noqa: E501

        Find the plural form of a word.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.pluralize_word(word, async_req=True)
        >>> result = thread.get()

        Args:
            word (str): The (noun) word for which the plural form should be found.

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            InlineResponse20026
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['word'] = \
            word
        return self.pluralize_word_endpoint.call_with_http_info(**kwargs)

    def score_readability(
        self,
        text,
        **kwargs
    ):
        """Score Readability  # noqa: E501

        Score the readability of a text. The readability score is based on the average length of the sentences and the average length of the words in the text. The text is score with multiple readability scores such as Flesch, Smog, ARI, LIX, Kincaid, Fog, and Coleman Liau.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.score_readability(text, async_req=True)
        >>> result = thread.get()

        Args:
            text (str): The text to score for readability.

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            InlineResponse20020
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['text'] = \
            text
        return self.score_readability_endpoint.call_with_http_info(**kwargs)

    def score_text(
        self,
        title,
        text,
        **kwargs
    ):
        """Score Text  # noqa: E501

        Score the readability, skimmability, interestingness, and style of a text. The readability score is based on the average length of the sentences and the average length of the words in the text. The text is scored with multiple readability scores such as Flesch, Smog, ARI, LIX, Kincaid, Fog, and Coleman Liau. Additionally, information such as the estimated reading time in seconds is returned.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.score_text(title, text, async_req=True)
        >>> result = thread.get()

        Args:
            title (str): The title of the text to score.
            text (str): The text to score for multiple metrics.

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            InlineResponse20019
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['title'] = \
            title
        kwargs['text'] = \
            text
        return self.score_text_endpoint.call_with_http_info(**kwargs)

    def singularize_word(
        self,
        word,
        **kwargs
    ):
        """Singularize Word  # noqa: E501

        Find the singular form of a word.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.singularize_word(word, async_req=True)
        >>> result = thread.get()

        Args:
            word (str): The (noun) word for which the singular form should be found.

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            InlineResponse20025
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['word'] = \
            word
        return self.singularize_word_endpoint.call_with_http_info(**kwargs)

    def text_stemming(
        self,
        text,
        **kwargs
    ):
        """Text Stemming  # noqa: E501

        The Text Stemming API is used to get the root form of a word. It is useful for searching and natural language processing.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.text_stemming(text, async_req=True)
        >>> result = thread.get()

        Args:
            text (str): The text to be stemmed.

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            InlineResponse20024
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['text'] = \
            text
        return self.text_stemming_endpoint.call_with_http_info(**kwargs)

