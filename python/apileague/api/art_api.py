# coding: utf-8

"""
    API League

    API League is a Hub for World Class APIs.

    The version of the OpenAPI document: 1.7.0
    Contact: mail@apileague.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictInt, StrictStr, field_validator
from typing import Optional, Union
from typing_extensions import Annotated
from apileague.models.art_search_api200_response import ArtSearchAPI200Response
from apileague.models.random_poem_api200_response import RandomPoemAPI200Response
from apileague.models.retrieve_artwork_by_id200_response import RetrieveArtworkById200Response

from apileague.api_client import ApiClient, RequestSerialized
from apileague.api_response import ApiResponse
from apileague.rest import RESTResponseType


class ArtApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def art_search_api(
        self,
        query: Annotated[Optional[Annotated[str, Field(strict=True, max_length=300)]], Field(description="The search query.")] = None,
        earliest_start_date: Annotated[Optional[StrictInt], Field(description="The artwork must have been created after this date.")] = None,
        latest_start_date: Annotated[Optional[StrictInt], Field(description="The artwork must have been created before this date.")] = None,
        earliest_end_date: Annotated[Optional[StrictInt], Field(description="For artworks with a period of creation, the completion date must be after this date.")] = None,
        latest_end_date: Annotated[Optional[StrictInt], Field(description="For artworks with a period of creation, the completion date must be before this date.")] = None,
        min_ratio: Annotated[Optional[Union[Annotated[float, Field(le=10, strict=True, ge=0)], Annotated[int, Field(le=10, strict=True, ge=0)]]], Field(description="The minimum aspect ratio (width/height) the artwork image must have.")] = None,
        max_ratio: Annotated[Optional[Union[Annotated[float, Field(le=10, strict=True, ge=0)], Annotated[int, Field(le=10, strict=True, ge=0)]]], Field(description="The maximum aspect ratio (width/height) the artwork image must have.")] = None,
        type: Annotated[Optional[Annotated[str, Field(strict=True, max_length=1000)]], Field(description="The artwork type. Possible values are tapestry, collotype, collage, printmaking, cutting, digital_art, sculpture, metalwork, fragment, token, embroidery, painting, jewellery, print, ornament, photograph, statuette, furniture, needlework, drawing, miniature, tile, stereograph, calligraphy.")] = None,
        material: Annotated[Optional[Annotated[str, Field(strict=True, max_length=1000)]], Field(description="The art material used. Possible values are ferrous_lactate, ink, textile, metal, bronze, canvas, stone, reduced_iron, horn, stoneware, in_shell_walnuts, chalk, velvet, silver, charcoal, gold_leaf, candied_walnuts, porcelain, walnut_halves, jade, cotton, paint, ferrous_fumarate, graphite, cobalt, sandstone, plastic, walnut_pieces, clay, walnuts, cupric_sulfate, ivory, ferric_orthophosphate, earthenware, tin, pen, linen, mahogany, electrolytic_iron, silk, crayon, black_walnuts, brush, beech_wood, terracotta, glass, lead, brass, oil_paint, pencil, leather, gold, marble, watercolor, diamond, iron, ferrous_sulfate, walnut_halves_and_pieces, gouache, wool, ceramic, parchment, cork, limestone, copper_gluconate, paper, pastel, copper, cardboard, plant_material, oak, wood.")] = None,
        technique: Annotated[Optional[Annotated[str, Field(strict=True, max_length=13)]], Field(description="The art technique used. Possible values are engraving, grinding, embroidering, etching, vitrification, gilding, lithography, knitting, cyanotype, silkscreen, woodcut, printing, drypoint, photolithography, weaving, sawing, casting, glassblowing, block_printing, photographing, forging.")] = None,
        origin: Annotated[Optional[Annotated[str, Field(strict=True, max_length=100)]], Field(description="The country or region of origin for the artwork")] = None,
        offset: Annotated[Optional[Annotated[int, Field(le=1000, strict=True, ge=0)]], Field(description="The number of artworks to skip in range [0,1000]")] = None,
        number: Annotated[Optional[Annotated[int, Field(le=10, strict=True, ge=1)]], Field(description="The number of artworks to return in range [1,10]")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ArtSearchAPI200Response:
        """Art Search API

        Search and filter artworks by query, creation time, material, technique, and origin. The natural language search uses semantic AI to understand the context of your query, so you can search for artworks by their style, subject, or even emotions they evoke. The API returns a list of artworks matching the given criteria.

        :param query: The search query.
        :type query: str
        :param earliest_start_date: The artwork must have been created after this date.
        :type earliest_start_date: int
        :param latest_start_date: The artwork must have been created before this date.
        :type latest_start_date: int
        :param earliest_end_date: For artworks with a period of creation, the completion date must be after this date.
        :type earliest_end_date: int
        :param latest_end_date: For artworks with a period of creation, the completion date must be before this date.
        :type latest_end_date: int
        :param min_ratio: The minimum aspect ratio (width/height) the artwork image must have.
        :type min_ratio: float
        :param max_ratio: The maximum aspect ratio (width/height) the artwork image must have.
        :type max_ratio: float
        :param type: The artwork type. Possible values are tapestry, collotype, collage, printmaking, cutting, digital_art, sculpture, metalwork, fragment, token, embroidery, painting, jewellery, print, ornament, photograph, statuette, furniture, needlework, drawing, miniature, tile, stereograph, calligraphy.
        :type type: str
        :param material: The art material used. Possible values are ferrous_lactate, ink, textile, metal, bronze, canvas, stone, reduced_iron, horn, stoneware, in_shell_walnuts, chalk, velvet, silver, charcoal, gold_leaf, candied_walnuts, porcelain, walnut_halves, jade, cotton, paint, ferrous_fumarate, graphite, cobalt, sandstone, plastic, walnut_pieces, clay, walnuts, cupric_sulfate, ivory, ferric_orthophosphate, earthenware, tin, pen, linen, mahogany, electrolytic_iron, silk, crayon, black_walnuts, brush, beech_wood, terracotta, glass, lead, brass, oil_paint, pencil, leather, gold, marble, watercolor, diamond, iron, ferrous_sulfate, walnut_halves_and_pieces, gouache, wool, ceramic, parchment, cork, limestone, copper_gluconate, paper, pastel, copper, cardboard, plant_material, oak, wood.
        :type material: str
        :param technique: The art technique used. Possible values are engraving, grinding, embroidering, etching, vitrification, gilding, lithography, knitting, cyanotype, silkscreen, woodcut, printing, drypoint, photolithography, weaving, sawing, casting, glassblowing, block_printing, photographing, forging.
        :type technique: str
        :param origin: The country or region of origin for the artwork
        :type origin: str
        :param offset: The number of artworks to skip in range [0,1000]
        :type offset: int
        :param number: The number of artworks to return in range [1,10]
        :type number: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._art_search_api_serialize(
            query=query,
            earliest_start_date=earliest_start_date,
            latest_start_date=latest_start_date,
            earliest_end_date=earliest_end_date,
            latest_end_date=latest_end_date,
            min_ratio=min_ratio,
            max_ratio=max_ratio,
            type=type,
            material=material,
            technique=technique,
            origin=origin,
            offset=offset,
            number=number,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ArtSearchAPI200Response",
            '401': None,
            '402': None,
            '403': None,
            '404': None,
            '406': None,
            '429': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def art_search_api_with_http_info(
        self,
        query: Annotated[Optional[Annotated[str, Field(strict=True, max_length=300)]], Field(description="The search query.")] = None,
        earliest_start_date: Annotated[Optional[StrictInt], Field(description="The artwork must have been created after this date.")] = None,
        latest_start_date: Annotated[Optional[StrictInt], Field(description="The artwork must have been created before this date.")] = None,
        earliest_end_date: Annotated[Optional[StrictInt], Field(description="For artworks with a period of creation, the completion date must be after this date.")] = None,
        latest_end_date: Annotated[Optional[StrictInt], Field(description="For artworks with a period of creation, the completion date must be before this date.")] = None,
        min_ratio: Annotated[Optional[Union[Annotated[float, Field(le=10, strict=True, ge=0)], Annotated[int, Field(le=10, strict=True, ge=0)]]], Field(description="The minimum aspect ratio (width/height) the artwork image must have.")] = None,
        max_ratio: Annotated[Optional[Union[Annotated[float, Field(le=10, strict=True, ge=0)], Annotated[int, Field(le=10, strict=True, ge=0)]]], Field(description="The maximum aspect ratio (width/height) the artwork image must have.")] = None,
        type: Annotated[Optional[Annotated[str, Field(strict=True, max_length=1000)]], Field(description="The artwork type. Possible values are tapestry, collotype, collage, printmaking, cutting, digital_art, sculpture, metalwork, fragment, token, embroidery, painting, jewellery, print, ornament, photograph, statuette, furniture, needlework, drawing, miniature, tile, stereograph, calligraphy.")] = None,
        material: Annotated[Optional[Annotated[str, Field(strict=True, max_length=1000)]], Field(description="The art material used. Possible values are ferrous_lactate, ink, textile, metal, bronze, canvas, stone, reduced_iron, horn, stoneware, in_shell_walnuts, chalk, velvet, silver, charcoal, gold_leaf, candied_walnuts, porcelain, walnut_halves, jade, cotton, paint, ferrous_fumarate, graphite, cobalt, sandstone, plastic, walnut_pieces, clay, walnuts, cupric_sulfate, ivory, ferric_orthophosphate, earthenware, tin, pen, linen, mahogany, electrolytic_iron, silk, crayon, black_walnuts, brush, beech_wood, terracotta, glass, lead, brass, oil_paint, pencil, leather, gold, marble, watercolor, diamond, iron, ferrous_sulfate, walnut_halves_and_pieces, gouache, wool, ceramic, parchment, cork, limestone, copper_gluconate, paper, pastel, copper, cardboard, plant_material, oak, wood.")] = None,
        technique: Annotated[Optional[Annotated[str, Field(strict=True, max_length=13)]], Field(description="The art technique used. Possible values are engraving, grinding, embroidering, etching, vitrification, gilding, lithography, knitting, cyanotype, silkscreen, woodcut, printing, drypoint, photolithography, weaving, sawing, casting, glassblowing, block_printing, photographing, forging.")] = None,
        origin: Annotated[Optional[Annotated[str, Field(strict=True, max_length=100)]], Field(description="The country or region of origin for the artwork")] = None,
        offset: Annotated[Optional[Annotated[int, Field(le=1000, strict=True, ge=0)]], Field(description="The number of artworks to skip in range [0,1000]")] = None,
        number: Annotated[Optional[Annotated[int, Field(le=10, strict=True, ge=1)]], Field(description="The number of artworks to return in range [1,10]")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ArtSearchAPI200Response]:
        """Art Search API

        Search and filter artworks by query, creation time, material, technique, and origin. The natural language search uses semantic AI to understand the context of your query, so you can search for artworks by their style, subject, or even emotions they evoke. The API returns a list of artworks matching the given criteria.

        :param query: The search query.
        :type query: str
        :param earliest_start_date: The artwork must have been created after this date.
        :type earliest_start_date: int
        :param latest_start_date: The artwork must have been created before this date.
        :type latest_start_date: int
        :param earliest_end_date: For artworks with a period of creation, the completion date must be after this date.
        :type earliest_end_date: int
        :param latest_end_date: For artworks with a period of creation, the completion date must be before this date.
        :type latest_end_date: int
        :param min_ratio: The minimum aspect ratio (width/height) the artwork image must have.
        :type min_ratio: float
        :param max_ratio: The maximum aspect ratio (width/height) the artwork image must have.
        :type max_ratio: float
        :param type: The artwork type. Possible values are tapestry, collotype, collage, printmaking, cutting, digital_art, sculpture, metalwork, fragment, token, embroidery, painting, jewellery, print, ornament, photograph, statuette, furniture, needlework, drawing, miniature, tile, stereograph, calligraphy.
        :type type: str
        :param material: The art material used. Possible values are ferrous_lactate, ink, textile, metal, bronze, canvas, stone, reduced_iron, horn, stoneware, in_shell_walnuts, chalk, velvet, silver, charcoal, gold_leaf, candied_walnuts, porcelain, walnut_halves, jade, cotton, paint, ferrous_fumarate, graphite, cobalt, sandstone, plastic, walnut_pieces, clay, walnuts, cupric_sulfate, ivory, ferric_orthophosphate, earthenware, tin, pen, linen, mahogany, electrolytic_iron, silk, crayon, black_walnuts, brush, beech_wood, terracotta, glass, lead, brass, oil_paint, pencil, leather, gold, marble, watercolor, diamond, iron, ferrous_sulfate, walnut_halves_and_pieces, gouache, wool, ceramic, parchment, cork, limestone, copper_gluconate, paper, pastel, copper, cardboard, plant_material, oak, wood.
        :type material: str
        :param technique: The art technique used. Possible values are engraving, grinding, embroidering, etching, vitrification, gilding, lithography, knitting, cyanotype, silkscreen, woodcut, printing, drypoint, photolithography, weaving, sawing, casting, glassblowing, block_printing, photographing, forging.
        :type technique: str
        :param origin: The country or region of origin for the artwork
        :type origin: str
        :param offset: The number of artworks to skip in range [0,1000]
        :type offset: int
        :param number: The number of artworks to return in range [1,10]
        :type number: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._art_search_api_serialize(
            query=query,
            earliest_start_date=earliest_start_date,
            latest_start_date=latest_start_date,
            earliest_end_date=earliest_end_date,
            latest_end_date=latest_end_date,
            min_ratio=min_ratio,
            max_ratio=max_ratio,
            type=type,
            material=material,
            technique=technique,
            origin=origin,
            offset=offset,
            number=number,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ArtSearchAPI200Response",
            '401': None,
            '402': None,
            '403': None,
            '404': None,
            '406': None,
            '429': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def art_search_api_without_preload_content(
        self,
        query: Annotated[Optional[Annotated[str, Field(strict=True, max_length=300)]], Field(description="The search query.")] = None,
        earliest_start_date: Annotated[Optional[StrictInt], Field(description="The artwork must have been created after this date.")] = None,
        latest_start_date: Annotated[Optional[StrictInt], Field(description="The artwork must have been created before this date.")] = None,
        earliest_end_date: Annotated[Optional[StrictInt], Field(description="For artworks with a period of creation, the completion date must be after this date.")] = None,
        latest_end_date: Annotated[Optional[StrictInt], Field(description="For artworks with a period of creation, the completion date must be before this date.")] = None,
        min_ratio: Annotated[Optional[Union[Annotated[float, Field(le=10, strict=True, ge=0)], Annotated[int, Field(le=10, strict=True, ge=0)]]], Field(description="The minimum aspect ratio (width/height) the artwork image must have.")] = None,
        max_ratio: Annotated[Optional[Union[Annotated[float, Field(le=10, strict=True, ge=0)], Annotated[int, Field(le=10, strict=True, ge=0)]]], Field(description="The maximum aspect ratio (width/height) the artwork image must have.")] = None,
        type: Annotated[Optional[Annotated[str, Field(strict=True, max_length=1000)]], Field(description="The artwork type. Possible values are tapestry, collotype, collage, printmaking, cutting, digital_art, sculpture, metalwork, fragment, token, embroidery, painting, jewellery, print, ornament, photograph, statuette, furniture, needlework, drawing, miniature, tile, stereograph, calligraphy.")] = None,
        material: Annotated[Optional[Annotated[str, Field(strict=True, max_length=1000)]], Field(description="The art material used. Possible values are ferrous_lactate, ink, textile, metal, bronze, canvas, stone, reduced_iron, horn, stoneware, in_shell_walnuts, chalk, velvet, silver, charcoal, gold_leaf, candied_walnuts, porcelain, walnut_halves, jade, cotton, paint, ferrous_fumarate, graphite, cobalt, sandstone, plastic, walnut_pieces, clay, walnuts, cupric_sulfate, ivory, ferric_orthophosphate, earthenware, tin, pen, linen, mahogany, electrolytic_iron, silk, crayon, black_walnuts, brush, beech_wood, terracotta, glass, lead, brass, oil_paint, pencil, leather, gold, marble, watercolor, diamond, iron, ferrous_sulfate, walnut_halves_and_pieces, gouache, wool, ceramic, parchment, cork, limestone, copper_gluconate, paper, pastel, copper, cardboard, plant_material, oak, wood.")] = None,
        technique: Annotated[Optional[Annotated[str, Field(strict=True, max_length=13)]], Field(description="The art technique used. Possible values are engraving, grinding, embroidering, etching, vitrification, gilding, lithography, knitting, cyanotype, silkscreen, woodcut, printing, drypoint, photolithography, weaving, sawing, casting, glassblowing, block_printing, photographing, forging.")] = None,
        origin: Annotated[Optional[Annotated[str, Field(strict=True, max_length=100)]], Field(description="The country or region of origin for the artwork")] = None,
        offset: Annotated[Optional[Annotated[int, Field(le=1000, strict=True, ge=0)]], Field(description="The number of artworks to skip in range [0,1000]")] = None,
        number: Annotated[Optional[Annotated[int, Field(le=10, strict=True, ge=1)]], Field(description="The number of artworks to return in range [1,10]")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Art Search API

        Search and filter artworks by query, creation time, material, technique, and origin. The natural language search uses semantic AI to understand the context of your query, so you can search for artworks by their style, subject, or even emotions they evoke. The API returns a list of artworks matching the given criteria.

        :param query: The search query.
        :type query: str
        :param earliest_start_date: The artwork must have been created after this date.
        :type earliest_start_date: int
        :param latest_start_date: The artwork must have been created before this date.
        :type latest_start_date: int
        :param earliest_end_date: For artworks with a period of creation, the completion date must be after this date.
        :type earliest_end_date: int
        :param latest_end_date: For artworks with a period of creation, the completion date must be before this date.
        :type latest_end_date: int
        :param min_ratio: The minimum aspect ratio (width/height) the artwork image must have.
        :type min_ratio: float
        :param max_ratio: The maximum aspect ratio (width/height) the artwork image must have.
        :type max_ratio: float
        :param type: The artwork type. Possible values are tapestry, collotype, collage, printmaking, cutting, digital_art, sculpture, metalwork, fragment, token, embroidery, painting, jewellery, print, ornament, photograph, statuette, furniture, needlework, drawing, miniature, tile, stereograph, calligraphy.
        :type type: str
        :param material: The art material used. Possible values are ferrous_lactate, ink, textile, metal, bronze, canvas, stone, reduced_iron, horn, stoneware, in_shell_walnuts, chalk, velvet, silver, charcoal, gold_leaf, candied_walnuts, porcelain, walnut_halves, jade, cotton, paint, ferrous_fumarate, graphite, cobalt, sandstone, plastic, walnut_pieces, clay, walnuts, cupric_sulfate, ivory, ferric_orthophosphate, earthenware, tin, pen, linen, mahogany, electrolytic_iron, silk, crayon, black_walnuts, brush, beech_wood, terracotta, glass, lead, brass, oil_paint, pencil, leather, gold, marble, watercolor, diamond, iron, ferrous_sulfate, walnut_halves_and_pieces, gouache, wool, ceramic, parchment, cork, limestone, copper_gluconate, paper, pastel, copper, cardboard, plant_material, oak, wood.
        :type material: str
        :param technique: The art technique used. Possible values are engraving, grinding, embroidering, etching, vitrification, gilding, lithography, knitting, cyanotype, silkscreen, woodcut, printing, drypoint, photolithography, weaving, sawing, casting, glassblowing, block_printing, photographing, forging.
        :type technique: str
        :param origin: The country or region of origin for the artwork
        :type origin: str
        :param offset: The number of artworks to skip in range [0,1000]
        :type offset: int
        :param number: The number of artworks to return in range [1,10]
        :type number: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._art_search_api_serialize(
            query=query,
            earliest_start_date=earliest_start_date,
            latest_start_date=latest_start_date,
            earliest_end_date=earliest_end_date,
            latest_end_date=latest_end_date,
            min_ratio=min_ratio,
            max_ratio=max_ratio,
            type=type,
            material=material,
            technique=technique,
            origin=origin,
            offset=offset,
            number=number,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ArtSearchAPI200Response",
            '401': None,
            '402': None,
            '403': None,
            '404': None,
            '406': None,
            '429': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _art_search_api_serialize(
        self,
        query,
        earliest_start_date,
        latest_start_date,
        earliest_end_date,
        latest_end_date,
        min_ratio,
        max_ratio,
        type,
        material,
        technique,
        origin,
        offset,
        number,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if query is not None:
            
            _query_params.append(('query', query))
            
        if earliest_start_date is not None:
            
            _query_params.append(('earliest-start-date', earliest_start_date))
            
        if latest_start_date is not None:
            
            _query_params.append(('latest-start-date', latest_start_date))
            
        if earliest_end_date is not None:
            
            _query_params.append(('earliest-end-date', earliest_end_date))
            
        if latest_end_date is not None:
            
            _query_params.append(('latest-end-date', latest_end_date))
            
        if min_ratio is not None:
            
            _query_params.append(('min-ratio', min_ratio))
            
        if max_ratio is not None:
            
            _query_params.append(('max-ratio', max_ratio))
            
        if type is not None:
            
            _query_params.append(('type', type))
            
        if material is not None:
            
            _query_params.append(('material', material))
            
        if technique is not None:
            
            _query_params.append(('technique', technique))
            
        if origin is not None:
            
            _query_params.append(('origin', origin))
            
        if offset is not None:
            
            _query_params.append(('offset', offset))
            
        if number is not None:
            
            _query_params.append(('number', number))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'apiKey', 
            'headerApiKey'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/search-artworks',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def image_to_ascii_art_by_urlapi(
        self,
        url: Annotated[str, Field(strict=True, max_length=1000, description="The URL to the image.")],
        width: Annotated[Optional[Annotated[int, Field(le=500, strict=True, ge=1)]], Field(description="The maximum width of the image (default 400, max. 500).")] = None,
        height: Annotated[Optional[Annotated[int, Field(le=500, strict=True, ge=1)]], Field(description="The maximum height of the image (default 400, max. 500).")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> str:
        """Image to Ascii Art by URL API

        Convert an image to ASCII art. You can pass the image URL as a query parameter. The API returns the ASCII art as plain text. This endpoint is using the GET method and an image URL as a query parameter.

        :param url: The URL to the image. (required)
        :type url: str
        :param width: The maximum width of the image (default 400, max. 500).
        :type width: int
        :param height: The maximum height of the image (default 400, max. 500).
        :type height: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._image_to_ascii_art_by_urlapi_serialize(
            url=url,
            width=width,
            height=height,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "str",
            '401': None,
            '402': None,
            '403': None,
            '404': None,
            '406': None,
            '429': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def image_to_ascii_art_by_urlapi_with_http_info(
        self,
        url: Annotated[str, Field(strict=True, max_length=1000, description="The URL to the image.")],
        width: Annotated[Optional[Annotated[int, Field(le=500, strict=True, ge=1)]], Field(description="The maximum width of the image (default 400, max. 500).")] = None,
        height: Annotated[Optional[Annotated[int, Field(le=500, strict=True, ge=1)]], Field(description="The maximum height of the image (default 400, max. 500).")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[str]:
        """Image to Ascii Art by URL API

        Convert an image to ASCII art. You can pass the image URL as a query parameter. The API returns the ASCII art as plain text. This endpoint is using the GET method and an image URL as a query parameter.

        :param url: The URL to the image. (required)
        :type url: str
        :param width: The maximum width of the image (default 400, max. 500).
        :type width: int
        :param height: The maximum height of the image (default 400, max. 500).
        :type height: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._image_to_ascii_art_by_urlapi_serialize(
            url=url,
            width=width,
            height=height,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "str",
            '401': None,
            '402': None,
            '403': None,
            '404': None,
            '406': None,
            '429': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def image_to_ascii_art_by_urlapi_without_preload_content(
        self,
        url: Annotated[str, Field(strict=True, max_length=1000, description="The URL to the image.")],
        width: Annotated[Optional[Annotated[int, Field(le=500, strict=True, ge=1)]], Field(description="The maximum width of the image (default 400, max. 500).")] = None,
        height: Annotated[Optional[Annotated[int, Field(le=500, strict=True, ge=1)]], Field(description="The maximum height of the image (default 400, max. 500).")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Image to Ascii Art by URL API

        Convert an image to ASCII art. You can pass the image URL as a query parameter. The API returns the ASCII art as plain text. This endpoint is using the GET method and an image URL as a query parameter.

        :param url: The URL to the image. (required)
        :type url: str
        :param width: The maximum width of the image (default 400, max. 500).
        :type width: int
        :param height: The maximum height of the image (default 400, max. 500).
        :type height: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._image_to_ascii_art_by_urlapi_serialize(
            url=url,
            width=width,
            height=height,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "str",
            '401': None,
            '402': None,
            '403': None,
            '404': None,
            '406': None,
            '429': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _image_to_ascii_art_by_urlapi_serialize(
        self,
        url,
        width,
        height,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if url is not None:
            
            _query_params.append(('url', url))
            
        if width is not None:
            
            _query_params.append(('width', width))
            
        if height is not None:
            
            _query_params.append(('height', height))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'text/plain'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'apiKey', 
            'headerApiKey'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/convert-image-to-ascii-txt',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def random_poem_api(
        self,
        min_lines: Annotated[Optional[Annotated[int, Field(le=1000, strict=True, ge=0)]], Field(description="The minimum number of lines of the poem.")] = None,
        max_lines: Annotated[Optional[Annotated[int, Field(le=1000, strict=True, ge=0)]], Field(description="The maximum number of lines of the poem.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RandomPoemAPI200Response:
        """Random Poem API

        Retrieve a random poem by many famous authors. You can filter poem's by length (number of lines).

        :param min_lines: The minimum number of lines of the poem.
        :type min_lines: int
        :param max_lines: The maximum number of lines of the poem.
        :type max_lines: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._random_poem_api_serialize(
            min_lines=min_lines,
            max_lines=max_lines,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "RandomPoemAPI200Response",
            '401': None,
            '402': None,
            '403': None,
            '404': None,
            '406': None,
            '429': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def random_poem_api_with_http_info(
        self,
        min_lines: Annotated[Optional[Annotated[int, Field(le=1000, strict=True, ge=0)]], Field(description="The minimum number of lines of the poem.")] = None,
        max_lines: Annotated[Optional[Annotated[int, Field(le=1000, strict=True, ge=0)]], Field(description="The maximum number of lines of the poem.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[RandomPoemAPI200Response]:
        """Random Poem API

        Retrieve a random poem by many famous authors. You can filter poem's by length (number of lines).

        :param min_lines: The minimum number of lines of the poem.
        :type min_lines: int
        :param max_lines: The maximum number of lines of the poem.
        :type max_lines: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._random_poem_api_serialize(
            min_lines=min_lines,
            max_lines=max_lines,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "RandomPoemAPI200Response",
            '401': None,
            '402': None,
            '403': None,
            '404': None,
            '406': None,
            '429': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def random_poem_api_without_preload_content(
        self,
        min_lines: Annotated[Optional[Annotated[int, Field(le=1000, strict=True, ge=0)]], Field(description="The minimum number of lines of the poem.")] = None,
        max_lines: Annotated[Optional[Annotated[int, Field(le=1000, strict=True, ge=0)]], Field(description="The maximum number of lines of the poem.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Random Poem API

        Retrieve a random poem by many famous authors. You can filter poem's by length (number of lines).

        :param min_lines: The minimum number of lines of the poem.
        :type min_lines: int
        :param max_lines: The maximum number of lines of the poem.
        :type max_lines: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._random_poem_api_serialize(
            min_lines=min_lines,
            max_lines=max_lines,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "RandomPoemAPI200Response",
            '401': None,
            '402': None,
            '403': None,
            '404': None,
            '406': None,
            '429': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _random_poem_api_serialize(
        self,
        min_lines,
        max_lines,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if min_lines is not None:
            
            _query_params.append(('min-lines', min_lines))
            
        if max_lines is not None:
            
            _query_params.append(('max-lines', max_lines))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'apiKey', 
            'headerApiKey'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/retrieve-random-poem',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def retrieve_artwork_by_id(
        self,
        id: Annotated[int, Field(le=99999999, strict=True, ge=0, description="The id of the artwork.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RetrieveArtworkById200Response:
        """Retrieve Artwork by Id

        Get one artwork by its id. The API returns the title, image URL, start and end date, and a description of the artwork.

        :param id: The id of the artwork. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._retrieve_artwork_by_id_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "RetrieveArtworkById200Response",
            '401': None,
            '402': None,
            '403': None,
            '404': None,
            '406': None,
            '429': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def retrieve_artwork_by_id_with_http_info(
        self,
        id: Annotated[int, Field(le=99999999, strict=True, ge=0, description="The id of the artwork.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[RetrieveArtworkById200Response]:
        """Retrieve Artwork by Id

        Get one artwork by its id. The API returns the title, image URL, start and end date, and a description of the artwork.

        :param id: The id of the artwork. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._retrieve_artwork_by_id_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "RetrieveArtworkById200Response",
            '401': None,
            '402': None,
            '403': None,
            '404': None,
            '406': None,
            '429': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def retrieve_artwork_by_id_without_preload_content(
        self,
        id: Annotated[int, Field(le=99999999, strict=True, ge=0, description="The id of the artwork.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Retrieve Artwork by Id

        Get one artwork by its id. The API returns the title, image URL, start and end date, and a description of the artwork.

        :param id: The id of the artwork. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._retrieve_artwork_by_id_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "RetrieveArtworkById200Response",
            '401': None,
            '402': None,
            '403': None,
            '404': None,
            '406': None,
            '429': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _retrieve_artwork_by_id_serialize(
        self,
        id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if id is not None:
            
            _query_params.append(('id', id))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'apiKey', 
            'headerApiKey'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/retrieve-artwork',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


