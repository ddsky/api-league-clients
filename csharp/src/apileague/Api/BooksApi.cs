/*
 * API League
 *
 * API League is a Hub for World Class APIs.
 *
 * The version of the OpenAPI document: 1.4.1
 * Contact: mail@apileague.com
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */


using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.Net;
using System.Net.Mime;
using apileague.Client;
using apileague.Model;

namespace apileague.Api
{

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IBooksApiSync : IApiAccessor
    {
        #region Synchronous Operations
        /// <summary>
        /// Find Similar Books
        /// </summary>
        /// <remarks>
        /// Find books that are similar to the given book. This is useful for recommending books to users based on their reading history or preferences. The response will contain a list of similar books with their title, id, and cover image.
        /// </remarks>
        /// <exception cref="apileague.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the book to which similar books should be found.</param>
        /// <param name="number">The number of similar books to return in range [1,100] (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>FindSimilarBooks200Response</returns>
        FindSimilarBooks200Response FindSimilarBooks(int id, int? number = default(int?), int operationIndex = 0);

        /// <summary>
        /// Find Similar Books
        /// </summary>
        /// <remarks>
        /// Find books that are similar to the given book. This is useful for recommending books to users based on their reading history or preferences. The response will contain a list of similar books with their title, id, and cover image.
        /// </remarks>
        /// <exception cref="apileague.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the book to which similar books should be found.</param>
        /// <param name="number">The number of similar books to return in range [1,100] (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of FindSimilarBooks200Response</returns>
        ApiResponse<FindSimilarBooks200Response> FindSimilarBooksWithHttpInfo(int id, int? number = default(int?), int operationIndex = 0);
        /// <summary>
        /// Search Books
        /// </summary>
        /// <remarks>
        /// Search and filter books based on matching a query, the ISBN, rating, and more fields. The query is semantically parsed using our own large ontology. That means you can search paranormal books and the ontology knows that Aliens, Werewolves, Ghosts, and Shapeshifters fall into that category.
        /// </remarks>
        /// <exception cref="apileague.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="query">The search query. (optional)</param>
        /// <param name="earliestPublishYear">The books must have been published after this year. (optional)</param>
        /// <param name="latestPublishYear">The books must have been published before this year. (optional)</param>
        /// <param name="minRating">The minimum rating the book must have gotten in the interval [0,1]. (optional)</param>
        /// <param name="maxRating">The maximum rating the book must have gotten in the interval [0,1]. (optional)</param>
        /// <param name="genres">A comma-separated list of genres. Only books from any of the given genres will be returned. (optional)</param>
        /// <param name="authors">A comma-separated list of author ids or names. Only books from any of the given authors will be returned. You can retrieve author ids from the search authors endpoint. Pass author names is slower and if two authors have the same name you can&#39;t disambiguate. (optional)</param>
        /// <param name="isbn">Only the book matching the ISBN-13 will be returned (optional)</param>
        /// <param name="oclc">Only the book matching the OCLC will be returned (optional)</param>
        /// <param name="sort">The sorting criteria (publish-date or rating). (optional)</param>
        /// <param name="sortDirection">Whether to sort ascending or descending (ASC or DESC). (optional)</param>
        /// <param name="groupResults">Whether to group similar editions of the same book. (optional)</param>
        /// <param name="offset">The number of books to skip in range [0,1000] (optional)</param>
        /// <param name="number">The number of books to return in range [1,100] (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>SearchBooks200Response</returns>
        SearchBooks200Response SearchBooks(string? query = default(string?), int? earliestPublishYear = default(int?), int? latestPublishYear = default(int?), double? minRating = default(double?), double? maxRating = default(double?), string? genres = default(string?), string? authors = default(string?), string? isbn = default(string?), string? oclc = default(string?), string? sort = default(string?), string? sortDirection = default(string?), bool? groupResults = default(bool?), int? offset = default(int?), int? number = default(int?), int operationIndex = 0);

        /// <summary>
        /// Search Books
        /// </summary>
        /// <remarks>
        /// Search and filter books based on matching a query, the ISBN, rating, and more fields. The query is semantically parsed using our own large ontology. That means you can search paranormal books and the ontology knows that Aliens, Werewolves, Ghosts, and Shapeshifters fall into that category.
        /// </remarks>
        /// <exception cref="apileague.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="query">The search query. (optional)</param>
        /// <param name="earliestPublishYear">The books must have been published after this year. (optional)</param>
        /// <param name="latestPublishYear">The books must have been published before this year. (optional)</param>
        /// <param name="minRating">The minimum rating the book must have gotten in the interval [0,1]. (optional)</param>
        /// <param name="maxRating">The maximum rating the book must have gotten in the interval [0,1]. (optional)</param>
        /// <param name="genres">A comma-separated list of genres. Only books from any of the given genres will be returned. (optional)</param>
        /// <param name="authors">A comma-separated list of author ids or names. Only books from any of the given authors will be returned. You can retrieve author ids from the search authors endpoint. Pass author names is slower and if two authors have the same name you can&#39;t disambiguate. (optional)</param>
        /// <param name="isbn">Only the book matching the ISBN-13 will be returned (optional)</param>
        /// <param name="oclc">Only the book matching the OCLC will be returned (optional)</param>
        /// <param name="sort">The sorting criteria (publish-date or rating). (optional)</param>
        /// <param name="sortDirection">Whether to sort ascending or descending (ASC or DESC). (optional)</param>
        /// <param name="groupResults">Whether to group similar editions of the same book. (optional)</param>
        /// <param name="offset">The number of books to skip in range [0,1000] (optional)</param>
        /// <param name="number">The number of books to return in range [1,100] (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of SearchBooks200Response</returns>
        ApiResponse<SearchBooks200Response> SearchBooksWithHttpInfo(string? query = default(string?), int? earliestPublishYear = default(int?), int? latestPublishYear = default(int?), double? minRating = default(double?), double? maxRating = default(double?), string? genres = default(string?), string? authors = default(string?), string? isbn = default(string?), string? oclc = default(string?), string? sort = default(string?), string? sortDirection = default(string?), bool? groupResults = default(bool?), int? offset = default(int?), int? number = default(int?), int operationIndex = 0);
        #endregion Synchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IBooksApiAsync : IApiAccessor
    {
        #region Asynchronous Operations
        /// <summary>
        /// Find Similar Books
        /// </summary>
        /// <remarks>
        /// Find books that are similar to the given book. This is useful for recommending books to users based on their reading history or preferences. The response will contain a list of similar books with their title, id, and cover image.
        /// </remarks>
        /// <exception cref="apileague.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the book to which similar books should be found.</param>
        /// <param name="number">The number of similar books to return in range [1,100] (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of FindSimilarBooks200Response</returns>
        System.Threading.Tasks.Task<FindSimilarBooks200Response> FindSimilarBooksAsync(int id, int? number = default(int?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Find Similar Books
        /// </summary>
        /// <remarks>
        /// Find books that are similar to the given book. This is useful for recommending books to users based on their reading history or preferences. The response will contain a list of similar books with their title, id, and cover image.
        /// </remarks>
        /// <exception cref="apileague.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the book to which similar books should be found.</param>
        /// <param name="number">The number of similar books to return in range [1,100] (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (FindSimilarBooks200Response)</returns>
        System.Threading.Tasks.Task<ApiResponse<FindSimilarBooks200Response>> FindSimilarBooksWithHttpInfoAsync(int id, int? number = default(int?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Search Books
        /// </summary>
        /// <remarks>
        /// Search and filter books based on matching a query, the ISBN, rating, and more fields. The query is semantically parsed using our own large ontology. That means you can search paranormal books and the ontology knows that Aliens, Werewolves, Ghosts, and Shapeshifters fall into that category.
        /// </remarks>
        /// <exception cref="apileague.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="query">The search query. (optional)</param>
        /// <param name="earliestPublishYear">The books must have been published after this year. (optional)</param>
        /// <param name="latestPublishYear">The books must have been published before this year. (optional)</param>
        /// <param name="minRating">The minimum rating the book must have gotten in the interval [0,1]. (optional)</param>
        /// <param name="maxRating">The maximum rating the book must have gotten in the interval [0,1]. (optional)</param>
        /// <param name="genres">A comma-separated list of genres. Only books from any of the given genres will be returned. (optional)</param>
        /// <param name="authors">A comma-separated list of author ids or names. Only books from any of the given authors will be returned. You can retrieve author ids from the search authors endpoint. Pass author names is slower and if two authors have the same name you can&#39;t disambiguate. (optional)</param>
        /// <param name="isbn">Only the book matching the ISBN-13 will be returned (optional)</param>
        /// <param name="oclc">Only the book matching the OCLC will be returned (optional)</param>
        /// <param name="sort">The sorting criteria (publish-date or rating). (optional)</param>
        /// <param name="sortDirection">Whether to sort ascending or descending (ASC or DESC). (optional)</param>
        /// <param name="groupResults">Whether to group similar editions of the same book. (optional)</param>
        /// <param name="offset">The number of books to skip in range [0,1000] (optional)</param>
        /// <param name="number">The number of books to return in range [1,100] (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of SearchBooks200Response</returns>
        System.Threading.Tasks.Task<SearchBooks200Response> SearchBooksAsync(string? query = default(string?), int? earliestPublishYear = default(int?), int? latestPublishYear = default(int?), double? minRating = default(double?), double? maxRating = default(double?), string? genres = default(string?), string? authors = default(string?), string? isbn = default(string?), string? oclc = default(string?), string? sort = default(string?), string? sortDirection = default(string?), bool? groupResults = default(bool?), int? offset = default(int?), int? number = default(int?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Search Books
        /// </summary>
        /// <remarks>
        /// Search and filter books based on matching a query, the ISBN, rating, and more fields. The query is semantically parsed using our own large ontology. That means you can search paranormal books and the ontology knows that Aliens, Werewolves, Ghosts, and Shapeshifters fall into that category.
        /// </remarks>
        /// <exception cref="apileague.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="query">The search query. (optional)</param>
        /// <param name="earliestPublishYear">The books must have been published after this year. (optional)</param>
        /// <param name="latestPublishYear">The books must have been published before this year. (optional)</param>
        /// <param name="minRating">The minimum rating the book must have gotten in the interval [0,1]. (optional)</param>
        /// <param name="maxRating">The maximum rating the book must have gotten in the interval [0,1]. (optional)</param>
        /// <param name="genres">A comma-separated list of genres. Only books from any of the given genres will be returned. (optional)</param>
        /// <param name="authors">A comma-separated list of author ids or names. Only books from any of the given authors will be returned. You can retrieve author ids from the search authors endpoint. Pass author names is slower and if two authors have the same name you can&#39;t disambiguate. (optional)</param>
        /// <param name="isbn">Only the book matching the ISBN-13 will be returned (optional)</param>
        /// <param name="oclc">Only the book matching the OCLC will be returned (optional)</param>
        /// <param name="sort">The sorting criteria (publish-date or rating). (optional)</param>
        /// <param name="sortDirection">Whether to sort ascending or descending (ASC or DESC). (optional)</param>
        /// <param name="groupResults">Whether to group similar editions of the same book. (optional)</param>
        /// <param name="offset">The number of books to skip in range [0,1000] (optional)</param>
        /// <param name="number">The number of books to return in range [1,100] (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (SearchBooks200Response)</returns>
        System.Threading.Tasks.Task<ApiResponse<SearchBooks200Response>> SearchBooksWithHttpInfoAsync(string? query = default(string?), int? earliestPublishYear = default(int?), int? latestPublishYear = default(int?), double? minRating = default(double?), double? maxRating = default(double?), string? genres = default(string?), string? authors = default(string?), string? isbn = default(string?), string? oclc = default(string?), string? sort = default(string?), string? sortDirection = default(string?), bool? groupResults = default(bool?), int? offset = default(int?), int? number = default(int?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        #endregion Asynchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IBooksApi : IBooksApiSync, IBooksApiAsync
    {

    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public partial class BooksApi : IBooksApi
    {
        private apileague.Client.ExceptionFactory _exceptionFactory = (name, response) => null;

        /// <summary>
        /// Initializes a new instance of the <see cref="BooksApi"/> class.
        /// </summary>
        /// <returns></returns>
        public BooksApi() : this((string)null)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="BooksApi"/> class.
        /// </summary>
        /// <returns></returns>
        public BooksApi(string basePath)
        {
            this.Configuration = apileague.Client.Configuration.MergeConfigurations(
                apileague.Client.GlobalConfiguration.Instance,
                new apileague.Client.Configuration { BasePath = basePath }
            );
            this.Client = new apileague.Client.ApiClient(this.Configuration.BasePath);
            this.AsynchronousClient = new apileague.Client.ApiClient(this.Configuration.BasePath);
            this.ExceptionFactory = apileague.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="BooksApi"/> class
        /// using Configuration object
        /// </summary>
        /// <param name="configuration">An instance of Configuration</param>
        /// <returns></returns>
        public BooksApi(apileague.Client.Configuration configuration)
        {
            if (configuration == null) throw new ArgumentNullException("configuration");

            this.Configuration = apileague.Client.Configuration.MergeConfigurations(
                apileague.Client.GlobalConfiguration.Instance,
                configuration
            );
            this.Client = new apileague.Client.ApiClient(this.Configuration.BasePath);
            this.AsynchronousClient = new apileague.Client.ApiClient(this.Configuration.BasePath);
            ExceptionFactory = apileague.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="BooksApi"/> class
        /// using a Configuration object and client instance.
        /// </summary>
        /// <param name="client">The client interface for synchronous API access.</param>
        /// <param name="asyncClient">The client interface for asynchronous API access.</param>
        /// <param name="configuration">The configuration object.</param>
        public BooksApi(apileague.Client.ISynchronousClient client, apileague.Client.IAsynchronousClient asyncClient, apileague.Client.IReadableConfiguration configuration)
        {
            if (client == null) throw new ArgumentNullException("client");
            if (asyncClient == null) throw new ArgumentNullException("asyncClient");
            if (configuration == null) throw new ArgumentNullException("configuration");

            this.Client = client;
            this.AsynchronousClient = asyncClient;
            this.Configuration = configuration;
            this.ExceptionFactory = apileague.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// The client for accessing this underlying API asynchronously.
        /// </summary>
        public apileague.Client.IAsynchronousClient AsynchronousClient { get; set; }

        /// <summary>
        /// The client for accessing this underlying API synchronously.
        /// </summary>
        public apileague.Client.ISynchronousClient Client { get; set; }

        /// <summary>
        /// Gets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        public string GetBasePath()
        {
            return this.Configuration.BasePath;
        }

        /// <summary>
        /// Gets or sets the configuration object
        /// </summary>
        /// <value>An instance of the Configuration</value>
        public apileague.Client.IReadableConfiguration Configuration { get; set; }

        /// <summary>
        /// Provides a factory method hook for the creation of exceptions.
        /// </summary>
        public apileague.Client.ExceptionFactory ExceptionFactory
        {
            get
            {
                if (_exceptionFactory != null && _exceptionFactory.GetInvocationList().Length > 1)
                {
                    throw new InvalidOperationException("Multicast delegate for ExceptionFactory is unsupported.");
                }
                return _exceptionFactory;
            }
            set { _exceptionFactory = value; }
        }

        /// <summary>
        /// Find Similar Books Find books that are similar to the given book. This is useful for recommending books to users based on their reading history or preferences. The response will contain a list of similar books with their title, id, and cover image.
        /// </summary>
        /// <exception cref="apileague.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the book to which similar books should be found.</param>
        /// <param name="number">The number of similar books to return in range [1,100] (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>FindSimilarBooks200Response</returns>
        public FindSimilarBooks200Response FindSimilarBooks(int id, int? number = default(int?), int operationIndex = 0)
        {
            apileague.Client.ApiResponse<FindSimilarBooks200Response> localVarResponse = FindSimilarBooksWithHttpInfo(id, number);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Find Similar Books Find books that are similar to the given book. This is useful for recommending books to users based on their reading history or preferences. The response will contain a list of similar books with their title, id, and cover image.
        /// </summary>
        /// <exception cref="apileague.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the book to which similar books should be found.</param>
        /// <param name="number">The number of similar books to return in range [1,100] (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of FindSimilarBooks200Response</returns>
        public apileague.Client.ApiResponse<FindSimilarBooks200Response> FindSimilarBooksWithHttpInfo(int id, int? number = default(int?), int operationIndex = 0)
        {
            apileague.Client.RequestOptions localVarRequestOptions = new apileague.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = apileague.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = apileague.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("id", apileague.Client.ClientUtils.ParameterToString(id)); // path parameter
            if (number != null)
            {
                localVarRequestOptions.QueryParameters.Add(apileague.Client.ClientUtils.ParameterToMultiMap("", "number", number));
            }

            localVarRequestOptions.Operation = "BooksApi.FindSimilarBooks";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (apiKey) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("api-key")))
            {
                localVarRequestOptions.QueryParameters.Add(apileague.Client.ClientUtils.ParameterToMultiMap("", "api-key", this.Configuration.GetApiKeyWithPrefix("api-key")));
            }
            // authentication (headerApiKey) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<FindSimilarBooks200Response>("/list-similar-books", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("FindSimilarBooks", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Find Similar Books Find books that are similar to the given book. This is useful for recommending books to users based on their reading history or preferences. The response will contain a list of similar books with their title, id, and cover image.
        /// </summary>
        /// <exception cref="apileague.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the book to which similar books should be found.</param>
        /// <param name="number">The number of similar books to return in range [1,100] (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of FindSimilarBooks200Response</returns>
        public async System.Threading.Tasks.Task<FindSimilarBooks200Response> FindSimilarBooksAsync(int id, int? number = default(int?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            apileague.Client.ApiResponse<FindSimilarBooks200Response> localVarResponse = await FindSimilarBooksWithHttpInfoAsync(id, number, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Find Similar Books Find books that are similar to the given book. This is useful for recommending books to users based on their reading history or preferences. The response will contain a list of similar books with their title, id, and cover image.
        /// </summary>
        /// <exception cref="apileague.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the book to which similar books should be found.</param>
        /// <param name="number">The number of similar books to return in range [1,100] (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (FindSimilarBooks200Response)</returns>
        public async System.Threading.Tasks.Task<apileague.Client.ApiResponse<FindSimilarBooks200Response>> FindSimilarBooksWithHttpInfoAsync(int id, int? number = default(int?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {

            apileague.Client.RequestOptions localVarRequestOptions = new apileague.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = apileague.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = apileague.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("id", apileague.Client.ClientUtils.ParameterToString(id)); // path parameter
            if (number != null)
            {
                localVarRequestOptions.QueryParameters.Add(apileague.Client.ClientUtils.ParameterToMultiMap("", "number", number));
            }

            localVarRequestOptions.Operation = "BooksApi.FindSimilarBooks";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (apiKey) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("api-key")))
            {
                localVarRequestOptions.QueryParameters.Add(apileague.Client.ClientUtils.ParameterToMultiMap("", "api-key", this.Configuration.GetApiKeyWithPrefix("api-key")));
            }
            // authentication (headerApiKey) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<FindSimilarBooks200Response>("/list-similar-books", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("FindSimilarBooks", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Search Books Search and filter books based on matching a query, the ISBN, rating, and more fields. The query is semantically parsed using our own large ontology. That means you can search paranormal books and the ontology knows that Aliens, Werewolves, Ghosts, and Shapeshifters fall into that category.
        /// </summary>
        /// <exception cref="apileague.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="query">The search query. (optional)</param>
        /// <param name="earliestPublishYear">The books must have been published after this year. (optional)</param>
        /// <param name="latestPublishYear">The books must have been published before this year. (optional)</param>
        /// <param name="minRating">The minimum rating the book must have gotten in the interval [0,1]. (optional)</param>
        /// <param name="maxRating">The maximum rating the book must have gotten in the interval [0,1]. (optional)</param>
        /// <param name="genres">A comma-separated list of genres. Only books from any of the given genres will be returned. (optional)</param>
        /// <param name="authors">A comma-separated list of author ids or names. Only books from any of the given authors will be returned. You can retrieve author ids from the search authors endpoint. Pass author names is slower and if two authors have the same name you can&#39;t disambiguate. (optional)</param>
        /// <param name="isbn">Only the book matching the ISBN-13 will be returned (optional)</param>
        /// <param name="oclc">Only the book matching the OCLC will be returned (optional)</param>
        /// <param name="sort">The sorting criteria (publish-date or rating). (optional)</param>
        /// <param name="sortDirection">Whether to sort ascending or descending (ASC or DESC). (optional)</param>
        /// <param name="groupResults">Whether to group similar editions of the same book. (optional)</param>
        /// <param name="offset">The number of books to skip in range [0,1000] (optional)</param>
        /// <param name="number">The number of books to return in range [1,100] (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>SearchBooks200Response</returns>
        public SearchBooks200Response SearchBooks(string? query = default(string?), int? earliestPublishYear = default(int?), int? latestPublishYear = default(int?), double? minRating = default(double?), double? maxRating = default(double?), string? genres = default(string?), string? authors = default(string?), string? isbn = default(string?), string? oclc = default(string?), string? sort = default(string?), string? sortDirection = default(string?), bool? groupResults = default(bool?), int? offset = default(int?), int? number = default(int?), int operationIndex = 0)
        {
            apileague.Client.ApiResponse<SearchBooks200Response> localVarResponse = SearchBooksWithHttpInfo(query, earliestPublishYear, latestPublishYear, minRating, maxRating, genres, authors, isbn, oclc, sort, sortDirection, groupResults, offset, number);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Search Books Search and filter books based on matching a query, the ISBN, rating, and more fields. The query is semantically parsed using our own large ontology. That means you can search paranormal books and the ontology knows that Aliens, Werewolves, Ghosts, and Shapeshifters fall into that category.
        /// </summary>
        /// <exception cref="apileague.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="query">The search query. (optional)</param>
        /// <param name="earliestPublishYear">The books must have been published after this year. (optional)</param>
        /// <param name="latestPublishYear">The books must have been published before this year. (optional)</param>
        /// <param name="minRating">The minimum rating the book must have gotten in the interval [0,1]. (optional)</param>
        /// <param name="maxRating">The maximum rating the book must have gotten in the interval [0,1]. (optional)</param>
        /// <param name="genres">A comma-separated list of genres. Only books from any of the given genres will be returned. (optional)</param>
        /// <param name="authors">A comma-separated list of author ids or names. Only books from any of the given authors will be returned. You can retrieve author ids from the search authors endpoint. Pass author names is slower and if two authors have the same name you can&#39;t disambiguate. (optional)</param>
        /// <param name="isbn">Only the book matching the ISBN-13 will be returned (optional)</param>
        /// <param name="oclc">Only the book matching the OCLC will be returned (optional)</param>
        /// <param name="sort">The sorting criteria (publish-date or rating). (optional)</param>
        /// <param name="sortDirection">Whether to sort ascending or descending (ASC or DESC). (optional)</param>
        /// <param name="groupResults">Whether to group similar editions of the same book. (optional)</param>
        /// <param name="offset">The number of books to skip in range [0,1000] (optional)</param>
        /// <param name="number">The number of books to return in range [1,100] (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of SearchBooks200Response</returns>
        public apileague.Client.ApiResponse<SearchBooks200Response> SearchBooksWithHttpInfo(string? query = default(string?), int? earliestPublishYear = default(int?), int? latestPublishYear = default(int?), double? minRating = default(double?), double? maxRating = default(double?), string? genres = default(string?), string? authors = default(string?), string? isbn = default(string?), string? oclc = default(string?), string? sort = default(string?), string? sortDirection = default(string?), bool? groupResults = default(bool?), int? offset = default(int?), int? number = default(int?), int operationIndex = 0)
        {
            apileague.Client.RequestOptions localVarRequestOptions = new apileague.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = apileague.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = apileague.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            if (query != null)
            {
                localVarRequestOptions.QueryParameters.Add(apileague.Client.ClientUtils.ParameterToMultiMap("", "query", query));
            }
            if (earliestPublishYear != null)
            {
                localVarRequestOptions.QueryParameters.Add(apileague.Client.ClientUtils.ParameterToMultiMap("", "earliest-publish-year", earliestPublishYear));
            }
            if (latestPublishYear != null)
            {
                localVarRequestOptions.QueryParameters.Add(apileague.Client.ClientUtils.ParameterToMultiMap("", "latest-publish-year", latestPublishYear));
            }
            if (minRating != null)
            {
                localVarRequestOptions.QueryParameters.Add(apileague.Client.ClientUtils.ParameterToMultiMap("", "min-rating", minRating));
            }
            if (maxRating != null)
            {
                localVarRequestOptions.QueryParameters.Add(apileague.Client.ClientUtils.ParameterToMultiMap("", "max-rating", maxRating));
            }
            if (genres != null)
            {
                localVarRequestOptions.QueryParameters.Add(apileague.Client.ClientUtils.ParameterToMultiMap("", "genres", genres));
            }
            if (authors != null)
            {
                localVarRequestOptions.QueryParameters.Add(apileague.Client.ClientUtils.ParameterToMultiMap("", "authors", authors));
            }
            if (isbn != null)
            {
                localVarRequestOptions.QueryParameters.Add(apileague.Client.ClientUtils.ParameterToMultiMap("", "isbn", isbn));
            }
            if (oclc != null)
            {
                localVarRequestOptions.QueryParameters.Add(apileague.Client.ClientUtils.ParameterToMultiMap("", "oclc", oclc));
            }
            if (sort != null)
            {
                localVarRequestOptions.QueryParameters.Add(apileague.Client.ClientUtils.ParameterToMultiMap("", "sort", sort));
            }
            if (sortDirection != null)
            {
                localVarRequestOptions.QueryParameters.Add(apileague.Client.ClientUtils.ParameterToMultiMap("", "sort-direction", sortDirection));
            }
            if (groupResults != null)
            {
                localVarRequestOptions.QueryParameters.Add(apileague.Client.ClientUtils.ParameterToMultiMap("", "group-results", groupResults));
            }
            if (offset != null)
            {
                localVarRequestOptions.QueryParameters.Add(apileague.Client.ClientUtils.ParameterToMultiMap("", "offset", offset));
            }
            if (number != null)
            {
                localVarRequestOptions.QueryParameters.Add(apileague.Client.ClientUtils.ParameterToMultiMap("", "number", number));
            }

            localVarRequestOptions.Operation = "BooksApi.SearchBooks";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (apiKey) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("api-key")))
            {
                localVarRequestOptions.QueryParameters.Add(apileague.Client.ClientUtils.ParameterToMultiMap("", "api-key", this.Configuration.GetApiKeyWithPrefix("api-key")));
            }
            // authentication (headerApiKey) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<SearchBooks200Response>("/search-books", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("SearchBooks", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Search Books Search and filter books based on matching a query, the ISBN, rating, and more fields. The query is semantically parsed using our own large ontology. That means you can search paranormal books and the ontology knows that Aliens, Werewolves, Ghosts, and Shapeshifters fall into that category.
        /// </summary>
        /// <exception cref="apileague.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="query">The search query. (optional)</param>
        /// <param name="earliestPublishYear">The books must have been published after this year. (optional)</param>
        /// <param name="latestPublishYear">The books must have been published before this year. (optional)</param>
        /// <param name="minRating">The minimum rating the book must have gotten in the interval [0,1]. (optional)</param>
        /// <param name="maxRating">The maximum rating the book must have gotten in the interval [0,1]. (optional)</param>
        /// <param name="genres">A comma-separated list of genres. Only books from any of the given genres will be returned. (optional)</param>
        /// <param name="authors">A comma-separated list of author ids or names. Only books from any of the given authors will be returned. You can retrieve author ids from the search authors endpoint. Pass author names is slower and if two authors have the same name you can&#39;t disambiguate. (optional)</param>
        /// <param name="isbn">Only the book matching the ISBN-13 will be returned (optional)</param>
        /// <param name="oclc">Only the book matching the OCLC will be returned (optional)</param>
        /// <param name="sort">The sorting criteria (publish-date or rating). (optional)</param>
        /// <param name="sortDirection">Whether to sort ascending or descending (ASC or DESC). (optional)</param>
        /// <param name="groupResults">Whether to group similar editions of the same book. (optional)</param>
        /// <param name="offset">The number of books to skip in range [0,1000] (optional)</param>
        /// <param name="number">The number of books to return in range [1,100] (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of SearchBooks200Response</returns>
        public async System.Threading.Tasks.Task<SearchBooks200Response> SearchBooksAsync(string? query = default(string?), int? earliestPublishYear = default(int?), int? latestPublishYear = default(int?), double? minRating = default(double?), double? maxRating = default(double?), string? genres = default(string?), string? authors = default(string?), string? isbn = default(string?), string? oclc = default(string?), string? sort = default(string?), string? sortDirection = default(string?), bool? groupResults = default(bool?), int? offset = default(int?), int? number = default(int?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            apileague.Client.ApiResponse<SearchBooks200Response> localVarResponse = await SearchBooksWithHttpInfoAsync(query, earliestPublishYear, latestPublishYear, minRating, maxRating, genres, authors, isbn, oclc, sort, sortDirection, groupResults, offset, number, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Search Books Search and filter books based on matching a query, the ISBN, rating, and more fields. The query is semantically parsed using our own large ontology. That means you can search paranormal books and the ontology knows that Aliens, Werewolves, Ghosts, and Shapeshifters fall into that category.
        /// </summary>
        /// <exception cref="apileague.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="query">The search query. (optional)</param>
        /// <param name="earliestPublishYear">The books must have been published after this year. (optional)</param>
        /// <param name="latestPublishYear">The books must have been published before this year. (optional)</param>
        /// <param name="minRating">The minimum rating the book must have gotten in the interval [0,1]. (optional)</param>
        /// <param name="maxRating">The maximum rating the book must have gotten in the interval [0,1]. (optional)</param>
        /// <param name="genres">A comma-separated list of genres. Only books from any of the given genres will be returned. (optional)</param>
        /// <param name="authors">A comma-separated list of author ids or names. Only books from any of the given authors will be returned. You can retrieve author ids from the search authors endpoint. Pass author names is slower and if two authors have the same name you can&#39;t disambiguate. (optional)</param>
        /// <param name="isbn">Only the book matching the ISBN-13 will be returned (optional)</param>
        /// <param name="oclc">Only the book matching the OCLC will be returned (optional)</param>
        /// <param name="sort">The sorting criteria (publish-date or rating). (optional)</param>
        /// <param name="sortDirection">Whether to sort ascending or descending (ASC or DESC). (optional)</param>
        /// <param name="groupResults">Whether to group similar editions of the same book. (optional)</param>
        /// <param name="offset">The number of books to skip in range [0,1000] (optional)</param>
        /// <param name="number">The number of books to return in range [1,100] (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (SearchBooks200Response)</returns>
        public async System.Threading.Tasks.Task<apileague.Client.ApiResponse<SearchBooks200Response>> SearchBooksWithHttpInfoAsync(string? query = default(string?), int? earliestPublishYear = default(int?), int? latestPublishYear = default(int?), double? minRating = default(double?), double? maxRating = default(double?), string? genres = default(string?), string? authors = default(string?), string? isbn = default(string?), string? oclc = default(string?), string? sort = default(string?), string? sortDirection = default(string?), bool? groupResults = default(bool?), int? offset = default(int?), int? number = default(int?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {

            apileague.Client.RequestOptions localVarRequestOptions = new apileague.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = apileague.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = apileague.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            if (query != null)
            {
                localVarRequestOptions.QueryParameters.Add(apileague.Client.ClientUtils.ParameterToMultiMap("", "query", query));
            }
            if (earliestPublishYear != null)
            {
                localVarRequestOptions.QueryParameters.Add(apileague.Client.ClientUtils.ParameterToMultiMap("", "earliest-publish-year", earliestPublishYear));
            }
            if (latestPublishYear != null)
            {
                localVarRequestOptions.QueryParameters.Add(apileague.Client.ClientUtils.ParameterToMultiMap("", "latest-publish-year", latestPublishYear));
            }
            if (minRating != null)
            {
                localVarRequestOptions.QueryParameters.Add(apileague.Client.ClientUtils.ParameterToMultiMap("", "min-rating", minRating));
            }
            if (maxRating != null)
            {
                localVarRequestOptions.QueryParameters.Add(apileague.Client.ClientUtils.ParameterToMultiMap("", "max-rating", maxRating));
            }
            if (genres != null)
            {
                localVarRequestOptions.QueryParameters.Add(apileague.Client.ClientUtils.ParameterToMultiMap("", "genres", genres));
            }
            if (authors != null)
            {
                localVarRequestOptions.QueryParameters.Add(apileague.Client.ClientUtils.ParameterToMultiMap("", "authors", authors));
            }
            if (isbn != null)
            {
                localVarRequestOptions.QueryParameters.Add(apileague.Client.ClientUtils.ParameterToMultiMap("", "isbn", isbn));
            }
            if (oclc != null)
            {
                localVarRequestOptions.QueryParameters.Add(apileague.Client.ClientUtils.ParameterToMultiMap("", "oclc", oclc));
            }
            if (sort != null)
            {
                localVarRequestOptions.QueryParameters.Add(apileague.Client.ClientUtils.ParameterToMultiMap("", "sort", sort));
            }
            if (sortDirection != null)
            {
                localVarRequestOptions.QueryParameters.Add(apileague.Client.ClientUtils.ParameterToMultiMap("", "sort-direction", sortDirection));
            }
            if (groupResults != null)
            {
                localVarRequestOptions.QueryParameters.Add(apileague.Client.ClientUtils.ParameterToMultiMap("", "group-results", groupResults));
            }
            if (offset != null)
            {
                localVarRequestOptions.QueryParameters.Add(apileague.Client.ClientUtils.ParameterToMultiMap("", "offset", offset));
            }
            if (number != null)
            {
                localVarRequestOptions.QueryParameters.Add(apileague.Client.ClientUtils.ParameterToMultiMap("", "number", number));
            }

            localVarRequestOptions.Operation = "BooksApi.SearchBooks";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (apiKey) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("api-key")))
            {
                localVarRequestOptions.QueryParameters.Add(apileague.Client.ClientUtils.ParameterToMultiMap("", "api-key", this.Configuration.GetApiKeyWithPrefix("api-key")));
            }
            // authentication (headerApiKey) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<SearchBooks200Response>("/search-books", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("SearchBooks", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

    }
}
