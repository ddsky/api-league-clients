/*
API League

API League is a Hub for World Class APIs.

API version: 1.4.0
Contact: mail@apileague.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package apileague

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


// FoodAPIService FoodAPI service
type FoodAPIService service

type ApiComputeNutritionRequest struct {
	ctx context.Context
	ApiService *FoodAPIService
	ingredients *string
	servings *int32
	reduceOils *bool
}

// A comma-separated list of the ingredients of the recipe.
func (r ApiComputeNutritionRequest) Ingredients(ingredients string) ApiComputeNutritionRequest {
	r.ingredients = &ingredients
	return r
}

// The number of servings the ingredients make. Nutrition is computed per serving.
func (r ApiComputeNutritionRequest) Servings(servings int32) ApiComputeNutritionRequest {
	r.servings = &servings
	return r
}

// If there is oil in the ingredients, e.g. 3 tablespoons olive oil but they are used for frying, not all of the oil is consumed and therefore should not be added to the computed nutrition. In this case set reduce-oils to true.
func (r ApiComputeNutritionRequest) ReduceOils(reduceOils bool) ApiComputeNutritionRequest {
	r.reduceOils = &reduceOils
	return r
}

func (r ApiComputeNutritionRequest) Execute() (*ComputeNutrition200Response, *http.Response, error) {
	return r.ApiService.ComputeNutritionExecute(r)
}

/*
ComputeNutrition Compute Nutrition

Compute detailed nutritional information for a given recipe (list of ingredients). The API will return the nutritional information for each ingredient, as well as the total nutritional content for the entire recipe. Aside from macro and micro nutrients, the API also returns flavanoid information and food properties such as glycemic index, glycemic load, and inflammation score.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiComputeNutritionRequest
*/
func (a *FoodAPIService) ComputeNutrition(ctx context.Context) ApiComputeNutritionRequest {
	return ApiComputeNutritionRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ComputeNutrition200Response
func (a *FoodAPIService) ComputeNutritionExecute(r ApiComputeNutritionRequest) (*ComputeNutrition200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComputeNutrition200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FoodAPIService.ComputeNutrition")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/compute-nutrition"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.ingredients == nil {
		return localVarReturnValue, nil, reportError("ingredients is required and must be specified")
	}
	if strlen(*r.ingredients) > 1000 {
		return localVarReturnValue, nil, reportError("ingredients must have less than 1000 elements")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "ingredients", r.ingredients, "")
	if r.servings != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "servings", r.servings, "")
	}
	if r.reduceOils != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reduce-oils", r.reduceOils, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api-key", key)
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["headerApiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRetrieveRecipeInformationRequest struct {
	ctx context.Context
	ApiService *FoodAPIService
	id *int32
	addWinePairing *bool
}

// The id of the recipe to retrieve.
func (r ApiRetrieveRecipeInformationRequest) Id(id int32) ApiRetrieveRecipeInformationRequest {
	r.id = &id
	return r
}

// Whether to pair a wine to the recipe.
func (r ApiRetrieveRecipeInformationRequest) AddWinePairing(addWinePairing bool) ApiRetrieveRecipeInformationRequest {
	r.addWinePairing = &addWinePairing
	return r
}

func (r ApiRetrieveRecipeInformationRequest) Execute() (*RetrieveRecipeInformation200Response, *http.Response, error) {
	return r.ApiService.RetrieveRecipeInformationExecute(r)
}

/*
RetrieveRecipeInformation Retrieve Recipe Information

Get detailed recipe information such as dietary properties, macro and micro nutrients, used ingredients and their amounts, and more.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRetrieveRecipeInformationRequest
*/
func (a *FoodAPIService) RetrieveRecipeInformation(ctx context.Context) ApiRetrieveRecipeInformationRequest {
	return ApiRetrieveRecipeInformationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RetrieveRecipeInformation200Response
func (a *FoodAPIService) RetrieveRecipeInformationExecute(r ApiRetrieveRecipeInformationRequest) (*RetrieveRecipeInformation200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RetrieveRecipeInformation200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FoodAPIService.RetrieveRecipeInformation")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/retrieve-recipe"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.id == nil {
		return localVarReturnValue, nil, reportError("id is required and must be specified")
	}
	if *r.id < 0 {
		return localVarReturnValue, nil, reportError("id must be greater than 0")
	}
	if *r.id > 1410065407 {
		return localVarReturnValue, nil, reportError("id must be less than 1410065407")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	if r.addWinePairing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "add-wine-pairing", r.addWinePairing, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api-key", key)
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["headerApiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchRecipesRequest struct {
	ctx context.Context
	ApiService *FoodAPIService
	query *string
	cuisines *string
	excludeCuisines *string
	mealType *string
	diet *string
	intolerances *string
	equipment *string
	includeIngredients *string
	excludeIngredients *string
	fillIngredients *bool
	addRecipeInformation *bool
	maxTime *int32
	minServings *int32
	maxServings *int32
	minCalories *float64
	maxCalories *float64
	minCarbs *float64
	maxCarbs *float64
	minProtein *float64
	maxProtein *float64
	minFat *float64
	maxFat *float64
	minSugar *float64
	maxSugar *float64
	minFiber *float64
	maxFiber *float64
	minFolate *float64
	maxFolate *float64
	minFolicAcid *float64
	maxFolicAcid *float64
	minIodine *float64
	maxIodine *float64
	minIron *float64
	maxIron *float64
	minZinc *float64
	maxZinc *float64
	minMagnesium *float64
	maxMagnesium *float64
	minManganese *float64
	maxManganese *float64
	minPhosphorus *float64
	maxPhosphorus *float64
	minPotassium *float64
	maxPotassium *float64
	minSodium *float64
	maxSodium *float64
	minSelenium *float64
	maxSelenium *float64
	minCopper *float64
	maxCopper *float64
	minCalcium *float64
	maxCalcium *float64
	minCholine *float64
	maxCholine *float64
	minCholesterol *float64
	maxCholesterol *float64
	minFluoride *float64
	maxFluoride *float64
	minAlcohol *float64
	maxAlcohol *float64
	minCaffeine *float64
	maxCaffeine *float64
	minSaturatedFat *float64
	maxSaturatedFat *float64
	minVitaminA *float64
	maxVitaminA *float64
	minVitaminC *float64
	maxVitaminC *float64
	minVitaminD *float64
	maxVitaminD *float64
	minVitaminE *float64
	maxVitaminE *float64
	minVitaminK *float64
	maxVitaminK *float64
	minVitaminB1 *float64
	maxVitaminB1 *float64
	minVitaminB2 *float64
	maxVitaminB2 *float64
	minVitaminB3 *float64
	maxVitaminB3 *float64
	minVitaminB5 *float64
	maxVitaminB5 *float64
	minVitaminB6 *float64
	maxVitaminB6 *float64
	minVitaminB12 *float64
	maxVitaminB12 *float64
	sort *string
	sortDirection *string
	offset *int32
	number *int32
}

// The search query.
func (r ApiSearchRecipesRequest) Query(query string) ApiSearchRecipesRequest {
	r.query = &query
	return r
}

// The cuisine(s) of the recipes. One or more, comma separated (will be interpreted as &#39;OR&#39;).
func (r ApiSearchRecipesRequest) Cuisines(cuisines string) ApiSearchRecipesRequest {
	r.cuisines = &cuisines
	return r
}

// The cuisine(s) the recipes must not match. One or more, comma separated (will be interpreted as &#39;AND&#39;).
func (r ApiSearchRecipesRequest) ExcludeCuisines(excludeCuisines string) ApiSearchRecipesRequest {
	r.excludeCuisines = &excludeCuisines
	return r
}

// The type of the recipe, one of: main course,side dish,dessert,appetizer,salad,bread,breakfast,soup,beverage,sauce,drink.
func (r ApiSearchRecipesRequest) MealType(mealType string) ApiSearchRecipesRequest {
	r.mealType = &mealType
	return r
}

// The diet the recipes must adhere to. One of the following: paleo,primal,grain-free,pescetarian,lacto vegetarian,ovo vegetarian,vegan,vegetarian.
func (r ApiSearchRecipesRequest) Diet(diet string) ApiSearchRecipesRequest {
	r.diet = &diet
	return r
}

// A comma-separated list of intolerances. All recipes returned must not contain ingredients that are not suitable for people with the intolerances entered.
func (r ApiSearchRecipesRequest) Intolerances(intolerances string) ApiSearchRecipesRequest {
	r.intolerances = &intolerances
	return r
}

// The equipment required. Multiple values will be interpreted as &#39;OR&#39;.
func (r ApiSearchRecipesRequest) Equipment(equipment string) ApiSearchRecipesRequest {
	r.equipment = &equipment
	return r
}

// A comma-separated list of ingredients that should/must be used in the recipes.
func (r ApiSearchRecipesRequest) IncludeIngredients(includeIngredients string) ApiSearchRecipesRequest {
	r.includeIngredients = &includeIngredients
	return r
}

// A comma-separated list of ingredients or ingredient types that the recipes must not contain.
func (r ApiSearchRecipesRequest) ExcludeIngredients(excludeIngredients string) ApiSearchRecipesRequest {
	r.excludeIngredients = &excludeIngredients
	return r
}

// Add information about the ingredients and whether they are used or missing in relation to the query.
func (r ApiSearchRecipesRequest) FillIngredients(fillIngredients bool) ApiSearchRecipesRequest {
	r.fillIngredients = &fillIngredients
	return r
}

// If set to true, you get more information about the recipes returned.
func (r ApiSearchRecipesRequest) AddRecipeInformation(addRecipeInformation bool) ApiSearchRecipesRequest {
	r.addRecipeInformation = &addRecipeInformation
	return r
}

// The maximum time in minutes it should take to prepare and cook the recipe.
func (r ApiSearchRecipesRequest) MaxTime(maxTime int32) ApiSearchRecipesRequest {
	r.maxTime = &maxTime
	return r
}

// The minimum amount of servings the recipe is for.
func (r ApiSearchRecipesRequest) MinServings(minServings int32) ApiSearchRecipesRequest {
	r.minServings = &minServings
	return r
}

// The maximum amount of servings the recipe is for.
func (r ApiSearchRecipesRequest) MaxServings(maxServings int32) ApiSearchRecipesRequest {
	r.maxServings = &maxServings
	return r
}

// The minimum amount of calories the recipe must have per serving.
func (r ApiSearchRecipesRequest) MinCalories(minCalories float64) ApiSearchRecipesRequest {
	r.minCalories = &minCalories
	return r
}

// The maximum amount of calories the recipe can have per serving.
func (r ApiSearchRecipesRequest) MaxCalories(maxCalories float64) ApiSearchRecipesRequest {
	r.maxCalories = &maxCalories
	return r
}

// The minimum amount of carbohydrates in grams the recipe must have per serving.
func (r ApiSearchRecipesRequest) MinCarbs(minCarbs float64) ApiSearchRecipesRequest {
	r.minCarbs = &minCarbs
	return r
}

// The maximum amount of carbohydrates in grams the recipe can have per serving.
func (r ApiSearchRecipesRequest) MaxCarbs(maxCarbs float64) ApiSearchRecipesRequest {
	r.maxCarbs = &maxCarbs
	return r
}

// The minimum amount of protein in grams the recipe must have per serving.
func (r ApiSearchRecipesRequest) MinProtein(minProtein float64) ApiSearchRecipesRequest {
	r.minProtein = &minProtein
	return r
}

// The maximum amount of protein in grams the recipe can have per serving.
func (r ApiSearchRecipesRequest) MaxProtein(maxProtein float64) ApiSearchRecipesRequest {
	r.maxProtein = &maxProtein
	return r
}

// The minimum amount of fat in grams the recipe must have per serving.
func (r ApiSearchRecipesRequest) MinFat(minFat float64) ApiSearchRecipesRequest {
	r.minFat = &minFat
	return r
}

// The maximum amount of fat in grams the recipe can have per serving.
func (r ApiSearchRecipesRequest) MaxFat(maxFat float64) ApiSearchRecipesRequest {
	r.maxFat = &maxFat
	return r
}

// The minimum amount of sugar in grams the recipe must have per serving.
func (r ApiSearchRecipesRequest) MinSugar(minSugar float64) ApiSearchRecipesRequest {
	r.minSugar = &minSugar
	return r
}

// The maximum amount of sugar in grams the recipe can have per serving.
func (r ApiSearchRecipesRequest) MaxSugar(maxSugar float64) ApiSearchRecipesRequest {
	r.maxSugar = &maxSugar
	return r
}

// The minimum amount of fiber in grams the recipe must have per serving.
func (r ApiSearchRecipesRequest) MinFiber(minFiber float64) ApiSearchRecipesRequest {
	r.minFiber = &minFiber
	return r
}

// The maximum amount of fiber in grams the recipe can have per serving.
func (r ApiSearchRecipesRequest) MaxFiber(maxFiber float64) ApiSearchRecipesRequest {
	r.maxFiber = &maxFiber
	return r
}

// The minimum amount of folate in micrograms the recipe must have per serving.
func (r ApiSearchRecipesRequest) MinFolate(minFolate float64) ApiSearchRecipesRequest {
	r.minFolate = &minFolate
	return r
}

// The maximum amount of folate in micrograms the recipe can have per serving.
func (r ApiSearchRecipesRequest) MaxFolate(maxFolate float64) ApiSearchRecipesRequest {
	r.maxFolate = &maxFolate
	return r
}

// The minimum amount of folic acid in micrograms the recipe must have per serving.
func (r ApiSearchRecipesRequest) MinFolicAcid(minFolicAcid float64) ApiSearchRecipesRequest {
	r.minFolicAcid = &minFolicAcid
	return r
}

// The maximum amount of folic acid in micrograms the recipe can have per serving.
func (r ApiSearchRecipesRequest) MaxFolicAcid(maxFolicAcid float64) ApiSearchRecipesRequest {
	r.maxFolicAcid = &maxFolicAcid
	return r
}

// The minimum amount of iodine in micrograms the recipe must have per serving.
func (r ApiSearchRecipesRequest) MinIodine(minIodine float64) ApiSearchRecipesRequest {
	r.minIodine = &minIodine
	return r
}

// The maximum amount of iodine in micrograms the recipe can have per serving.
func (r ApiSearchRecipesRequest) MaxIodine(maxIodine float64) ApiSearchRecipesRequest {
	r.maxIodine = &maxIodine
	return r
}

// The minimum amount of iron in milligrams the recipe must have per serving.
func (r ApiSearchRecipesRequest) MinIron(minIron float64) ApiSearchRecipesRequest {
	r.minIron = &minIron
	return r
}

// The maximum amount of iron in milligrams the recipe can have per serving.
func (r ApiSearchRecipesRequest) MaxIron(maxIron float64) ApiSearchRecipesRequest {
	r.maxIron = &maxIron
	return r
}

// The minimum amount of zinc in milligrams the recipe must have per serving.
func (r ApiSearchRecipesRequest) MinZinc(minZinc float64) ApiSearchRecipesRequest {
	r.minZinc = &minZinc
	return r
}

// The maximum amount of zinc in milligrams the recipe can have per serving.
func (r ApiSearchRecipesRequest) MaxZinc(maxZinc float64) ApiSearchRecipesRequest {
	r.maxZinc = &maxZinc
	return r
}

// The minimum amount of magnesium in milligrams the recipe must have per serving.
func (r ApiSearchRecipesRequest) MinMagnesium(minMagnesium float64) ApiSearchRecipesRequest {
	r.minMagnesium = &minMagnesium
	return r
}

// The maximum amount of magnesium in milligrams the recipe can have per serving.
func (r ApiSearchRecipesRequest) MaxMagnesium(maxMagnesium float64) ApiSearchRecipesRequest {
	r.maxMagnesium = &maxMagnesium
	return r
}

// The minimum amount of manganese in milligrams the recipe must have per serving.
func (r ApiSearchRecipesRequest) MinManganese(minManganese float64) ApiSearchRecipesRequest {
	r.minManganese = &minManganese
	return r
}

// The maximum amount of manganese in milligrams the recipe can have per serving.
func (r ApiSearchRecipesRequest) MaxManganese(maxManganese float64) ApiSearchRecipesRequest {
	r.maxManganese = &maxManganese
	return r
}

// The minimum amount of phosphorus in milligrams the recipe must have per serving.
func (r ApiSearchRecipesRequest) MinPhosphorus(minPhosphorus float64) ApiSearchRecipesRequest {
	r.minPhosphorus = &minPhosphorus
	return r
}

// The maximum amount of phosphorus in milligrams the recipe can have per serving.
func (r ApiSearchRecipesRequest) MaxPhosphorus(maxPhosphorus float64) ApiSearchRecipesRequest {
	r.maxPhosphorus = &maxPhosphorus
	return r
}

// The minimum amount of potassium in milligrams the recipe must have per serving.
func (r ApiSearchRecipesRequest) MinPotassium(minPotassium float64) ApiSearchRecipesRequest {
	r.minPotassium = &minPotassium
	return r
}

// The maximum amount of potassium in milligrams the recipe can have per serving.
func (r ApiSearchRecipesRequest) MaxPotassium(maxPotassium float64) ApiSearchRecipesRequest {
	r.maxPotassium = &maxPotassium
	return r
}

// The minimum amount of sodium in milligrams the recipe must have per serving.
func (r ApiSearchRecipesRequest) MinSodium(minSodium float64) ApiSearchRecipesRequest {
	r.minSodium = &minSodium
	return r
}

// The maximum amount of sodium in milligrams the recipe can have per serving.
func (r ApiSearchRecipesRequest) MaxSodium(maxSodium float64) ApiSearchRecipesRequest {
	r.maxSodium = &maxSodium
	return r
}

// The minimum amount of selenium in micrograms the recipe must have per serving.
func (r ApiSearchRecipesRequest) MinSelenium(minSelenium float64) ApiSearchRecipesRequest {
	r.minSelenium = &minSelenium
	return r
}

// The maximum amount of selenium in micrograms the recipe can have per serving.
func (r ApiSearchRecipesRequest) MaxSelenium(maxSelenium float64) ApiSearchRecipesRequest {
	r.maxSelenium = &maxSelenium
	return r
}

// The minimum amount of copper in milligrams the recipe must have per serving.
func (r ApiSearchRecipesRequest) MinCopper(minCopper float64) ApiSearchRecipesRequest {
	r.minCopper = &minCopper
	return r
}

// The maximum amount of copper in milligrams the recipe can have per serving.
func (r ApiSearchRecipesRequest) MaxCopper(maxCopper float64) ApiSearchRecipesRequest {
	r.maxCopper = &maxCopper
	return r
}

// The minimum amount of calcium in milligrams the recipe must have per serving.
func (r ApiSearchRecipesRequest) MinCalcium(minCalcium float64) ApiSearchRecipesRequest {
	r.minCalcium = &minCalcium
	return r
}

// The maximum amount of calcium in milligrams the recipe can have per serving.
func (r ApiSearchRecipesRequest) MaxCalcium(maxCalcium float64) ApiSearchRecipesRequest {
	r.maxCalcium = &maxCalcium
	return r
}

// The minimum amount of choline in milligrams the recipe must have per serving.
func (r ApiSearchRecipesRequest) MinCholine(minCholine float64) ApiSearchRecipesRequest {
	r.minCholine = &minCholine
	return r
}

// The maximum amount of choline in milligrams the recipe can have per serving.
func (r ApiSearchRecipesRequest) MaxCholine(maxCholine float64) ApiSearchRecipesRequest {
	r.maxCholine = &maxCholine
	return r
}

// The minimum amount of cholesterol in milligrams the recipe must have per serving.
func (r ApiSearchRecipesRequest) MinCholesterol(minCholesterol float64) ApiSearchRecipesRequest {
	r.minCholesterol = &minCholesterol
	return r
}

// The maximum amount of cholesterol in milligrams the recipe can have per serving.
func (r ApiSearchRecipesRequest) MaxCholesterol(maxCholesterol float64) ApiSearchRecipesRequest {
	r.maxCholesterol = &maxCholesterol
	return r
}

// The minimum amount of fluoride in milligrams the recipe must have per serving.
func (r ApiSearchRecipesRequest) MinFluoride(minFluoride float64) ApiSearchRecipesRequest {
	r.minFluoride = &minFluoride
	return r
}

// The maximum amount of fluoride in milligrams the recipe can have per serving.
func (r ApiSearchRecipesRequest) MaxFluoride(maxFluoride float64) ApiSearchRecipesRequest {
	r.maxFluoride = &maxFluoride
	return r
}

// The minimum amount of alcohol in grams the recipe must have per serving.
func (r ApiSearchRecipesRequest) MinAlcohol(minAlcohol float64) ApiSearchRecipesRequest {
	r.minAlcohol = &minAlcohol
	return r
}

// The maximum amount of alcohol in grams the recipe can have per serving.
func (r ApiSearchRecipesRequest) MaxAlcohol(maxAlcohol float64) ApiSearchRecipesRequest {
	r.maxAlcohol = &maxAlcohol
	return r
}

// The minimum amount of caffeine in milligrams the recipe must have per serving.
func (r ApiSearchRecipesRequest) MinCaffeine(minCaffeine float64) ApiSearchRecipesRequest {
	r.minCaffeine = &minCaffeine
	return r
}

// The maximum amount of caffeine in milligrams the recipe can have per serving.
func (r ApiSearchRecipesRequest) MaxCaffeine(maxCaffeine float64) ApiSearchRecipesRequest {
	r.maxCaffeine = &maxCaffeine
	return r
}

// The minimum amount of saturated fat in grams the recipe must have per serving.
func (r ApiSearchRecipesRequest) MinSaturatedFat(minSaturatedFat float64) ApiSearchRecipesRequest {
	r.minSaturatedFat = &minSaturatedFat
	return r
}

// The maximum amount of saturated fat in grams the recipe can have per serving.
func (r ApiSearchRecipesRequest) MaxSaturatedFat(maxSaturatedFat float64) ApiSearchRecipesRequest {
	r.maxSaturatedFat = &maxSaturatedFat
	return r
}

// The minimum amount of Vitamin A in IU the recipe must have per serving.
func (r ApiSearchRecipesRequest) MinVitaminA(minVitaminA float64) ApiSearchRecipesRequest {
	r.minVitaminA = &minVitaminA
	return r
}

// The maximum amount of Vitamin A in IU the recipe can have per serving.
func (r ApiSearchRecipesRequest) MaxVitaminA(maxVitaminA float64) ApiSearchRecipesRequest {
	r.maxVitaminA = &maxVitaminA
	return r
}

// The minimum amount of Vitamin C in milligrams the recipe must have per serving.
func (r ApiSearchRecipesRequest) MinVitaminC(minVitaminC float64) ApiSearchRecipesRequest {
	r.minVitaminC = &minVitaminC
	return r
}

// The maximum amount of Vitamin C in milligrams the recipe can have per serving.
func (r ApiSearchRecipesRequest) MaxVitaminC(maxVitaminC float64) ApiSearchRecipesRequest {
	r.maxVitaminC = &maxVitaminC
	return r
}

// The minimum amount of Vitamin D in micrograms the recipe must have per serving.
func (r ApiSearchRecipesRequest) MinVitaminD(minVitaminD float64) ApiSearchRecipesRequest {
	r.minVitaminD = &minVitaminD
	return r
}

// The maximum amount of Vitamin D in micrograms the recipe can have per serving.
func (r ApiSearchRecipesRequest) MaxVitaminD(maxVitaminD float64) ApiSearchRecipesRequest {
	r.maxVitaminD = &maxVitaminD
	return r
}

// The minimum amount of Vitamin E in milligrams the recipe must have per serving.
func (r ApiSearchRecipesRequest) MinVitaminE(minVitaminE float64) ApiSearchRecipesRequest {
	r.minVitaminE = &minVitaminE
	return r
}

// The maximum amount of Vitamin E in milligrams the recipe can have per serving.
func (r ApiSearchRecipesRequest) MaxVitaminE(maxVitaminE float64) ApiSearchRecipesRequest {
	r.maxVitaminE = &maxVitaminE
	return r
}

// The minimum amount of Vitamin K in micrograms the recipe must have per serving.
func (r ApiSearchRecipesRequest) MinVitaminK(minVitaminK float64) ApiSearchRecipesRequest {
	r.minVitaminK = &minVitaminK
	return r
}

// The maximum amount of Vitamin K in micrograms the recipe can have per serving.
func (r ApiSearchRecipesRequest) MaxVitaminK(maxVitaminK float64) ApiSearchRecipesRequest {
	r.maxVitaminK = &maxVitaminK
	return r
}

// The minimum amount of Vitamin B1 in milligrams the recipe must have per serving.
func (r ApiSearchRecipesRequest) MinVitaminB1(minVitaminB1 float64) ApiSearchRecipesRequest {
	r.minVitaminB1 = &minVitaminB1
	return r
}

// The maximum amount of Vitamin B1 in milligrams the recipe can have per serving.
func (r ApiSearchRecipesRequest) MaxVitaminB1(maxVitaminB1 float64) ApiSearchRecipesRequest {
	r.maxVitaminB1 = &maxVitaminB1
	return r
}

// The minimum amount of Vitamin B2 in milligrams the recipe must have per serving.
func (r ApiSearchRecipesRequest) MinVitaminB2(minVitaminB2 float64) ApiSearchRecipesRequest {
	r.minVitaminB2 = &minVitaminB2
	return r
}

// The maximum amount of Vitamin B2 in milligrams the recipe can have per serving.
func (r ApiSearchRecipesRequest) MaxVitaminB2(maxVitaminB2 float64) ApiSearchRecipesRequest {
	r.maxVitaminB2 = &maxVitaminB2
	return r
}

// The minimum amount of Vitamin B3 in milligrams the recipe must have per serving.
func (r ApiSearchRecipesRequest) MinVitaminB3(minVitaminB3 float64) ApiSearchRecipesRequest {
	r.minVitaminB3 = &minVitaminB3
	return r
}

// The maximum amount of Vitamin B3 in milligrams the recipe can have per serving.
func (r ApiSearchRecipesRequest) MaxVitaminB3(maxVitaminB3 float64) ApiSearchRecipesRequest {
	r.maxVitaminB3 = &maxVitaminB3
	return r
}

// The minimum amount of Vitamin B5 in milligrams the recipe must have per serving.
func (r ApiSearchRecipesRequest) MinVitaminB5(minVitaminB5 float64) ApiSearchRecipesRequest {
	r.minVitaminB5 = &minVitaminB5
	return r
}

// The maximum amount of Vitamin B5 in milligrams the recipe can have per serving.
func (r ApiSearchRecipesRequest) MaxVitaminB5(maxVitaminB5 float64) ApiSearchRecipesRequest {
	r.maxVitaminB5 = &maxVitaminB5
	return r
}

// The minimum amount of Vitamin B6 in milligrams the recipe must have per serving.
func (r ApiSearchRecipesRequest) MinVitaminB6(minVitaminB6 float64) ApiSearchRecipesRequest {
	r.minVitaminB6 = &minVitaminB6
	return r
}

// The maximum amount of Vitamin B6 in milligrams the recipe can have per serving.
func (r ApiSearchRecipesRequest) MaxVitaminB6(maxVitaminB6 float64) ApiSearchRecipesRequest {
	r.maxVitaminB6 = &maxVitaminB6
	return r
}

// The minimum amount of Vitamin B12 in milligrams the recipe must have per serving.
func (r ApiSearchRecipesRequest) MinVitaminB12(minVitaminB12 float64) ApiSearchRecipesRequest {
	r.minVitaminB12 = &minVitaminB12
	return r
}

// The maximum amount of Vitamin B12 in milligrams the recipe can have per serving.
func (r ApiSearchRecipesRequest) MaxVitaminB12(maxVitaminB12 float64) ApiSearchRecipesRequest {
	r.maxVitaminB12 = &maxVitaminB12
	return r
}

// The strategy to sort recipes by. See a full list of supported sorting options.
func (r ApiSearchRecipesRequest) Sort(sort string) ApiSearchRecipesRequest {
	r.sort = &sort
	return r
}

// Whether to sort ascending or descending (ASC or DESC).
func (r ApiSearchRecipesRequest) SortDirection(sortDirection string) ApiSearchRecipesRequest {
	r.sortDirection = &sortDirection
	return r
}

// The number of recipes to skip, between 0 and 900.
func (r ApiSearchRecipesRequest) Offset(offset int32) ApiSearchRecipesRequest {
	r.offset = &offset
	return r
}

// The number of recipes, between 1 and 100.
func (r ApiSearchRecipesRequest) Number(number int32) ApiSearchRecipesRequest {
	r.number = &number
	return r
}

func (r ApiSearchRecipesRequest) Execute() (*SearchRecipes200Response, *http.Response, error) {
	return r.ApiService.SearchRecipesExecute(r)
}

/*
SearchRecipes Search Recipes

Search and filter thousands of recipes with natural language, e.g. pasta recipes without mushrooms but with truffles. You can filter by ingredients, diet, cuisine, meal type, macro and micro nutrition, intolerances, and much more.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSearchRecipesRequest
*/
func (a *FoodAPIService) SearchRecipes(ctx context.Context) ApiSearchRecipesRequest {
	return ApiSearchRecipesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SearchRecipes200Response
func (a *FoodAPIService) SearchRecipesExecute(r ApiSearchRecipesRequest) (*SearchRecipes200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SearchRecipes200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FoodAPIService.SearchRecipes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/search-recipes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.query != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "query", r.query, "")
	}
	if r.cuisines != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cuisines", r.cuisines, "")
	}
	if r.excludeCuisines != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude-cuisines", r.excludeCuisines, "")
	}
	if r.mealType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "meal-type", r.mealType, "")
	}
	if r.diet != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "diet", r.diet, "")
	}
	if r.intolerances != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "intolerances", r.intolerances, "")
	}
	if r.equipment != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "equipment", r.equipment, "")
	}
	if r.includeIngredients != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include-ingredients", r.includeIngredients, "")
	}
	if r.excludeIngredients != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude-ingredients", r.excludeIngredients, "")
	}
	if r.fillIngredients != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fill-ingredients", r.fillIngredients, "")
	}
	if r.addRecipeInformation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "add-recipe-information", r.addRecipeInformation, "")
	}
	if r.maxTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max-time", r.maxTime, "")
	}
	if r.minServings != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min-servings", r.minServings, "")
	}
	if r.maxServings != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max-servings", r.maxServings, "")
	}
	if r.minCalories != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min-calories", r.minCalories, "")
	}
	if r.maxCalories != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max-calories", r.maxCalories, "")
	}
	if r.minCarbs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min-carbs", r.minCarbs, "")
	}
	if r.maxCarbs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max-carbs", r.maxCarbs, "")
	}
	if r.minProtein != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min-protein", r.minProtein, "")
	}
	if r.maxProtein != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max-protein", r.maxProtein, "")
	}
	if r.minFat != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min-fat", r.minFat, "")
	}
	if r.maxFat != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max-fat", r.maxFat, "")
	}
	if r.minSugar != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min-sugar", r.minSugar, "")
	}
	if r.maxSugar != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max-sugar", r.maxSugar, "")
	}
	if r.minFiber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min-fiber", r.minFiber, "")
	}
	if r.maxFiber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max-fiber", r.maxFiber, "")
	}
	if r.minFolate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min-folate", r.minFolate, "")
	}
	if r.maxFolate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max-folate", r.maxFolate, "")
	}
	if r.minFolicAcid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min-folic-acid", r.minFolicAcid, "")
	}
	if r.maxFolicAcid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max-folic-acid", r.maxFolicAcid, "")
	}
	if r.minIodine != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min-iodine", r.minIodine, "")
	}
	if r.maxIodine != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max-iodine", r.maxIodine, "")
	}
	if r.minIron != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min-iron", r.minIron, "")
	}
	if r.maxIron != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max-iron", r.maxIron, "")
	}
	if r.minZinc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min-zinc", r.minZinc, "")
	}
	if r.maxZinc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max-zinc", r.maxZinc, "")
	}
	if r.minMagnesium != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min-magnesium", r.minMagnesium, "")
	}
	if r.maxMagnesium != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max-magnesium", r.maxMagnesium, "")
	}
	if r.minManganese != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min-manganese", r.minManganese, "")
	}
	if r.maxManganese != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max-manganese", r.maxManganese, "")
	}
	if r.minPhosphorus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min-phosphorus", r.minPhosphorus, "")
	}
	if r.maxPhosphorus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max-phosphorus", r.maxPhosphorus, "")
	}
	if r.minPotassium != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min-potassium", r.minPotassium, "")
	}
	if r.maxPotassium != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max-potassium", r.maxPotassium, "")
	}
	if r.minSodium != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min-sodium", r.minSodium, "")
	}
	if r.maxSodium != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max-sodium", r.maxSodium, "")
	}
	if r.minSelenium != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min-selenium", r.minSelenium, "")
	}
	if r.maxSelenium != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max-selenium", r.maxSelenium, "")
	}
	if r.minCopper != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min-copper", r.minCopper, "")
	}
	if r.maxCopper != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max-copper", r.maxCopper, "")
	}
	if r.minCalcium != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min-calcium", r.minCalcium, "")
	}
	if r.maxCalcium != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max-calcium", r.maxCalcium, "")
	}
	if r.minCholine != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min-choline", r.minCholine, "")
	}
	if r.maxCholine != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max-choline", r.maxCholine, "")
	}
	if r.minCholesterol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min-cholesterol", r.minCholesterol, "")
	}
	if r.maxCholesterol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max-cholesterol", r.maxCholesterol, "")
	}
	if r.minFluoride != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min-fluoride", r.minFluoride, "")
	}
	if r.maxFluoride != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max-fluoride", r.maxFluoride, "")
	}
	if r.minAlcohol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min-alcohol", r.minAlcohol, "")
	}
	if r.maxAlcohol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max-alcohol", r.maxAlcohol, "")
	}
	if r.minCaffeine != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min-caffeine", r.minCaffeine, "")
	}
	if r.maxCaffeine != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max-caffeine", r.maxCaffeine, "")
	}
	if r.minSaturatedFat != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min-saturated-fat", r.minSaturatedFat, "")
	}
	if r.maxSaturatedFat != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max-saturated-fat", r.maxSaturatedFat, "")
	}
	if r.minVitaminA != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min-vitamin-a", r.minVitaminA, "")
	}
	if r.maxVitaminA != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max-vitamin-a", r.maxVitaminA, "")
	}
	if r.minVitaminC != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min-vitamin-c", r.minVitaminC, "")
	}
	if r.maxVitaminC != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max-vitamin-c", r.maxVitaminC, "")
	}
	if r.minVitaminD != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min-vitamin-d", r.minVitaminD, "")
	}
	if r.maxVitaminD != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max-vitamin-d", r.maxVitaminD, "")
	}
	if r.minVitaminE != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min-vitamin-e", r.minVitaminE, "")
	}
	if r.maxVitaminE != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max-vitamin-e", r.maxVitaminE, "")
	}
	if r.minVitaminK != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min-vitamin-k", r.minVitaminK, "")
	}
	if r.maxVitaminK != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max-vitamin-k", r.maxVitaminK, "")
	}
	if r.minVitaminB1 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min-vitamin-b1", r.minVitaminB1, "")
	}
	if r.maxVitaminB1 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max-vitamin-b1", r.maxVitaminB1, "")
	}
	if r.minVitaminB2 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min-vitamin-b2", r.minVitaminB2, "")
	}
	if r.maxVitaminB2 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max-vitamin-b2", r.maxVitaminB2, "")
	}
	if r.minVitaminB3 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min-vitamin-b3", r.minVitaminB3, "")
	}
	if r.maxVitaminB3 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max-vitamin-b3", r.maxVitaminB3, "")
	}
	if r.minVitaminB5 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min-vitamin-b5", r.minVitaminB5, "")
	}
	if r.maxVitaminB5 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max-vitamin-b5", r.maxVitaminB5, "")
	}
	if r.minVitaminB6 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min-vitamin-b6", r.minVitaminB6, "")
	}
	if r.maxVitaminB6 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max-vitamin-b6", r.maxVitaminB6, "")
	}
	if r.minVitaminB12 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min-vitamin-b12", r.minVitaminB12, "")
	}
	if r.maxVitaminB12 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max-vitamin-b12", r.maxVitaminB12, "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "")
	}
	if r.sortDirection != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort-direction", r.sortDirection, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.number != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "number", r.number, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api-key", key)
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["headerApiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchRestaurantsRequest struct {
	ctx context.Context
	ApiService *FoodAPIService
	lat *float64
	lon *float64
	query *string
	distance *int32
	budget *float64
	minRating *float64
	cuisine *string
	isOpen *bool
	page *int32
	sort *string
}

// The latitude to search around.
func (r ApiSearchRestaurantsRequest) Lat(lat float64) ApiSearchRestaurantsRequest {
	r.lat = &lat
	return r
}

// The longitude to search around.
func (r ApiSearchRestaurantsRequest) Lon(lon float64) ApiSearchRestaurantsRequest {
	r.lon = &lon
	return r
}

// The search query.
func (r ApiSearchRestaurantsRequest) Query(query string) ApiSearchRestaurantsRequest {
	r.query = &query
	return r
}

// The maximum distance of the restaurant in miles around the given location.
func (r ApiSearchRestaurantsRequest) Distance(distance int32) ApiSearchRestaurantsRequest {
	r.distance = &distance
	return r
}

// The budget in USD for the meal.
func (r ApiSearchRestaurantsRequest) Budget(budget float64) ApiSearchRestaurantsRequest {
	r.budget = &budget
	return r
}

// The minimum rating of the restaurants in range [0,5].
func (r ApiSearchRestaurantsRequest) MinRating(minRating float64) ApiSearchRestaurantsRequest {
	r.minRating = &minRating
	return r
}

// The cuisine that the restaurants should support.
func (r ApiSearchRestaurantsRequest) Cuisine(cuisine string) ApiSearchRestaurantsRequest {
	r.cuisine = &cuisine
	return r
}

// Whether the restaurants have to be open now.
func (r ApiSearchRestaurantsRequest) IsOpen(isOpen bool) ApiSearchRestaurantsRequest {
	r.isOpen = &isOpen
	return r
}

// The page of the results.
func (r ApiSearchRestaurantsRequest) Page(page int32) ApiSearchRestaurantsRequest {
	r.page = &page
	return r
}

// The sort parameter, one of: cheapest, fastest, rating, distance or relevance.
func (r ApiSearchRestaurantsRequest) Sort(sort string) ApiSearchRestaurantsRequest {
	r.sort = &sort
	return r
}

func (r ApiSearchRestaurantsRequest) Execute() (*SearchRestaurants200Response, *http.Response, error) {
	return r.ApiService.SearchRestaurantsExecute(r)
}

/*
SearchRestaurants Search Restaurants

Search through thousands of restaurants (in North America) by location, cuisine, budget, and more.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSearchRestaurantsRequest
*/
func (a *FoodAPIService) SearchRestaurants(ctx context.Context) ApiSearchRestaurantsRequest {
	return ApiSearchRestaurantsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SearchRestaurants200Response
func (a *FoodAPIService) SearchRestaurantsExecute(r ApiSearchRestaurantsRequest) (*SearchRestaurants200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SearchRestaurants200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FoodAPIService.SearchRestaurants")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/search-restaurants"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.lat == nil {
		return localVarReturnValue, nil, reportError("lat is required and must be specified")
	}
	if *r.lat < -999 {
		return localVarReturnValue, nil, reportError("lat must be greater than -999")
	}
	if *r.lat > 999 {
		return localVarReturnValue, nil, reportError("lat must be less than 999")
	}
	if r.lon == nil {
		return localVarReturnValue, nil, reportError("lon is required and must be specified")
	}
	if *r.lon < -999 {
		return localVarReturnValue, nil, reportError("lon must be greater than -999")
	}
	if *r.lon > 999 {
		return localVarReturnValue, nil, reportError("lon must be less than 999")
	}

	if r.query != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "query", r.query, "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "lat", r.lat, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "lon", r.lon, "")
	if r.distance != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "distance", r.distance, "")
	}
	if r.budget != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "budget", r.budget, "")
	}
	if r.minRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min-rating", r.minRating, "")
	}
	if r.cuisine != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cuisine", r.cuisine, "")
	}
	if r.isOpen != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "is-open", r.isOpen, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api-key", key)
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["headerApiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
