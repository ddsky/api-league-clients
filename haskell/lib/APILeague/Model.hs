{-
   API League

   API League is a Hub for World Class APIs.

   OpenAPI Version: 3.0.0
   API League API version: 1.0
   Contact: mail@apileague.com
   Generated by OpenAPI Generator (https://openapi-generator.tech)
-}

{-|
Module : APILeague.Model
-}

{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveFoldable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE DeriveTraversable #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE NamedFieldPuns #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE TupleSections #-}
{-# LANGUAGE TypeFamilies #-}
{-# OPTIONS_GHC -fno-warn-unused-matches -fno-warn-unused-binds -fno-warn-unused-imports #-}

module APILeague.Model where

import APILeague.Core
import APILeague.MimeTypes

import Data.Aeson ((.:),(.:!),(.:?),(.=))

import qualified Control.Arrow as P (left)
import qualified Data.Aeson as A
import qualified Data.ByteString as B
import qualified Data.ByteString.Base64 as B64
import qualified Data.ByteString.Char8 as BC
import qualified Data.ByteString.Lazy as BL
import qualified Data.Data as P (Typeable, TypeRep, typeOf, typeRep)
import qualified Data.Foldable as P
import qualified Data.HashMap.Lazy as HM
import qualified Data.Map as Map
import qualified Data.Maybe as P
import qualified Data.Set as Set
import qualified Data.Text as T
import qualified Data.Text.Encoding as T
import qualified Data.Time as TI
import qualified Lens.Micro as L
import qualified Web.FormUrlEncoded as WH
import qualified Web.HttpApiData as WH

import Control.Applicative ((<|>))
import Control.Applicative (Alternative)
import Data.Function ((&))
import Data.Monoid ((<>))
import Data.Text (Text)
import Prelude (($),(/=),(.),(<$>),(<*>),(>>=),(=<<),Maybe(..),Bool(..),Char,Double,FilePath,Float,Int,Integer,String,fmap,undefined,mempty,maybe,pure,Monad,Applicative,Functor)

import qualified Prelude as P



-- * Parameter newtypes


-- ** Analyze
newtype Analyze = Analyze { unAnalyze :: Bool } deriving (P.Eq, P.Show)

-- ** Authors
newtype Authors = Authors { unAuthors :: Text } deriving (P.Eq, P.Show)

-- ** Crop
newtype Crop = Crop { unCrop :: Bool } deriving (P.Eq, P.Show)

-- ** EarliestPublishDate
newtype EarliestPublishDate = EarliestPublishDate { unEarliestPublishDate :: Text } deriving (P.Eq, P.Show)

-- ** EarliestPublishYear
newtype EarliestPublishYear = EarliestPublishYear { unEarliestPublishYear :: Int } deriving (P.Eq, P.Show)

-- ** Entities
newtype Entities = Entities { unEntities :: Text } deriving (P.Eq, P.Show)

-- ** ExcludeTags
newtype ExcludeTags = ExcludeTags { unExcludeTags :: Text } deriving (P.Eq, P.Show)

-- ** FoodName
newtype FoodName = FoodName { unFoodName :: Text } deriving (P.Eq, P.Show)

-- ** Genres
newtype Genres = Genres { unGenres :: Text } deriving (P.Eq, P.Show)

-- ** GroupResults
newtype GroupResults = GroupResults { unGroupResults :: Bool } deriving (P.Eq, P.Show)

-- ** Height
newtype Height = Height { unHeight :: Int } deriving (P.Eq, P.Show)

-- ** Id
newtype Id = Id { unId :: Int } deriving (P.Eq, P.Show)

-- ** IncludeTags
newtype IncludeTags = IncludeTags { unIncludeTags :: Text } deriving (P.Eq, P.Show)

-- ** Isbn
newtype Isbn = Isbn { unIsbn :: Text } deriving (P.Eq, P.Show)

-- ** Key
newtype Key = Key { unKey :: Text } deriving (P.Eq, P.Show)

-- ** Keywords
newtype Keywords = Keywords { unKeywords :: Text } deriving (P.Eq, P.Show)

-- ** KeywordsInImage
newtype KeywordsInImage = KeywordsInImage { unKeywordsInImage :: Bool } deriving (P.Eq, P.Show)

-- ** Language
newtype Language = Language { unLanguage :: Text } deriving (P.Eq, P.Show)

-- ** LatestPublishDate
newtype LatestPublishDate = LatestPublishDate { unLatestPublishDate :: Text } deriving (P.Eq, P.Show)

-- ** LatestPublishYear
newtype LatestPublishYear = LatestPublishYear { unLatestPublishYear :: Int } deriving (P.Eq, P.Show)

-- ** LocationFilter
newtype LocationFilter = LocationFilter { unLocationFilter :: Text } deriving (P.Eq, P.Show)

-- ** MaxAgeDays
newtype MaxAgeDays = MaxAgeDays { unMaxAgeDays :: Int } deriving (P.Eq, P.Show)

-- ** MaxLength
newtype MaxLength = MaxLength { unMaxLength :: Double } deriving (P.Eq, P.Show)

-- ** MaxLengthInt
newtype MaxLengthInt = MaxLengthInt { unMaxLengthInt :: Int } deriving (P.Eq, P.Show)

-- ** MaxLines
newtype MaxLines = MaxLines { unMaxLines :: Int } deriving (P.Eq, P.Show)

-- ** MaxRating
newtype MaxRating = MaxRating { unMaxRating :: Double } deriving (P.Eq, P.Show)

-- ** MaxSentiment
newtype MaxSentiment = MaxSentiment { unMaxSentiment :: Double } deriving (P.Eq, P.Show)

-- ** MediaType
newtype MediaType = MediaType { unMediaType :: Text } deriving (P.Eq, P.Show)

-- ** MinLength
newtype MinLength = MinLength { unMinLength :: Int } deriving (P.Eq, P.Show)

-- ** MinLines
newtype MinLines = MinLines { unMinLines :: Int } deriving (P.Eq, P.Show)

-- ** MinRating
newtype MinRating = MinRating { unMinRating :: Double } deriving (P.Eq, P.Show)

-- ** MinSentiment
newtype MinSentiment = MinSentiment { unMinSentiment :: Double } deriving (P.Eq, P.Show)

-- ** NewsSources
newtype NewsSources = NewsSources { unNewsSources :: Text } deriving (P.Eq, P.Show)

-- ** Number
newtype Number = Number { unNumber :: Int } deriving (P.Eq, P.Show)

-- ** Oclc
newtype Oclc = Oclc { unOclc :: Text } deriving (P.Eq, P.Show)

-- ** Offset
newtype Offset = Offset { unOffset :: Int } deriving (P.Eq, P.Show)

-- ** ParamText
newtype ParamText = ParamText { unParamText :: Text } deriving (P.Eq, P.Show)

-- ** Query
newtype Query = Query { unQuery :: Text } deriving (P.Eq, P.Show)

-- ** Sort
newtype Sort = Sort { unSort :: Text } deriving (P.Eq, P.Show)

-- ** SortDirection
newtype SortDirection = SortDirection { unSortDirection :: Text } deriving (P.Eq, P.Show)

-- ** SourceAmount
newtype SourceAmount = SourceAmount { unSourceAmount :: Double } deriving (P.Eq, P.Show)

-- ** SourceCountries
newtype SourceCountries = SourceCountries { unSourceCountries :: Text } deriving (P.Eq, P.Show)

-- ** SourceUnit
newtype SourceUnit = SourceUnit { unSourceUnit :: Text } deriving (P.Eq, P.Show)

-- ** TargetUnit
newtype TargetUnit = TargetUnit { unTargetUnit :: Text } deriving (P.Eq, P.Show)

-- ** Title
newtype Title = Title { unTitle :: Text } deriving (P.Eq, P.Show)

-- ** Url
newtype Url = Url { unUrl :: Text } deriving (P.Eq, P.Show)

-- ** Value
newtype Value = Value { unValue :: Text } deriving (P.Eq, P.Show)

-- ** Width
newtype Width = Width { unWidth :: Int } deriving (P.Eq, P.Show)

-- ** Word
newtype Word = Word { unWord :: Text } deriving (P.Eq, P.Show)

-- * Models


-- ** InlineResponse200
-- | InlineResponse200
data InlineResponse200 = InlineResponse200
  { inlineResponse200Available :: !(Maybe Int) -- ^ "available"
  , inlineResponse200Number :: !(Maybe Int) -- ^ "number"
  , inlineResponse200Offset :: !(Maybe Int) -- ^ "offset"
  , inlineResponse200Books :: !(Maybe [InlineResponse200Books]) -- ^ "books"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse200
instance A.FromJSON InlineResponse200 where
  parseJSON = A.withObject "InlineResponse200" $ \o ->
    InlineResponse200
      <$> (o .:? "available")
      <*> (o .:? "number")
      <*> (o .:? "offset")
      <*> (o .:? "books")

-- | ToJSON InlineResponse200
instance A.ToJSON InlineResponse200 where
  toJSON InlineResponse200 {..} =
   _omitNulls
      [ "available" .= inlineResponse200Available
      , "number" .= inlineResponse200Number
      , "offset" .= inlineResponse200Offset
      , "books" .= inlineResponse200Books
      ]


-- | Construct a value of type 'InlineResponse200' (by applying it's required fields, if any)
mkInlineResponse200
  :: InlineResponse200
mkInlineResponse200 =
  InlineResponse200
  { inlineResponse200Available = Nothing
  , inlineResponse200Number = Nothing
  , inlineResponse200Offset = Nothing
  , inlineResponse200Books = Nothing
  }

-- ** InlineResponse2001
-- | InlineResponse2001
data InlineResponse2001 = InlineResponse2001
  { inlineResponse2001SimilarBooks :: !(Maybe [InlineResponse200Books]) -- ^ "similar_books"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse2001
instance A.FromJSON InlineResponse2001 where
  parseJSON = A.withObject "InlineResponse2001" $ \o ->
    InlineResponse2001
      <$> (o .:? "similar_books")

-- | ToJSON InlineResponse2001
instance A.ToJSON InlineResponse2001 where
  toJSON InlineResponse2001 {..} =
   _omitNulls
      [ "similar_books" .= inlineResponse2001SimilarBooks
      ]


-- | Construct a value of type 'InlineResponse2001' (by applying it's required fields, if any)
mkInlineResponse2001
  :: InlineResponse2001
mkInlineResponse2001 =
  InlineResponse2001
  { inlineResponse2001SimilarBooks = Nothing
  }

-- ** InlineResponse20010
-- | InlineResponse20010
data InlineResponse20010 = InlineResponse20010
  { inlineResponse20010Author :: !(Maybe Text) -- ^ "author"
  , inlineResponse20010Quote :: !(Maybe Text) -- ^ "quote"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20010
instance A.FromJSON InlineResponse20010 where
  parseJSON = A.withObject "InlineResponse20010" $ \o ->
    InlineResponse20010
      <$> (o .:? "author")
      <*> (o .:? "quote")

-- | ToJSON InlineResponse20010
instance A.ToJSON InlineResponse20010 where
  toJSON InlineResponse20010 {..} =
   _omitNulls
      [ "author" .= inlineResponse20010Author
      , "quote" .= inlineResponse20010Quote
      ]


-- | Construct a value of type 'InlineResponse20010' (by applying it's required fields, if any)
mkInlineResponse20010
  :: InlineResponse20010
mkInlineResponse20010 =
  InlineResponse20010
  { inlineResponse20010Author = Nothing
  , inlineResponse20010Quote = Nothing
  }

-- ** InlineResponse20011
-- | InlineResponse20011
data InlineResponse20011 = InlineResponse20011
  { inlineResponse20011Title :: !(Maybe Text) -- ^ "title"
  , inlineResponse20011Author :: !(Maybe Text) -- ^ "author"
  , inlineResponse20011Poem :: !(Maybe Text) -- ^ "poem"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20011
instance A.FromJSON InlineResponse20011 where
  parseJSON = A.withObject "InlineResponse20011" $ \o ->
    InlineResponse20011
      <$> (o .:? "title")
      <*> (o .:? "author")
      <*> (o .:? "poem")

-- | ToJSON InlineResponse20011
instance A.ToJSON InlineResponse20011 where
  toJSON InlineResponse20011 {..} =
   _omitNulls
      [ "title" .= inlineResponse20011Title
      , "author" .= inlineResponse20011Author
      , "poem" .= inlineResponse20011Poem
      ]


-- | Construct a value of type 'InlineResponse20011' (by applying it's required fields, if any)
mkInlineResponse20011
  :: InlineResponse20011
mkInlineResponse20011 =
  InlineResponse20011
  { inlineResponse20011Title = Nothing
  , inlineResponse20011Author = Nothing
  , inlineResponse20011Poem = Nothing
  }

-- ** InlineResponse20012
-- | InlineResponse20012
data InlineResponse20012 = InlineResponse20012
  { inlineResponse20012Title :: !(Maybe Text) -- ^ "title"
  , inlineResponse20012MainText :: !(Maybe Text) -- ^ "main_text"
  , inlineResponse20012MainHtml :: !(Maybe Text) -- ^ "main_html"
  , inlineResponse20012Images :: !(Maybe [Text]) -- ^ "images"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20012
instance A.FromJSON InlineResponse20012 where
  parseJSON = A.withObject "InlineResponse20012" $ \o ->
    InlineResponse20012
      <$> (o .:? "title")
      <*> (o .:? "main_text")
      <*> (o .:? "main_html")
      <*> (o .:? "images")

-- | ToJSON InlineResponse20012
instance A.ToJSON InlineResponse20012 where
  toJSON InlineResponse20012 {..} =
   _omitNulls
      [ "title" .= inlineResponse20012Title
      , "main_text" .= inlineResponse20012MainText
      , "main_html" .= inlineResponse20012MainHtml
      , "images" .= inlineResponse20012Images
      ]


-- | Construct a value of type 'InlineResponse20012' (by applying it's required fields, if any)
mkInlineResponse20012
  :: InlineResponse20012
mkInlineResponse20012 =
  InlineResponse20012
  { inlineResponse20012Title = Nothing
  , inlineResponse20012MainText = Nothing
  , inlineResponse20012MainHtml = Nothing
  , inlineResponse20012Images = Nothing
  }

-- ** InlineResponse20013
-- | InlineResponse20013
data InlineResponse20013 = InlineResponse20013
  { inlineResponse20013PublishDate :: !(Maybe Text) -- ^ "publish_date"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20013
instance A.FromJSON InlineResponse20013 where
  parseJSON = A.withObject "InlineResponse20013" $ \o ->
    InlineResponse20013
      <$> (o .:? "publish_date")

-- | ToJSON InlineResponse20013
instance A.ToJSON InlineResponse20013 where
  toJSON InlineResponse20013 {..} =
   _omitNulls
      [ "publish_date" .= inlineResponse20013PublishDate
      ]


-- | Construct a value of type 'InlineResponse20013' (by applying it's required fields, if any)
mkInlineResponse20013
  :: InlineResponse20013
mkInlineResponse20013 =
  InlineResponse20013
  { inlineResponse20013PublishDate = Nothing
  }

-- ** InlineResponse20014
-- | InlineResponse20014
data InlineResponse20014 = InlineResponse20014
  { inlineResponse20014Authors :: !(Maybe [InlineResponse20014Authors]) -- ^ "authors"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20014
instance A.FromJSON InlineResponse20014 where
  parseJSON = A.withObject "InlineResponse20014" $ \o ->
    InlineResponse20014
      <$> (o .:? "authors")

-- | ToJSON InlineResponse20014
instance A.ToJSON InlineResponse20014 where
  toJSON InlineResponse20014 {..} =
   _omitNulls
      [ "authors" .= inlineResponse20014Authors
      ]


-- | Construct a value of type 'InlineResponse20014' (by applying it's required fields, if any)
mkInlineResponse20014
  :: InlineResponse20014
mkInlineResponse20014 =
  InlineResponse20014
  { inlineResponse20014Authors = Nothing
  }

-- ** InlineResponse20014Authors
-- | InlineResponse20014Authors
data InlineResponse20014Authors = InlineResponse20014Authors
  { inlineResponse20014AuthorsLink :: !(Maybe Text) -- ^ "link"
  , inlineResponse20014AuthorsName :: !(Maybe Text) -- ^ "name"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20014Authors
instance A.FromJSON InlineResponse20014Authors where
  parseJSON = A.withObject "InlineResponse20014Authors" $ \o ->
    InlineResponse20014Authors
      <$> (o .:? "link")
      <*> (o .:? "name")

-- | ToJSON InlineResponse20014Authors
instance A.ToJSON InlineResponse20014Authors where
  toJSON InlineResponse20014Authors {..} =
   _omitNulls
      [ "link" .= inlineResponse20014AuthorsLink
      , "name" .= inlineResponse20014AuthorsName
      ]


-- | Construct a value of type 'InlineResponse20014Authors' (by applying it's required fields, if any)
mkInlineResponse20014Authors
  :: InlineResponse20014Authors
mkInlineResponse20014Authors =
  InlineResponse20014Authors
  { inlineResponse20014AuthorsLink = Nothing
  , inlineResponse20014AuthorsName = Nothing
  }

-- ** InlineResponse20015
-- | InlineResponse20015
data InlineResponse20015 = InlineResponse20015
  { inlineResponse20015Results :: !(Maybe [InlineResponse20015Results]) -- ^ "results"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20015
instance A.FromJSON InlineResponse20015 where
  parseJSON = A.withObject "InlineResponse20015" $ \o ->
    InlineResponse20015
      <$> (o .:? "results")

-- | ToJSON InlineResponse20015
instance A.ToJSON InlineResponse20015 where
  toJSON InlineResponse20015 {..} =
   _omitNulls
      [ "results" .= inlineResponse20015Results
      ]


-- | Construct a value of type 'InlineResponse20015' (by applying it's required fields, if any)
mkInlineResponse20015
  :: InlineResponse20015
mkInlineResponse20015 =
  InlineResponse20015
  { inlineResponse20015Results = Nothing
  }

-- ** InlineResponse20015Results
-- | InlineResponse20015Results
data InlineResponse20015Results = InlineResponse20015Results
  { inlineResponse20015ResultsTitle :: !(Maybe Text) -- ^ "title"
  , inlineResponse20015ResultsSummary :: !(Maybe Text) -- ^ "summary"
  , inlineResponse20015ResultsUrl :: !(Maybe Text) -- ^ "url"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20015Results
instance A.FromJSON InlineResponse20015Results where
  parseJSON = A.withObject "InlineResponse20015Results" $ \o ->
    InlineResponse20015Results
      <$> (o .:? "title")
      <*> (o .:? "summary")
      <*> (o .:? "url")

-- | ToJSON InlineResponse20015Results
instance A.ToJSON InlineResponse20015Results where
  toJSON InlineResponse20015Results {..} =
   _omitNulls
      [ "title" .= inlineResponse20015ResultsTitle
      , "summary" .= inlineResponse20015ResultsSummary
      , "url" .= inlineResponse20015ResultsUrl
      ]


-- | Construct a value of type 'InlineResponse20015Results' (by applying it's required fields, if any)
mkInlineResponse20015Results
  :: InlineResponse20015Results
mkInlineResponse20015Results =
  InlineResponse20015Results
  { inlineResponse20015ResultsTitle = Nothing
  , inlineResponse20015ResultsSummary = Nothing
  , inlineResponse20015ResultsUrl = Nothing
  }

-- ** InlineResponse20016
-- | InlineResponse20016
data InlineResponse20016 = InlineResponse20016
  { inlineResponse20016CorrectedText :: !(Maybe Text) -- ^ "corrected_text"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20016
instance A.FromJSON InlineResponse20016 where
  parseJSON = A.withObject "InlineResponse20016" $ \o ->
    InlineResponse20016
      <$> (o .:? "corrected_text")

-- | ToJSON InlineResponse20016
instance A.ToJSON InlineResponse20016 where
  toJSON InlineResponse20016 {..} =
   _omitNulls
      [ "corrected_text" .= inlineResponse20016CorrectedText
      ]


-- | Construct a value of type 'InlineResponse20016' (by applying it's required fields, if any)
mkInlineResponse20016
  :: InlineResponse20016
mkInlineResponse20016 =
  InlineResponse20016
  { inlineResponse20016CorrectedText = Nothing
  }

-- ** InlineResponse20017
-- | InlineResponse20017
data InlineResponse20017 = InlineResponse20017
  { inlineResponse20017Language :: !(Maybe Text) -- ^ "language"
  , inlineResponse20017Confidence :: !(Maybe Double) -- ^ "confidence"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20017
instance A.FromJSON InlineResponse20017 where
  parseJSON = A.withObject "InlineResponse20017" $ \o ->
    InlineResponse20017
      <$> (o .:? "language")
      <*> (o .:? "confidence")

-- | ToJSON InlineResponse20017
instance A.ToJSON InlineResponse20017 where
  toJSON InlineResponse20017 {..} =
   _omitNulls
      [ "language" .= inlineResponse20017Language
      , "confidence" .= inlineResponse20017Confidence
      ]


-- | Construct a value of type 'InlineResponse20017' (by applying it's required fields, if any)
mkInlineResponse20017
  :: InlineResponse20017
mkInlineResponse20017 =
  InlineResponse20017
  { inlineResponse20017Language = Nothing
  , inlineResponse20017Confidence = Nothing
  }

-- ** InlineResponse20018
-- | InlineResponse20018
data InlineResponse20018 = InlineResponse20018
  { inlineResponse20018Document :: !(Maybe InlineResponse20018Document) -- ^ "document"
  , inlineResponse20018Sentences :: !(Maybe [InlineResponse20018Sentences]) -- ^ "sentences"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20018
instance A.FromJSON InlineResponse20018 where
  parseJSON = A.withObject "InlineResponse20018" $ \o ->
    InlineResponse20018
      <$> (o .:? "document")
      <*> (o .:? "sentences")

-- | ToJSON InlineResponse20018
instance A.ToJSON InlineResponse20018 where
  toJSON InlineResponse20018 {..} =
   _omitNulls
      [ "document" .= inlineResponse20018Document
      , "sentences" .= inlineResponse20018Sentences
      ]


-- | Construct a value of type 'InlineResponse20018' (by applying it's required fields, if any)
mkInlineResponse20018
  :: InlineResponse20018
mkInlineResponse20018 =
  InlineResponse20018
  { inlineResponse20018Document = Nothing
  , inlineResponse20018Sentences = Nothing
  }

-- ** InlineResponse20018Document
-- | InlineResponse20018Document
data InlineResponse20018Document = InlineResponse20018Document
  { inlineResponse20018DocumentSentiment :: !(Maybe Text) -- ^ "sentiment"
  , inlineResponse20018DocumentConfidence :: !(Maybe Int) -- ^ "confidence"
  , inlineResponse20018DocumentAverageConfidence :: !(Maybe Int) -- ^ "average_confidence"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20018Document
instance A.FromJSON InlineResponse20018Document where
  parseJSON = A.withObject "InlineResponse20018Document" $ \o ->
    InlineResponse20018Document
      <$> (o .:? "sentiment")
      <*> (o .:? "confidence")
      <*> (o .:? "average_confidence")

-- | ToJSON InlineResponse20018Document
instance A.ToJSON InlineResponse20018Document where
  toJSON InlineResponse20018Document {..} =
   _omitNulls
      [ "sentiment" .= inlineResponse20018DocumentSentiment
      , "confidence" .= inlineResponse20018DocumentConfidence
      , "average_confidence" .= inlineResponse20018DocumentAverageConfidence
      ]


-- | Construct a value of type 'InlineResponse20018Document' (by applying it's required fields, if any)
mkInlineResponse20018Document
  :: InlineResponse20018Document
mkInlineResponse20018Document =
  InlineResponse20018Document
  { inlineResponse20018DocumentSentiment = Nothing
  , inlineResponse20018DocumentConfidence = Nothing
  , inlineResponse20018DocumentAverageConfidence = Nothing
  }

-- ** InlineResponse20018Sentences
-- | InlineResponse20018Sentences
data InlineResponse20018Sentences = InlineResponse20018Sentences
  { inlineResponse20018SentencesLength :: !(Maybe Int) -- ^ "length"
  , inlineResponse20018SentencesSentiment :: !(Maybe Text) -- ^ "sentiment"
  , inlineResponse20018SentencesOffset :: !(Maybe Int) -- ^ "offset"
  , inlineResponse20018SentencesConfidence :: !(Maybe Int) -- ^ "confidence"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20018Sentences
instance A.FromJSON InlineResponse20018Sentences where
  parseJSON = A.withObject "InlineResponse20018Sentences" $ \o ->
    InlineResponse20018Sentences
      <$> (o .:? "length")
      <*> (o .:? "sentiment")
      <*> (o .:? "offset")
      <*> (o .:? "confidence")

-- | ToJSON InlineResponse20018Sentences
instance A.ToJSON InlineResponse20018Sentences where
  toJSON InlineResponse20018Sentences {..} =
   _omitNulls
      [ "length" .= inlineResponse20018SentencesLength
      , "sentiment" .= inlineResponse20018SentencesSentiment
      , "offset" .= inlineResponse20018SentencesOffset
      , "confidence" .= inlineResponse20018SentencesConfidence
      ]


-- | Construct a value of type 'InlineResponse20018Sentences' (by applying it's required fields, if any)
mkInlineResponse20018Sentences
  :: InlineResponse20018Sentences
mkInlineResponse20018Sentences =
  InlineResponse20018Sentences
  { inlineResponse20018SentencesLength = Nothing
  , inlineResponse20018SentencesSentiment = Nothing
  , inlineResponse20018SentencesOffset = Nothing
  , inlineResponse20018SentencesConfidence = Nothing
  }

-- ** InlineResponse20019
-- | InlineResponse20019
data InlineResponse20019 = InlineResponse20019
  { inlineResponse20019NumberOfWords :: !(Maybe Int) -- ^ "number_of_words"
  , inlineResponse20019NumberOfSentences :: !(Maybe Int) -- ^ "number_of_sentences"
  , inlineResponse20019Readability :: !(Maybe InlineResponse20019Readability) -- ^ "readability"
  , inlineResponse20019Skimmability :: !(Maybe InlineResponse20019Skimmability) -- ^ "skimmability"
  , inlineResponse20019Interestingness :: !(Maybe InlineResponse20019Interestingness) -- ^ "interestingness"
  , inlineResponse20019Style :: !(Maybe InlineResponse20019Style) -- ^ "style"
  , inlineResponse20019TotalScore :: !(Maybe Double) -- ^ "total_score"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20019
instance A.FromJSON InlineResponse20019 where
  parseJSON = A.withObject "InlineResponse20019" $ \o ->
    InlineResponse20019
      <$> (o .:? "number_of_words")
      <*> (o .:? "number_of_sentences")
      <*> (o .:? "readability")
      <*> (o .:? "skimmability")
      <*> (o .:? "interestingness")
      <*> (o .:? "style")
      <*> (o .:? "total_score")

-- | ToJSON InlineResponse20019
instance A.ToJSON InlineResponse20019 where
  toJSON InlineResponse20019 {..} =
   _omitNulls
      [ "number_of_words" .= inlineResponse20019NumberOfWords
      , "number_of_sentences" .= inlineResponse20019NumberOfSentences
      , "readability" .= inlineResponse20019Readability
      , "skimmability" .= inlineResponse20019Skimmability
      , "interestingness" .= inlineResponse20019Interestingness
      , "style" .= inlineResponse20019Style
      , "total_score" .= inlineResponse20019TotalScore
      ]


-- | Construct a value of type 'InlineResponse20019' (by applying it's required fields, if any)
mkInlineResponse20019
  :: InlineResponse20019
mkInlineResponse20019 =
  InlineResponse20019
  { inlineResponse20019NumberOfWords = Nothing
  , inlineResponse20019NumberOfSentences = Nothing
  , inlineResponse20019Readability = Nothing
  , inlineResponse20019Skimmability = Nothing
  , inlineResponse20019Interestingness = Nothing
  , inlineResponse20019Style = Nothing
  , inlineResponse20019TotalScore = Nothing
  }

-- ** InlineResponse20019Interestingness
-- | InlineResponse20019Interestingness
data InlineResponse20019Interestingness = InlineResponse20019Interestingness
  { inlineResponse20019InterestingnessMainscores :: !(Maybe InlineResponse20019SkimmabilityMainscores) -- ^ "mainscores"
  , inlineResponse20019InterestingnessSubscores :: !(Maybe InlineResponse20019InterestingnessSubscores) -- ^ "subscores"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20019Interestingness
instance A.FromJSON InlineResponse20019Interestingness where
  parseJSON = A.withObject "InlineResponse20019Interestingness" $ \o ->
    InlineResponse20019Interestingness
      <$> (o .:? "mainscores")
      <*> (o .:? "subscores")

-- | ToJSON InlineResponse20019Interestingness
instance A.ToJSON InlineResponse20019Interestingness where
  toJSON InlineResponse20019Interestingness {..} =
   _omitNulls
      [ "mainscores" .= inlineResponse20019InterestingnessMainscores
      , "subscores" .= inlineResponse20019InterestingnessSubscores
      ]


-- | Construct a value of type 'InlineResponse20019Interestingness' (by applying it's required fields, if any)
mkInlineResponse20019Interestingness
  :: InlineResponse20019Interestingness
mkInlineResponse20019Interestingness =
  InlineResponse20019Interestingness
  { inlineResponse20019InterestingnessMainscores = Nothing
  , inlineResponse20019InterestingnessSubscores = Nothing
  }

-- ** InlineResponse20019InterestingnessSubscores
-- | InlineResponse20019InterestingnessSubscores
data InlineResponse20019InterestingnessSubscores = InlineResponse20019InterestingnessSubscores
  { inlineResponse20019InterestingnessSubscoresTitleRatingScore :: !(Maybe [Int]) -- ^ "title_rating_score"
  , inlineResponse20019InterestingnessSubscoresQuoteScore :: !(Maybe [Int]) -- ^ "quote_score"
  , inlineResponse20019InterestingnessSubscoresLengthScore :: !(Maybe [Int]) -- ^ "length_score"
  , inlineResponse20019InterestingnessSubscoresLinkScore :: !(Maybe [Int]) -- ^ "link_score"
  , inlineResponse20019InterestingnessSubscoresGoogleHitsScore :: !(Maybe [Int]) -- ^ "google_hits_score"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20019InterestingnessSubscores
instance A.FromJSON InlineResponse20019InterestingnessSubscores where
  parseJSON = A.withObject "InlineResponse20019InterestingnessSubscores" $ \o ->
    InlineResponse20019InterestingnessSubscores
      <$> (o .:? "title_rating_score")
      <*> (o .:? "quote_score")
      <*> (o .:? "length_score")
      <*> (o .:? "link_score")
      <*> (o .:? "google_hits_score")

-- | ToJSON InlineResponse20019InterestingnessSubscores
instance A.ToJSON InlineResponse20019InterestingnessSubscores where
  toJSON InlineResponse20019InterestingnessSubscores {..} =
   _omitNulls
      [ "title_rating_score" .= inlineResponse20019InterestingnessSubscoresTitleRatingScore
      , "quote_score" .= inlineResponse20019InterestingnessSubscoresQuoteScore
      , "length_score" .= inlineResponse20019InterestingnessSubscoresLengthScore
      , "link_score" .= inlineResponse20019InterestingnessSubscoresLinkScore
      , "google_hits_score" .= inlineResponse20019InterestingnessSubscoresGoogleHitsScore
      ]


-- | Construct a value of type 'InlineResponse20019InterestingnessSubscores' (by applying it's required fields, if any)
mkInlineResponse20019InterestingnessSubscores
  :: InlineResponse20019InterestingnessSubscores
mkInlineResponse20019InterestingnessSubscores =
  InlineResponse20019InterestingnessSubscores
  { inlineResponse20019InterestingnessSubscoresTitleRatingScore = Nothing
  , inlineResponse20019InterestingnessSubscoresQuoteScore = Nothing
  , inlineResponse20019InterestingnessSubscoresLengthScore = Nothing
  , inlineResponse20019InterestingnessSubscoresLinkScore = Nothing
  , inlineResponse20019InterestingnessSubscoresGoogleHitsScore = Nothing
  }

-- ** InlineResponse20019Readability
-- | InlineResponse20019Readability
data InlineResponse20019Readability = InlineResponse20019Readability
  { inlineResponse20019ReadabilityMainscores :: !(Maybe InlineResponse20019ReadabilityMainscores) -- ^ "mainscores"
  , inlineResponse20019ReadabilitySubscores :: !(Maybe InlineResponse20019ReadabilitySubscores) -- ^ "subscores"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20019Readability
instance A.FromJSON InlineResponse20019Readability where
  parseJSON = A.withObject "InlineResponse20019Readability" $ \o ->
    InlineResponse20019Readability
      <$> (o .:? "mainscores")
      <*> (o .:? "subscores")

-- | ToJSON InlineResponse20019Readability
instance A.ToJSON InlineResponse20019Readability where
  toJSON InlineResponse20019Readability {..} =
   _omitNulls
      [ "mainscores" .= inlineResponse20019ReadabilityMainscores
      , "subscores" .= inlineResponse20019ReadabilitySubscores
      ]


-- | Construct a value of type 'InlineResponse20019Readability' (by applying it's required fields, if any)
mkInlineResponse20019Readability
  :: InlineResponse20019Readability
mkInlineResponse20019Readability =
  InlineResponse20019Readability
  { inlineResponse20019ReadabilityMainscores = Nothing
  , inlineResponse20019ReadabilitySubscores = Nothing
  }

-- ** InlineResponse20019ReadabilityMainscores
-- | InlineResponse20019ReadabilityMainscores
data InlineResponse20019ReadabilityMainscores = InlineResponse20019ReadabilityMainscores
  { inlineResponse20019ReadabilityMainscoresTotalPossible :: !(Maybe Int) -- ^ "total_possible"
  , inlineResponse20019ReadabilityMainscoresTotal :: !(Maybe Int) -- ^ "total"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20019ReadabilityMainscores
instance A.FromJSON InlineResponse20019ReadabilityMainscores where
  parseJSON = A.withObject "InlineResponse20019ReadabilityMainscores" $ \o ->
    InlineResponse20019ReadabilityMainscores
      <$> (o .:? "total_possible")
      <*> (o .:? "total")

-- | ToJSON InlineResponse20019ReadabilityMainscores
instance A.ToJSON InlineResponse20019ReadabilityMainscores where
  toJSON InlineResponse20019ReadabilityMainscores {..} =
   _omitNulls
      [ "total_possible" .= inlineResponse20019ReadabilityMainscoresTotalPossible
      , "total" .= inlineResponse20019ReadabilityMainscoresTotal
      ]


-- | Construct a value of type 'InlineResponse20019ReadabilityMainscores' (by applying it's required fields, if any)
mkInlineResponse20019ReadabilityMainscores
  :: InlineResponse20019ReadabilityMainscores
mkInlineResponse20019ReadabilityMainscores =
  InlineResponse20019ReadabilityMainscores
  { inlineResponse20019ReadabilityMainscoresTotalPossible = Nothing
  , inlineResponse20019ReadabilityMainscoresTotal = Nothing
  }

-- ** InlineResponse20019ReadabilitySubscores
-- | InlineResponse20019ReadabilitySubscores
data InlineResponse20019ReadabilitySubscores = InlineResponse20019ReadabilitySubscores
  { inlineResponse20019ReadabilitySubscoresReadingTimeSeconds :: !(Maybe Int) -- ^ "reading_time_seconds"
  , inlineResponse20019ReadabilitySubscoresForcast :: !(Maybe Double) -- ^ "forcast"
  , inlineResponse20019ReadabilitySubscoresFlesch :: !(Maybe Double) -- ^ "flesch"
  , inlineResponse20019ReadabilitySubscoresSmog :: !(Maybe Double) -- ^ "smog"
  , inlineResponse20019ReadabilitySubscoresAri :: !(Maybe Double) -- ^ "ari"
  , inlineResponse20019ReadabilitySubscoresLix :: !(Maybe Double) -- ^ "lix"
  , inlineResponse20019ReadabilitySubscoresColemanLiau :: !(Maybe Double) -- ^ "coleman_liau"
  , inlineResponse20019ReadabilitySubscoresKincaid :: !(Maybe Double) -- ^ "kincaid"
  , inlineResponse20019ReadabilitySubscoresFog :: !(Maybe Double) -- ^ "fog"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20019ReadabilitySubscores
instance A.FromJSON InlineResponse20019ReadabilitySubscores where
  parseJSON = A.withObject "InlineResponse20019ReadabilitySubscores" $ \o ->
    InlineResponse20019ReadabilitySubscores
      <$> (o .:? "reading_time_seconds")
      <*> (o .:? "forcast")
      <*> (o .:? "flesch")
      <*> (o .:? "smog")
      <*> (o .:? "ari")
      <*> (o .:? "lix")
      <*> (o .:? "coleman_liau")
      <*> (o .:? "kincaid")
      <*> (o .:? "fog")

-- | ToJSON InlineResponse20019ReadabilitySubscores
instance A.ToJSON InlineResponse20019ReadabilitySubscores where
  toJSON InlineResponse20019ReadabilitySubscores {..} =
   _omitNulls
      [ "reading_time_seconds" .= inlineResponse20019ReadabilitySubscoresReadingTimeSeconds
      , "forcast" .= inlineResponse20019ReadabilitySubscoresForcast
      , "flesch" .= inlineResponse20019ReadabilitySubscoresFlesch
      , "smog" .= inlineResponse20019ReadabilitySubscoresSmog
      , "ari" .= inlineResponse20019ReadabilitySubscoresAri
      , "lix" .= inlineResponse20019ReadabilitySubscoresLix
      , "coleman_liau" .= inlineResponse20019ReadabilitySubscoresColemanLiau
      , "kincaid" .= inlineResponse20019ReadabilitySubscoresKincaid
      , "fog" .= inlineResponse20019ReadabilitySubscoresFog
      ]


-- | Construct a value of type 'InlineResponse20019ReadabilitySubscores' (by applying it's required fields, if any)
mkInlineResponse20019ReadabilitySubscores
  :: InlineResponse20019ReadabilitySubscores
mkInlineResponse20019ReadabilitySubscores =
  InlineResponse20019ReadabilitySubscores
  { inlineResponse20019ReadabilitySubscoresReadingTimeSeconds = Nothing
  , inlineResponse20019ReadabilitySubscoresForcast = Nothing
  , inlineResponse20019ReadabilitySubscoresFlesch = Nothing
  , inlineResponse20019ReadabilitySubscoresSmog = Nothing
  , inlineResponse20019ReadabilitySubscoresAri = Nothing
  , inlineResponse20019ReadabilitySubscoresLix = Nothing
  , inlineResponse20019ReadabilitySubscoresColemanLiau = Nothing
  , inlineResponse20019ReadabilitySubscoresKincaid = Nothing
  , inlineResponse20019ReadabilitySubscoresFog = Nothing
  }

-- ** InlineResponse20019Skimmability
-- | InlineResponse20019Skimmability
data InlineResponse20019Skimmability = InlineResponse20019Skimmability
  { inlineResponse20019SkimmabilityMainscores :: !(Maybe InlineResponse20019SkimmabilityMainscores) -- ^ "mainscores"
  , inlineResponse20019SkimmabilitySubscores :: !(Maybe InlineResponse20019SkimmabilitySubscores) -- ^ "subscores"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20019Skimmability
instance A.FromJSON InlineResponse20019Skimmability where
  parseJSON = A.withObject "InlineResponse20019Skimmability" $ \o ->
    InlineResponse20019Skimmability
      <$> (o .:? "mainscores")
      <*> (o .:? "subscores")

-- | ToJSON InlineResponse20019Skimmability
instance A.ToJSON InlineResponse20019Skimmability where
  toJSON InlineResponse20019Skimmability {..} =
   _omitNulls
      [ "mainscores" .= inlineResponse20019SkimmabilityMainscores
      , "subscores" .= inlineResponse20019SkimmabilitySubscores
      ]


-- | Construct a value of type 'InlineResponse20019Skimmability' (by applying it's required fields, if any)
mkInlineResponse20019Skimmability
  :: InlineResponse20019Skimmability
mkInlineResponse20019Skimmability =
  InlineResponse20019Skimmability
  { inlineResponse20019SkimmabilityMainscores = Nothing
  , inlineResponse20019SkimmabilitySubscores = Nothing
  }

-- ** InlineResponse20019SkimmabilityMainscores
-- | InlineResponse20019SkimmabilityMainscores
data InlineResponse20019SkimmabilityMainscores = InlineResponse20019SkimmabilityMainscores
  { inlineResponse20019SkimmabilityMainscoresTotalPossible :: !(Maybe Int) -- ^ "total_possible"
  , inlineResponse20019SkimmabilityMainscoresTotal :: !(Maybe Double) -- ^ "total"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20019SkimmabilityMainscores
instance A.FromJSON InlineResponse20019SkimmabilityMainscores where
  parseJSON = A.withObject "InlineResponse20019SkimmabilityMainscores" $ \o ->
    InlineResponse20019SkimmabilityMainscores
      <$> (o .:? "total_possible")
      <*> (o .:? "total")

-- | ToJSON InlineResponse20019SkimmabilityMainscores
instance A.ToJSON InlineResponse20019SkimmabilityMainscores where
  toJSON InlineResponse20019SkimmabilityMainscores {..} =
   _omitNulls
      [ "total_possible" .= inlineResponse20019SkimmabilityMainscoresTotalPossible
      , "total" .= inlineResponse20019SkimmabilityMainscoresTotal
      ]


-- | Construct a value of type 'InlineResponse20019SkimmabilityMainscores' (by applying it's required fields, if any)
mkInlineResponse20019SkimmabilityMainscores
  :: InlineResponse20019SkimmabilityMainscores
mkInlineResponse20019SkimmabilityMainscores =
  InlineResponse20019SkimmabilityMainscores
  { inlineResponse20019SkimmabilityMainscoresTotalPossible = Nothing
  , inlineResponse20019SkimmabilityMainscoresTotal = Nothing
  }

-- ** InlineResponse20019SkimmabilitySubscores
-- | InlineResponse20019SkimmabilitySubscores
data InlineResponse20019SkimmabilitySubscores = InlineResponse20019SkimmabilitySubscores
  { inlineResponse20019SkimmabilitySubscoresBulletPointRatioScore :: !(Maybe [Int]) -- ^ "bullet_point_ratio_score"
  , inlineResponse20019SkimmabilitySubscoresImageScore :: !(Maybe [Int]) -- ^ "image_score"
  , inlineResponse20019SkimmabilitySubscoresHighlightedWordRatioScore :: !(Maybe [Int]) -- ^ "highlighted_word_ratio_score"
  , inlineResponse20019SkimmabilitySubscoresVideoScore :: !(Maybe [Int]) -- ^ "video_score"
  , inlineResponse20019SkimmabilitySubscoresParagraphScore :: !(Maybe [Int]) -- ^ "paragraph_score"
  , inlineResponse20019SkimmabilitySubscoresParagraphHeadlineRatioScore :: !(Maybe [Int]) -- ^ "paragraph_headline_ratio_score"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20019SkimmabilitySubscores
instance A.FromJSON InlineResponse20019SkimmabilitySubscores where
  parseJSON = A.withObject "InlineResponse20019SkimmabilitySubscores" $ \o ->
    InlineResponse20019SkimmabilitySubscores
      <$> (o .:? "bullet_point_ratio_score")
      <*> (o .:? "image_score")
      <*> (o .:? "highlighted_word_ratio_score")
      <*> (o .:? "video_score")
      <*> (o .:? "paragraph_score")
      <*> (o .:? "paragraph_headline_ratio_score")

-- | ToJSON InlineResponse20019SkimmabilitySubscores
instance A.ToJSON InlineResponse20019SkimmabilitySubscores where
  toJSON InlineResponse20019SkimmabilitySubscores {..} =
   _omitNulls
      [ "bullet_point_ratio_score" .= inlineResponse20019SkimmabilitySubscoresBulletPointRatioScore
      , "image_score" .= inlineResponse20019SkimmabilitySubscoresImageScore
      , "highlighted_word_ratio_score" .= inlineResponse20019SkimmabilitySubscoresHighlightedWordRatioScore
      , "video_score" .= inlineResponse20019SkimmabilitySubscoresVideoScore
      , "paragraph_score" .= inlineResponse20019SkimmabilitySubscoresParagraphScore
      , "paragraph_headline_ratio_score" .= inlineResponse20019SkimmabilitySubscoresParagraphHeadlineRatioScore
      ]


-- | Construct a value of type 'InlineResponse20019SkimmabilitySubscores' (by applying it's required fields, if any)
mkInlineResponse20019SkimmabilitySubscores
  :: InlineResponse20019SkimmabilitySubscores
mkInlineResponse20019SkimmabilitySubscores =
  InlineResponse20019SkimmabilitySubscores
  { inlineResponse20019SkimmabilitySubscoresBulletPointRatioScore = Nothing
  , inlineResponse20019SkimmabilitySubscoresImageScore = Nothing
  , inlineResponse20019SkimmabilitySubscoresHighlightedWordRatioScore = Nothing
  , inlineResponse20019SkimmabilitySubscoresVideoScore = Nothing
  , inlineResponse20019SkimmabilitySubscoresParagraphScore = Nothing
  , inlineResponse20019SkimmabilitySubscoresParagraphHeadlineRatioScore = Nothing
  }

-- ** InlineResponse20019Style
-- | InlineResponse20019Style
data InlineResponse20019Style = InlineResponse20019Style
  { inlineResponse20019StyleMainscores :: !(Maybe InlineResponse20019ReadabilityMainscores) -- ^ "mainscores"
  , inlineResponse20019StyleSubscores :: !(Maybe InlineResponse20019StyleSubscores) -- ^ "subscores"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20019Style
instance A.FromJSON InlineResponse20019Style where
  parseJSON = A.withObject "InlineResponse20019Style" $ \o ->
    InlineResponse20019Style
      <$> (o .:? "mainscores")
      <*> (o .:? "subscores")

-- | ToJSON InlineResponse20019Style
instance A.ToJSON InlineResponse20019Style where
  toJSON InlineResponse20019Style {..} =
   _omitNulls
      [ "mainscores" .= inlineResponse20019StyleMainscores
      , "subscores" .= inlineResponse20019StyleSubscores
      ]


-- | Construct a value of type 'InlineResponse20019Style' (by applying it's required fields, if any)
mkInlineResponse20019Style
  :: InlineResponse20019Style
mkInlineResponse20019Style =
  InlineResponse20019Style
  { inlineResponse20019StyleMainscores = Nothing
  , inlineResponse20019StyleSubscores = Nothing
  }

-- ** InlineResponse20019StyleSubscores
-- | InlineResponse20019StyleSubscores
data InlineResponse20019StyleSubscores = InlineResponse20019StyleSubscores
  { inlineResponse20019StyleSubscoresAbbreviationScore :: !(Maybe [Int]) -- ^ "abbreviation_score"
  , inlineResponse20019StyleSubscoresStyleScore :: !(Maybe [Int]) -- ^ "style_score"
  , inlineResponse20019StyleSubscoresSpellingScore :: !(Maybe [Int]) -- ^ "spelling_score"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20019StyleSubscores
instance A.FromJSON InlineResponse20019StyleSubscores where
  parseJSON = A.withObject "InlineResponse20019StyleSubscores" $ \o ->
    InlineResponse20019StyleSubscores
      <$> (o .:? "abbreviation_score")
      <*> (o .:? "style_score")
      <*> (o .:? "spelling_score")

-- | ToJSON InlineResponse20019StyleSubscores
instance A.ToJSON InlineResponse20019StyleSubscores where
  toJSON InlineResponse20019StyleSubscores {..} =
   _omitNulls
      [ "abbreviation_score" .= inlineResponse20019StyleSubscoresAbbreviationScore
      , "style_score" .= inlineResponse20019StyleSubscoresStyleScore
      , "spelling_score" .= inlineResponse20019StyleSubscoresSpellingScore
      ]


-- | Construct a value of type 'InlineResponse20019StyleSubscores' (by applying it's required fields, if any)
mkInlineResponse20019StyleSubscores
  :: InlineResponse20019StyleSubscores
mkInlineResponse20019StyleSubscores =
  InlineResponse20019StyleSubscores
  { inlineResponse20019StyleSubscoresAbbreviationScore = Nothing
  , inlineResponse20019StyleSubscoresStyleScore = Nothing
  , inlineResponse20019StyleSubscoresSpellingScore = Nothing
  }

-- ** InlineResponse2002
-- | InlineResponse2002
data InlineResponse2002 = InlineResponse2002
  { inlineResponse2002Offset :: !(Maybe Int) -- ^ "offset"
  , inlineResponse2002Number :: !(Maybe Int) -- ^ "number"
  , inlineResponse2002Available :: !(Maybe Int) -- ^ "available"
  , inlineResponse2002News :: !(Maybe [InlineResponse2002News]) -- ^ "news"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse2002
instance A.FromJSON InlineResponse2002 where
  parseJSON = A.withObject "InlineResponse2002" $ \o ->
    InlineResponse2002
      <$> (o .:? "offset")
      <*> (o .:? "number")
      <*> (o .:? "available")
      <*> (o .:? "news")

-- | ToJSON InlineResponse2002
instance A.ToJSON InlineResponse2002 where
  toJSON InlineResponse2002 {..} =
   _omitNulls
      [ "offset" .= inlineResponse2002Offset
      , "number" .= inlineResponse2002Number
      , "available" .= inlineResponse2002Available
      , "news" .= inlineResponse2002News
      ]


-- | Construct a value of type 'InlineResponse2002' (by applying it's required fields, if any)
mkInlineResponse2002
  :: InlineResponse2002
mkInlineResponse2002 =
  InlineResponse2002
  { inlineResponse2002Offset = Nothing
  , inlineResponse2002Number = Nothing
  , inlineResponse2002Available = Nothing
  , inlineResponse2002News = Nothing
  }

-- ** InlineResponse20020
-- | InlineResponse20020
data InlineResponse20020 = InlineResponse20020
  { inlineResponse20020Readability :: !(Maybe InlineResponse20019Readability) -- ^ "readability"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20020
instance A.FromJSON InlineResponse20020 where
  parseJSON = A.withObject "InlineResponse20020" $ \o ->
    InlineResponse20020
      <$> (o .:? "readability")

-- | ToJSON InlineResponse20020
instance A.ToJSON InlineResponse20020 where
  toJSON InlineResponse20020 {..} =
   _omitNulls
      [ "readability" .= inlineResponse20020Readability
      ]


-- | Construct a value of type 'InlineResponse20020' (by applying it's required fields, if any)
mkInlineResponse20020
  :: InlineResponse20020
mkInlineResponse20020 =
  InlineResponse20020
  { inlineResponse20020Readability = Nothing
  }

-- ** InlineResponse20021
-- | InlineResponse20021
data InlineResponse20021 = InlineResponse20021
  { inlineResponse20021Dates :: !(Maybe [InlineResponse20021Dates]) -- ^ "dates"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20021
instance A.FromJSON InlineResponse20021 where
  parseJSON = A.withObject "InlineResponse20021" $ \o ->
    InlineResponse20021
      <$> (o .:? "dates")

-- | ToJSON InlineResponse20021
instance A.ToJSON InlineResponse20021 where
  toJSON InlineResponse20021 {..} =
   _omitNulls
      [ "dates" .= inlineResponse20021Dates
      ]


-- | Construct a value of type 'InlineResponse20021' (by applying it's required fields, if any)
mkInlineResponse20021
  :: InlineResponse20021
mkInlineResponse20021 =
  InlineResponse20021
  { inlineResponse20021Dates = Nothing
  }

-- ** InlineResponse20021Dates
-- | InlineResponse20021Dates
data InlineResponse20021Dates = InlineResponse20021Dates
  { inlineResponse20021DatesStartPosition :: !(Maybe Int) -- ^ "start_position"
  , inlineResponse20021DatesDate :: !(Maybe Text) -- ^ "date"
  , inlineResponse20021DatesNormalizedDate :: !(Maybe Double) -- ^ "normalized_date"
  , inlineResponse20021DatesTag :: !(Maybe Text) -- ^ "tag"
  , inlineResponse20021DatesEndPosition :: !(Maybe Int) -- ^ "end_position"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20021Dates
instance A.FromJSON InlineResponse20021Dates where
  parseJSON = A.withObject "InlineResponse20021Dates" $ \o ->
    InlineResponse20021Dates
      <$> (o .:? "start_position")
      <*> (o .:? "date")
      <*> (o .:? "normalized_date")
      <*> (o .:? "tag")
      <*> (o .:? "end_position")

-- | ToJSON InlineResponse20021Dates
instance A.ToJSON InlineResponse20021Dates where
  toJSON InlineResponse20021Dates {..} =
   _omitNulls
      [ "start_position" .= inlineResponse20021DatesStartPosition
      , "date" .= inlineResponse20021DatesDate
      , "normalized_date" .= inlineResponse20021DatesNormalizedDate
      , "tag" .= inlineResponse20021DatesTag
      , "end_position" .= inlineResponse20021DatesEndPosition
      ]


-- | Construct a value of type 'InlineResponse20021Dates' (by applying it's required fields, if any)
mkInlineResponse20021Dates
  :: InlineResponse20021Dates
mkInlineResponse20021Dates =
  InlineResponse20021Dates
  { inlineResponse20021DatesStartPosition = Nothing
  , inlineResponse20021DatesDate = Nothing
  , inlineResponse20021DatesNormalizedDate = Nothing
  , inlineResponse20021DatesTag = Nothing
  , inlineResponse20021DatesEndPosition = Nothing
  }

-- ** InlineResponse20022
-- | InlineResponse20022
data InlineResponse20022 = InlineResponse20022
  { inlineResponse20022Synonyms :: !(Maybe [Text]) -- ^ "synonyms"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20022
instance A.FromJSON InlineResponse20022 where
  parseJSON = A.withObject "InlineResponse20022" $ \o ->
    InlineResponse20022
      <$> (o .:? "synonyms")

-- | ToJSON InlineResponse20022
instance A.ToJSON InlineResponse20022 where
  toJSON InlineResponse20022 {..} =
   _omitNulls
      [ "synonyms" .= inlineResponse20022Synonyms
      ]


-- | Construct a value of type 'InlineResponse20022' (by applying it's required fields, if any)
mkInlineResponse20022
  :: InlineResponse20022
mkInlineResponse20022 =
  InlineResponse20022
  { inlineResponse20022Synonyms = Nothing
  }

-- ** InlineResponse20023
-- | InlineResponse20023
data InlineResponse20023 = InlineResponse20023
  { inlineResponse20023TaggedText :: !(Maybe Text) -- ^ "tagged_text"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20023
instance A.FromJSON InlineResponse20023 where
  parseJSON = A.withObject "InlineResponse20023" $ \o ->
    InlineResponse20023
      <$> (o .:? "tagged_text")

-- | ToJSON InlineResponse20023
instance A.ToJSON InlineResponse20023 where
  toJSON InlineResponse20023 {..} =
   _omitNulls
      [ "tagged_text" .= inlineResponse20023TaggedText
      ]


-- | Construct a value of type 'InlineResponse20023' (by applying it's required fields, if any)
mkInlineResponse20023
  :: InlineResponse20023
mkInlineResponse20023 =
  InlineResponse20023
  { inlineResponse20023TaggedText = Nothing
  }

-- ** InlineResponse20024
-- | InlineResponse20024
data InlineResponse20024 = InlineResponse20024
  { inlineResponse20024Original :: !(Maybe Text) -- ^ "original"
  , inlineResponse20024Stemmed :: !(Maybe Text) -- ^ "stemmed"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20024
instance A.FromJSON InlineResponse20024 where
  parseJSON = A.withObject "InlineResponse20024" $ \o ->
    InlineResponse20024
      <$> (o .:? "original")
      <*> (o .:? "stemmed")

-- | ToJSON InlineResponse20024
instance A.ToJSON InlineResponse20024 where
  toJSON InlineResponse20024 {..} =
   _omitNulls
      [ "original" .= inlineResponse20024Original
      , "stemmed" .= inlineResponse20024Stemmed
      ]


-- | Construct a value of type 'InlineResponse20024' (by applying it's required fields, if any)
mkInlineResponse20024
  :: InlineResponse20024
mkInlineResponse20024 =
  InlineResponse20024
  { inlineResponse20024Original = Nothing
  , inlineResponse20024Stemmed = Nothing
  }

-- ** InlineResponse20025
-- | InlineResponse20025
data InlineResponse20025 = InlineResponse20025
  { inlineResponse20025Original :: !(Maybe Text) -- ^ "original"
  , inlineResponse20025Singular :: !(Maybe Text) -- ^ "singular"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20025
instance A.FromJSON InlineResponse20025 where
  parseJSON = A.withObject "InlineResponse20025" $ \o ->
    InlineResponse20025
      <$> (o .:? "original")
      <*> (o .:? "singular")

-- | ToJSON InlineResponse20025
instance A.ToJSON InlineResponse20025 where
  toJSON InlineResponse20025 {..} =
   _omitNulls
      [ "original" .= inlineResponse20025Original
      , "singular" .= inlineResponse20025Singular
      ]


-- | Construct a value of type 'InlineResponse20025' (by applying it's required fields, if any)
mkInlineResponse20025
  :: InlineResponse20025
mkInlineResponse20025 =
  InlineResponse20025
  { inlineResponse20025Original = Nothing
  , inlineResponse20025Singular = Nothing
  }

-- ** InlineResponse20026
-- | InlineResponse20026
data InlineResponse20026 = InlineResponse20026
  { inlineResponse20026Original :: !(Maybe Text) -- ^ "original"
  , inlineResponse20026Plural :: !(Maybe Text) -- ^ "plural"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20026
instance A.FromJSON InlineResponse20026 where
  parseJSON = A.withObject "InlineResponse20026" $ \o ->
    InlineResponse20026
      <$> (o .:? "original")
      <*> (o .:? "plural")

-- | ToJSON InlineResponse20026
instance A.ToJSON InlineResponse20026 where
  toJSON InlineResponse20026 {..} =
   _omitNulls
      [ "original" .= inlineResponse20026Original
      , "plural" .= inlineResponse20026Plural
      ]


-- | Construct a value of type 'InlineResponse20026' (by applying it's required fields, if any)
mkInlineResponse20026
  :: InlineResponse20026
mkInlineResponse20026 =
  InlineResponse20026
  { inlineResponse20026Original = Nothing
  , inlineResponse20026Plural = Nothing
  }

-- ** InlineResponse20027
-- | InlineResponse20027
data InlineResponse20027 = InlineResponse20027
  { inlineResponse20027Entities :: !(Maybe [InlineResponse20027Entities]) -- ^ "entities"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20027
instance A.FromJSON InlineResponse20027 where
  parseJSON = A.withObject "InlineResponse20027" $ \o ->
    InlineResponse20027
      <$> (o .:? "entities")

-- | ToJSON InlineResponse20027
instance A.ToJSON InlineResponse20027 where
  toJSON InlineResponse20027 {..} =
   _omitNulls
      [ "entities" .= inlineResponse20027Entities
      ]


-- | Construct a value of type 'InlineResponse20027' (by applying it's required fields, if any)
mkInlineResponse20027
  :: InlineResponse20027
mkInlineResponse20027 =
  InlineResponse20027
  { inlineResponse20027Entities = Nothing
  }

-- ** InlineResponse20027Entities
-- | InlineResponse20027Entities
data InlineResponse20027Entities = InlineResponse20027Entities
  { inlineResponse20027EntitiesStartPosition :: !(Maybe Int) -- ^ "start_position"
  , inlineResponse20027EntitiesImage :: !(Maybe Text) -- ^ "image"
  , inlineResponse20027EntitiesType :: !(Maybe Text) -- ^ "type"
  , inlineResponse20027EntitiesValue :: !(Maybe Text) -- ^ "value"
  , inlineResponse20027EntitiesEndPosition :: !(Maybe Int) -- ^ "end_position"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20027Entities
instance A.FromJSON InlineResponse20027Entities where
  parseJSON = A.withObject "InlineResponse20027Entities" $ \o ->
    InlineResponse20027Entities
      <$> (o .:? "start_position")
      <*> (o .:? "image")
      <*> (o .:? "type")
      <*> (o .:? "value")
      <*> (o .:? "end_position")

-- | ToJSON InlineResponse20027Entities
instance A.ToJSON InlineResponse20027Entities where
  toJSON InlineResponse20027Entities {..} =
   _omitNulls
      [ "start_position" .= inlineResponse20027EntitiesStartPosition
      , "image" .= inlineResponse20027EntitiesImage
      , "type" .= inlineResponse20027EntitiesType
      , "value" .= inlineResponse20027EntitiesValue
      , "end_position" .= inlineResponse20027EntitiesEndPosition
      ]


-- | Construct a value of type 'InlineResponse20027Entities' (by applying it's required fields, if any)
mkInlineResponse20027Entities
  :: InlineResponse20027Entities
mkInlineResponse20027Entities =
  InlineResponse20027Entities
  { inlineResponse20027EntitiesStartPosition = Nothing
  , inlineResponse20027EntitiesImage = Nothing
  , inlineResponse20027EntitiesType = Nothing
  , inlineResponse20027EntitiesValue = Nothing
  , inlineResponse20027EntitiesEndPosition = Nothing
  }

-- ** InlineResponse20028
-- | InlineResponse20028
data InlineResponse20028 = InlineResponse20028
  { inlineResponse20028Images :: !(Maybe [InlineResponse20028Images]) -- ^ "images"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20028
instance A.FromJSON InlineResponse20028 where
  parseJSON = A.withObject "InlineResponse20028" $ \o ->
    InlineResponse20028
      <$> (o .:? "images")

-- | ToJSON InlineResponse20028
instance A.ToJSON InlineResponse20028 where
  toJSON InlineResponse20028 {..} =
   _omitNulls
      [ "images" .= inlineResponse20028Images
      ]


-- | Construct a value of type 'InlineResponse20028' (by applying it's required fields, if any)
mkInlineResponse20028
  :: InlineResponse20028
mkInlineResponse20028 =
  InlineResponse20028
  { inlineResponse20028Images = Nothing
  }

-- ** InlineResponse20028Images
-- | InlineResponse20028Images
data InlineResponse20028Images = InlineResponse20028Images
  { inlineResponse20028ImagesWidth :: !(Maybe Int) -- ^ "width"
  , inlineResponse20028ImagesLicense :: !(Maybe InlineResponse20028License) -- ^ "license"
  , inlineResponse20028ImagesThumbnail :: !(Maybe Text) -- ^ "thumbnail"
  , inlineResponse20028ImagesId :: !(Maybe Text) -- ^ "id"
  , inlineResponse20028ImagesUrl :: !(Maybe Text) -- ^ "url"
  , inlineResponse20028ImagesHeight :: !(Maybe Int) -- ^ "height"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20028Images
instance A.FromJSON InlineResponse20028Images where
  parseJSON = A.withObject "InlineResponse20028Images" $ \o ->
    InlineResponse20028Images
      <$> (o .:? "width")
      <*> (o .:? "license")
      <*> (o .:? "thumbnail")
      <*> (o .:? "id")
      <*> (o .:? "url")
      <*> (o .:? "height")

-- | ToJSON InlineResponse20028Images
instance A.ToJSON InlineResponse20028Images where
  toJSON InlineResponse20028Images {..} =
   _omitNulls
      [ "width" .= inlineResponse20028ImagesWidth
      , "license" .= inlineResponse20028ImagesLicense
      , "thumbnail" .= inlineResponse20028ImagesThumbnail
      , "id" .= inlineResponse20028ImagesId
      , "url" .= inlineResponse20028ImagesUrl
      , "height" .= inlineResponse20028ImagesHeight
      ]


-- | Construct a value of type 'InlineResponse20028Images' (by applying it's required fields, if any)
mkInlineResponse20028Images
  :: InlineResponse20028Images
mkInlineResponse20028Images =
  InlineResponse20028Images
  { inlineResponse20028ImagesWidth = Nothing
  , inlineResponse20028ImagesLicense = Nothing
  , inlineResponse20028ImagesThumbnail = Nothing
  , inlineResponse20028ImagesId = Nothing
  , inlineResponse20028ImagesUrl = Nothing
  , inlineResponse20028ImagesHeight = Nothing
  }

-- ** InlineResponse20028License
-- | InlineResponse20028License
data InlineResponse20028License = InlineResponse20028License
  { inlineResponse20028LicenseName :: !(Maybe Text) -- ^ "name"
  , inlineResponse20028LicenseLink :: !(Maybe Text) -- ^ "link"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20028License
instance A.FromJSON InlineResponse20028License where
  parseJSON = A.withObject "InlineResponse20028License" $ \o ->
    InlineResponse20028License
      <$> (o .:? "name")
      <*> (o .:? "link")

-- | ToJSON InlineResponse20028License
instance A.ToJSON InlineResponse20028License where
  toJSON InlineResponse20028License {..} =
   _omitNulls
      [ "name" .= inlineResponse20028LicenseName
      , "link" .= inlineResponse20028LicenseLink
      ]


-- | Construct a value of type 'InlineResponse20028License' (by applying it's required fields, if any)
mkInlineResponse20028License
  :: InlineResponse20028License
mkInlineResponse20028License =
  InlineResponse20028License
  { inlineResponse20028LicenseName = Nothing
  , inlineResponse20028LicenseLink = Nothing
  }

-- ** InlineResponse20029
-- | InlineResponse20029
data InlineResponse20029 = InlineResponse20029
  { inlineResponse20029SpecificColor :: !(Maybe Text) -- ^ "specific_color"
  , inlineResponse20029MainColor :: !(Maybe Text) -- ^ "main_color"
  , inlineResponse20029HexCode :: !(Maybe Text) -- ^ "hex_code"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20029
instance A.FromJSON InlineResponse20029 where
  parseJSON = A.withObject "InlineResponse20029" $ \o ->
    InlineResponse20029
      <$> (o .:? "specific_color")
      <*> (o .:? "main_color")
      <*> (o .:? "hex_code")

-- | ToJSON InlineResponse20029
instance A.ToJSON InlineResponse20029 where
  toJSON InlineResponse20029 {..} =
   _omitNulls
      [ "specific_color" .= inlineResponse20029SpecificColor
      , "main_color" .= inlineResponse20029MainColor
      , "hex_code" .= inlineResponse20029HexCode
      ]


-- | Construct a value of type 'InlineResponse20029' (by applying it's required fields, if any)
mkInlineResponse20029
  :: InlineResponse20029
mkInlineResponse20029 =
  InlineResponse20029
  { inlineResponse20029SpecificColor = Nothing
  , inlineResponse20029MainColor = Nothing
  , inlineResponse20029HexCode = Nothing
  }

-- ** InlineResponse2002News
-- | InlineResponse2002News
data InlineResponse2002News = InlineResponse2002News
  { inlineResponse2002NewsSummary :: !(Maybe Text) -- ^ "summary"
  , inlineResponse2002NewsImage :: !(Maybe Text) -- ^ "image"
  , inlineResponse2002NewsSentiment :: !(Maybe Double) -- ^ "sentiment"
  , inlineResponse2002NewsSourceCountry :: !(Maybe Text) -- ^ "source_country"
  , inlineResponse2002NewsLanguage :: !(Maybe Text) -- ^ "language"
  , inlineResponse2002NewsId :: !(Maybe Int) -- ^ "id"
  , inlineResponse2002NewsText :: !(Maybe Text) -- ^ "text"
  , inlineResponse2002NewsTitle :: !(Maybe Text) -- ^ "title"
  , inlineResponse2002NewsPublishDate :: !(Maybe Text) -- ^ "publish_date"
  , inlineResponse2002NewsUrl :: !(Maybe Text) -- ^ "url"
  , inlineResponse2002NewsAuthors :: !(Maybe [Text]) -- ^ "authors"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse2002News
instance A.FromJSON InlineResponse2002News where
  parseJSON = A.withObject "InlineResponse2002News" $ \o ->
    InlineResponse2002News
      <$> (o .:? "summary")
      <*> (o .:? "image")
      <*> (o .:? "sentiment")
      <*> (o .:? "source_country")
      <*> (o .:? "language")
      <*> (o .:? "id")
      <*> (o .:? "text")
      <*> (o .:? "title")
      <*> (o .:? "publish_date")
      <*> (o .:? "url")
      <*> (o .:? "authors")

-- | ToJSON InlineResponse2002News
instance A.ToJSON InlineResponse2002News where
  toJSON InlineResponse2002News {..} =
   _omitNulls
      [ "summary" .= inlineResponse2002NewsSummary
      , "image" .= inlineResponse2002NewsImage
      , "sentiment" .= inlineResponse2002NewsSentiment
      , "source_country" .= inlineResponse2002NewsSourceCountry
      , "language" .= inlineResponse2002NewsLanguage
      , "id" .= inlineResponse2002NewsId
      , "text" .= inlineResponse2002NewsText
      , "title" .= inlineResponse2002NewsTitle
      , "publish_date" .= inlineResponse2002NewsPublishDate
      , "url" .= inlineResponse2002NewsUrl
      , "authors" .= inlineResponse2002NewsAuthors
      ]


-- | Construct a value of type 'InlineResponse2002News' (by applying it's required fields, if any)
mkInlineResponse2002News
  :: InlineResponse2002News
mkInlineResponse2002News =
  InlineResponse2002News
  { inlineResponse2002NewsSummary = Nothing
  , inlineResponse2002NewsImage = Nothing
  , inlineResponse2002NewsSentiment = Nothing
  , inlineResponse2002NewsSourceCountry = Nothing
  , inlineResponse2002NewsLanguage = Nothing
  , inlineResponse2002NewsId = Nothing
  , inlineResponse2002NewsText = Nothing
  , inlineResponse2002NewsTitle = Nothing
  , inlineResponse2002NewsPublishDate = Nothing
  , inlineResponse2002NewsUrl = Nothing
  , inlineResponse2002NewsAuthors = Nothing
  }

-- ** InlineResponse2003
-- | InlineResponse2003
data InlineResponse2003 = InlineResponse2003
  { inlineResponse2003Title :: !(Maybe Text) -- ^ "title"
  , inlineResponse2003Text :: !(Maybe Text) -- ^ "text"
  , inlineResponse2003Url :: !(Maybe Text) -- ^ "url"
  , inlineResponse2003Image :: !(Maybe Text) -- ^ "image"
  , inlineResponse2003PublishDate :: !(Maybe Text) -- ^ "publish_date"
  , inlineResponse2003Author :: !(Maybe Text) -- ^ "author"
  , inlineResponse2003Language :: !(Maybe Text) -- ^ "language"
  , inlineResponse2003SourceCountry :: !(Maybe Text) -- ^ "source_country"
  , inlineResponse2003Sentiment :: !(Maybe Double) -- ^ "sentiment"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse2003
instance A.FromJSON InlineResponse2003 where
  parseJSON = A.withObject "InlineResponse2003" $ \o ->
    InlineResponse2003
      <$> (o .:? "title")
      <*> (o .:? "text")
      <*> (o .:? "url")
      <*> (o .:? "image")
      <*> (o .:? "publish_date")
      <*> (o .:? "author")
      <*> (o .:? "language")
      <*> (o .:? "source_country")
      <*> (o .:? "sentiment")

-- | ToJSON InlineResponse2003
instance A.ToJSON InlineResponse2003 where
  toJSON InlineResponse2003 {..} =
   _omitNulls
      [ "title" .= inlineResponse2003Title
      , "text" .= inlineResponse2003Text
      , "url" .= inlineResponse2003Url
      , "image" .= inlineResponse2003Image
      , "publish_date" .= inlineResponse2003PublishDate
      , "author" .= inlineResponse2003Author
      , "language" .= inlineResponse2003Language
      , "source_country" .= inlineResponse2003SourceCountry
      , "sentiment" .= inlineResponse2003Sentiment
      ]


-- | Construct a value of type 'InlineResponse2003' (by applying it's required fields, if any)
mkInlineResponse2003
  :: InlineResponse2003
mkInlineResponse2003 =
  InlineResponse2003
  { inlineResponse2003Title = Nothing
  , inlineResponse2003Text = Nothing
  , inlineResponse2003Url = Nothing
  , inlineResponse2003Image = Nothing
  , inlineResponse2003PublishDate = Nothing
  , inlineResponse2003Author = Nothing
  , inlineResponse2003Language = Nothing
  , inlineResponse2003SourceCountry = Nothing
  , inlineResponse2003Sentiment = Nothing
  }

-- ** InlineResponse20030
-- | InlineResponse20030
data InlineResponse20030 = InlineResponse20030
  { inlineResponse20030TargetAmount :: !(Maybe Double) -- ^ "target_amount"
  , inlineResponse20030TargetUnit :: !(Maybe Text) -- ^ "target_unit"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20030
instance A.FromJSON InlineResponse20030 where
  parseJSON = A.withObject "InlineResponse20030" $ \o ->
    InlineResponse20030
      <$> (o .:? "target_amount")
      <*> (o .:? "target_unit")

-- | ToJSON InlineResponse20030
instance A.ToJSON InlineResponse20030 where
  toJSON InlineResponse20030 {..} =
   _omitNulls
      [ "target_amount" .= inlineResponse20030TargetAmount
      , "target_unit" .= inlineResponse20030TargetUnit
      ]


-- | Construct a value of type 'InlineResponse20030' (by applying it's required fields, if any)
mkInlineResponse20030
  :: InlineResponse20030
mkInlineResponse20030 =
  InlineResponse20030
  { inlineResponse20030TargetAmount = Nothing
  , inlineResponse20030TargetUnit = Nothing
  }

-- ** InlineResponse20031
-- | InlineResponse20031
data InlineResponse20031 = InlineResponse20031
  { inlineResponse20031Value :: !(Maybe Text) -- ^ "value"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20031
instance A.FromJSON InlineResponse20031 where
  parseJSON = A.withObject "InlineResponse20031" $ \o ->
    InlineResponse20031
      <$> (o .:? "value")

-- | ToJSON InlineResponse20031
instance A.ToJSON InlineResponse20031 where
  toJSON InlineResponse20031 {..} =
   _omitNulls
      [ "value" .= inlineResponse20031Value
      ]


-- | Construct a value of type 'InlineResponse20031' (by applying it's required fields, if any)
mkInlineResponse20031
  :: InlineResponse20031
mkInlineResponse20031 =
  InlineResponse20031
  { inlineResponse20031Value = Nothing
  }

-- ** InlineResponse20032
-- | InlineResponse20032
data InlineResponse20032 = InlineResponse20032
  { inlineResponse20032Status :: !(Maybe Text) -- ^ "status"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20032
instance A.FromJSON InlineResponse20032 where
  parseJSON = A.withObject "InlineResponse20032" $ \o ->
    InlineResponse20032
      <$> (o .:? "status")

-- | ToJSON InlineResponse20032
instance A.ToJSON InlineResponse20032 where
  toJSON InlineResponse20032 {..} =
   _omitNulls
      [ "status" .= inlineResponse20032Status
      ]


-- | Construct a value of type 'InlineResponse20032' (by applying it's required fields, if any)
mkInlineResponse20032
  :: InlineResponse20032
mkInlineResponse20032 =
  InlineResponse20032
  { inlineResponse20032Status = Nothing
  }

-- ** InlineResponse2004
-- | InlineResponse2004
data InlineResponse2004 = InlineResponse2004
  { inlineResponse2004Jokes :: !(Maybe [InlineResponse2004Jokes]) -- ^ "jokes"
  , inlineResponse2004Available :: !(Maybe Int) -- ^ "available"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse2004
instance A.FromJSON InlineResponse2004 where
  parseJSON = A.withObject "InlineResponse2004" $ \o ->
    InlineResponse2004
      <$> (o .:? "jokes")
      <*> (o .:? "available")

-- | ToJSON InlineResponse2004
instance A.ToJSON InlineResponse2004 where
  toJSON InlineResponse2004 {..} =
   _omitNulls
      [ "jokes" .= inlineResponse2004Jokes
      , "available" .= inlineResponse2004Available
      ]


-- | Construct a value of type 'InlineResponse2004' (by applying it's required fields, if any)
mkInlineResponse2004
  :: InlineResponse2004
mkInlineResponse2004 =
  InlineResponse2004
  { inlineResponse2004Jokes = Nothing
  , inlineResponse2004Available = Nothing
  }

-- ** InlineResponse2004Jokes
-- | InlineResponse2004Jokes
data InlineResponse2004Jokes = InlineResponse2004Jokes
  { inlineResponse2004JokesJoke :: !(Maybe Text) -- ^ "joke"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse2004Jokes
instance A.FromJSON InlineResponse2004Jokes where
  parseJSON = A.withObject "InlineResponse2004Jokes" $ \o ->
    InlineResponse2004Jokes
      <$> (o .:? "joke")

-- | ToJSON InlineResponse2004Jokes
instance A.ToJSON InlineResponse2004Jokes where
  toJSON InlineResponse2004Jokes {..} =
   _omitNulls
      [ "joke" .= inlineResponse2004JokesJoke
      ]


-- | Construct a value of type 'InlineResponse2004Jokes' (by applying it's required fields, if any)
mkInlineResponse2004Jokes
  :: InlineResponse2004Jokes
mkInlineResponse2004Jokes =
  InlineResponse2004Jokes
  { inlineResponse2004JokesJoke = Nothing
  }

-- ** InlineResponse2005
-- | InlineResponse2005
data InlineResponse2005 = InlineResponse2005
  { inlineResponse2005Memes :: !(Maybe [InlineResponse2005Memes]) -- ^ "memes"
  , inlineResponse2005Available :: !(Maybe Int) -- ^ "available"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse2005
instance A.FromJSON InlineResponse2005 where
  parseJSON = A.withObject "InlineResponse2005" $ \o ->
    InlineResponse2005
      <$> (o .:? "memes")
      <*> (o .:? "available")

-- | ToJSON InlineResponse2005
instance A.ToJSON InlineResponse2005 where
  toJSON InlineResponse2005 {..} =
   _omitNulls
      [ "memes" .= inlineResponse2005Memes
      , "available" .= inlineResponse2005Available
      ]


-- | Construct a value of type 'InlineResponse2005' (by applying it's required fields, if any)
mkInlineResponse2005
  :: InlineResponse2005
mkInlineResponse2005 =
  InlineResponse2005
  { inlineResponse2005Memes = Nothing
  , inlineResponse2005Available = Nothing
  }

-- ** InlineResponse2005Memes
-- | InlineResponse2005Memes
data InlineResponse2005Memes = InlineResponse2005Memes
  { inlineResponse2005MemesType :: !(Maybe Text) -- ^ "type"
  , inlineResponse2005MemesDescription :: !(Maybe Text) -- ^ "description"
  , inlineResponse2005MemesUrl :: !(Maybe Text) -- ^ "url"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse2005Memes
instance A.FromJSON InlineResponse2005Memes where
  parseJSON = A.withObject "InlineResponse2005Memes" $ \o ->
    InlineResponse2005Memes
      <$> (o .:? "type")
      <*> (o .:? "description")
      <*> (o .:? "url")

-- | ToJSON InlineResponse2005Memes
instance A.ToJSON InlineResponse2005Memes where
  toJSON InlineResponse2005Memes {..} =
   _omitNulls
      [ "type" .= inlineResponse2005MemesType
      , "description" .= inlineResponse2005MemesDescription
      , "url" .= inlineResponse2005MemesUrl
      ]


-- | Construct a value of type 'InlineResponse2005Memes' (by applying it's required fields, if any)
mkInlineResponse2005Memes
  :: InlineResponse2005Memes
mkInlineResponse2005Memes =
  InlineResponse2005Memes
  { inlineResponse2005MemesType = Nothing
  , inlineResponse2005MemesDescription = Nothing
  , inlineResponse2005MemesUrl = Nothing
  }

-- ** InlineResponse2006
-- | InlineResponse2006
data InlineResponse2006 = InlineResponse2006
  { inlineResponse2006Description :: !(Maybe Text) -- ^ "description"
  , inlineResponse2006Url :: !(Maybe Text) -- ^ "url"
  , inlineResponse2006Type :: !(Maybe Text) -- ^ "type"
  , inlineResponse2006Width :: !(Maybe Int) -- ^ "width"
  , inlineResponse2006Height :: !(Maybe Int) -- ^ "height"
  , inlineResponse2006Ratio :: !(Maybe Double) -- ^ "ratio"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse2006
instance A.FromJSON InlineResponse2006 where
  parseJSON = A.withObject "InlineResponse2006" $ \o ->
    InlineResponse2006
      <$> (o .:? "description")
      <*> (o .:? "url")
      <*> (o .:? "type")
      <*> (o .:? "width")
      <*> (o .:? "height")
      <*> (o .:? "ratio")

-- | ToJSON InlineResponse2006
instance A.ToJSON InlineResponse2006 where
  toJSON InlineResponse2006 {..} =
   _omitNulls
      [ "description" .= inlineResponse2006Description
      , "url" .= inlineResponse2006Url
      , "type" .= inlineResponse2006Type
      , "width" .= inlineResponse2006Width
      , "height" .= inlineResponse2006Height
      , "ratio" .= inlineResponse2006Ratio
      ]


-- | Construct a value of type 'InlineResponse2006' (by applying it's required fields, if any)
mkInlineResponse2006
  :: InlineResponse2006
mkInlineResponse2006 =
  InlineResponse2006
  { inlineResponse2006Description = Nothing
  , inlineResponse2006Url = Nothing
  , inlineResponse2006Type = Nothing
  , inlineResponse2006Width = Nothing
  , inlineResponse2006Height = Nothing
  , inlineResponse2006Ratio = Nothing
  }

-- ** InlineResponse2007
-- | InlineResponse2007
data InlineResponse2007 = InlineResponse2007
  { inlineResponse2007Images :: !(Maybe [InlineResponse2007Images]) -- ^ "images"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse2007
instance A.FromJSON InlineResponse2007 where
  parseJSON = A.withObject "InlineResponse2007" $ \o ->
    InlineResponse2007
      <$> (o .:? "images")

-- | ToJSON InlineResponse2007
instance A.ToJSON InlineResponse2007 where
  toJSON InlineResponse2007 {..} =
   _omitNulls
      [ "images" .= inlineResponse2007Images
      ]


-- | Construct a value of type 'InlineResponse2007' (by applying it's required fields, if any)
mkInlineResponse2007
  :: InlineResponse2007
mkInlineResponse2007 =
  InlineResponse2007
  { inlineResponse2007Images = Nothing
  }

-- ** InlineResponse2007Images
-- | InlineResponse2007Images
data InlineResponse2007Images = InlineResponse2007Images
  { inlineResponse2007ImagesWidth :: !(Maybe Int) -- ^ "width"
  , inlineResponse2007ImagesUrl :: !(Maybe Text) -- ^ "url"
  , inlineResponse2007ImagesHeight :: !(Maybe Int) -- ^ "height"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse2007Images
instance A.FromJSON InlineResponse2007Images where
  parseJSON = A.withObject "InlineResponse2007Images" $ \o ->
    InlineResponse2007Images
      <$> (o .:? "width")
      <*> (o .:? "url")
      <*> (o .:? "height")

-- | ToJSON InlineResponse2007Images
instance A.ToJSON InlineResponse2007Images where
  toJSON InlineResponse2007Images {..} =
   _omitNulls
      [ "width" .= inlineResponse2007ImagesWidth
      , "url" .= inlineResponse2007ImagesUrl
      , "height" .= inlineResponse2007ImagesHeight
      ]


-- | Construct a value of type 'InlineResponse2007Images' (by applying it's required fields, if any)
mkInlineResponse2007Images
  :: InlineResponse2007Images
mkInlineResponse2007Images =
  InlineResponse2007Images
  { inlineResponse2007ImagesWidth = Nothing
  , inlineResponse2007ImagesUrl = Nothing
  , inlineResponse2007ImagesHeight = Nothing
  }

-- ** InlineResponse2008
-- | InlineResponse2008
data InlineResponse2008 = InlineResponse2008
  { inlineResponse2008Word :: !(Maybe Text) -- ^ "word"
  , inlineResponse2008Rating :: !(Maybe Double) -- ^ "rating"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse2008
instance A.FromJSON InlineResponse2008 where
  parseJSON = A.withObject "InlineResponse2008" $ \o ->
    InlineResponse2008
      <$> (o .:? "word")
      <*> (o .:? "rating")

-- | ToJSON InlineResponse2008
instance A.ToJSON InlineResponse2008 where
  toJSON InlineResponse2008 {..} =
   _omitNulls
      [ "word" .= inlineResponse2008Word
      , "rating" .= inlineResponse2008Rating
      ]


-- | Construct a value of type 'InlineResponse2008' (by applying it's required fields, if any)
mkInlineResponse2008
  :: InlineResponse2008
mkInlineResponse2008 =
  InlineResponse2008
  { inlineResponse2008Word = Nothing
  , inlineResponse2008Rating = Nothing
  }

-- ** InlineResponse2009
-- | InlineResponse2009
data InlineResponse2009 = InlineResponse2009
  { inlineResponse2009Trivia :: !(Maybe Text) -- ^ "trivia"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse2009
instance A.FromJSON InlineResponse2009 where
  parseJSON = A.withObject "InlineResponse2009" $ \o ->
    InlineResponse2009
      <$> (o .:? "trivia")

-- | ToJSON InlineResponse2009
instance A.ToJSON InlineResponse2009 where
  toJSON InlineResponse2009 {..} =
   _omitNulls
      [ "trivia" .= inlineResponse2009Trivia
      ]


-- | Construct a value of type 'InlineResponse2009' (by applying it's required fields, if any)
mkInlineResponse2009
  :: InlineResponse2009
mkInlineResponse2009 =
  InlineResponse2009
  { inlineResponse2009Trivia = Nothing
  }

-- ** InlineResponse200Books
-- | InlineResponse200Books
data InlineResponse200Books = InlineResponse200Books
  { inlineResponse200BooksTitle :: !(Maybe Text) -- ^ "title"
  , inlineResponse200BooksImage :: !(Maybe Text) -- ^ "image"
  , inlineResponse200BooksId :: !(Maybe Int) -- ^ "id"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse200Books
instance A.FromJSON InlineResponse200Books where
  parseJSON = A.withObject "InlineResponse200Books" $ \o ->
    InlineResponse200Books
      <$> (o .:? "title")
      <*> (o .:? "image")
      <*> (o .:? "id")

-- | ToJSON InlineResponse200Books
instance A.ToJSON InlineResponse200Books where
  toJSON InlineResponse200Books {..} =
   _omitNulls
      [ "title" .= inlineResponse200BooksTitle
      , "image" .= inlineResponse200BooksImage
      , "id" .= inlineResponse200BooksId
      ]


-- | Construct a value of type 'InlineResponse200Books' (by applying it's required fields, if any)
mkInlineResponse200Books
  :: InlineResponse200Books
mkInlineResponse200Books =
  InlineResponse200Books
  { inlineResponse200BooksTitle = Nothing
  , inlineResponse200BooksImage = Nothing
  , inlineResponse200BooksId = Nothing
  }




-- * Auth Methods

-- ** AuthApiKeyApiKey
data AuthApiKeyApiKey =
  AuthApiKeyApiKey Text -- ^ secret
  deriving (P.Eq, P.Show, P.Typeable)

instance AuthMethod AuthApiKeyApiKey where
  applyAuthMethod _ a@(AuthApiKeyApiKey secret) req =
    P.pure $
    if (P.typeOf a `P.elem` rAuthTypes req)
      then req `setQuery` toQuery ("api-key", Just secret)
           & L.over rAuthTypesL (P.filter (/= P.typeOf a))
      else req

-- ** AuthApiKeyHeaderApiKey
data AuthApiKeyHeaderApiKey =
  AuthApiKeyHeaderApiKey Text -- ^ secret
  deriving (P.Eq, P.Show, P.Typeable)

instance AuthMethod AuthApiKeyHeaderApiKey where
  applyAuthMethod _ a@(AuthApiKeyHeaderApiKey secret) req =
    P.pure $
    if (P.typeOf a `P.elem` rAuthTypes req)
      then req `setHeader` toHeader ("x-api-key", secret)
           & L.over rAuthTypesL (P.filter (/= P.typeOf a))
      else req


