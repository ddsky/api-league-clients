{-
   API League

   API League is a Hub for World Class APIs.

   OpenAPI Version: 3.0.0
   API League API version: 1.6.3
   Contact: mail@apileague.com
   Generated by OpenAPI Generator (https://openapi-generator.tech)
-}

{-|
Module : APILeague.Model
-}

{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveFoldable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE DeriveTraversable #-}
{-# LANGUAGE DuplicateRecordFields #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE NamedFieldPuns #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE TupleSections #-}
{-# LANGUAGE TypeFamilies #-}
{-# OPTIONS_GHC -fno-warn-unused-matches -fno-warn-unused-binds -fno-warn-unused-imports #-}

module APILeague.Model where

import APILeague.Core
import APILeague.MimeTypes

import Data.Aeson ((.:),(.:!),(.:?),(.=))

import qualified Control.Arrow as P (left)
import qualified Data.Aeson as A
import qualified Data.ByteString as B
import qualified Data.ByteString.Base64 as B64
import qualified Data.ByteString.Char8 as BC
import qualified Data.ByteString.Lazy as BL
import qualified Data.Data as P (Typeable, TypeRep, typeOf, typeRep)
import qualified Data.Foldable as P
import qualified Data.HashMap.Lazy as HM
import qualified Data.Map as Map
import qualified Data.Maybe as P
import qualified Data.Set as Set
import qualified Data.Text as T
import qualified Data.Text.Encoding as T
import qualified Data.Time as TI
import qualified Lens.Micro as L
import qualified Web.FormUrlEncoded as WH
import qualified Web.HttpApiData as WH

import Control.Applicative ((<|>))
import Control.Applicative (Alternative)
import Data.Function ((&))
import Data.Monoid ((<>))
import Data.Text (Text)
import Prelude (($),(/=),(.),(<$>),(<*>),(>>=),(=<<),Maybe(..),Bool(..),Char,Double,FilePath,Float,Int,Integer,String,fmap,undefined,mempty,maybe,pure,Monad,Applicative,Functor)

import qualified Prelude as P



-- * Parameter newtypes


-- ** AddRecipeInformation
newtype AddRecipeInformation = AddRecipeInformation { unAddRecipeInformation :: Bool } deriving (P.Eq, P.Show)

-- ** AddWinePairing
newtype AddWinePairing = AddWinePairing { unAddWinePairing :: Bool } deriving (P.Eq, P.Show)

-- ** Analyze
newtype Analyze = Analyze { unAnalyze :: Bool } deriving (P.Eq, P.Show)

-- ** Authors
newtype Authors = Authors { unAuthors :: Text } deriving (P.Eq, P.Show)

-- ** Budget
newtype Budget = Budget { unBudget :: Double } deriving (P.Eq, P.Show)

-- ** Categories
newtype Categories = Categories { unCategories :: Text } deriving (P.Eq, P.Show)

-- ** Crop
newtype Crop = Crop { unCrop :: Bool } deriving (P.Eq, P.Show)

-- ** Cuisine
newtype Cuisine = Cuisine { unCuisine :: Text } deriving (P.Eq, P.Show)

-- ** Cuisines
newtype Cuisines = Cuisines { unCuisines :: Text } deriving (P.Eq, P.Show)

-- ** Diet
newtype Diet = Diet { unDiet :: Text } deriving (P.Eq, P.Show)

-- ** Difficulty
newtype Difficulty = Difficulty { unDifficulty :: Text } deriving (P.Eq, P.Show)

-- ** Distance
newtype Distance = Distance { unDistance :: Int } deriving (P.Eq, P.Show)

-- ** Domain
newtype Domain = Domain { unDomain :: Text } deriving (P.Eq, P.Show)

-- ** EarliestPublishDate
newtype EarliestPublishDate = EarliestPublishDate { unEarliestPublishDate :: Text } deriving (P.Eq, P.Show)

-- ** EarliestPublishYear
newtype EarliestPublishYear = EarliestPublishYear { unEarliestPublishYear :: Int } deriving (P.Eq, P.Show)

-- ** Email
newtype Email = Email { unEmail :: Text } deriving (P.Eq, P.Show)

-- ** Entities
newtype Entities = Entities { unEntities :: Text } deriving (P.Eq, P.Show)

-- ** Equipment
newtype Equipment = Equipment { unEquipment :: Text } deriving (P.Eq, P.Show)

-- ** ExcludeCuisines
newtype ExcludeCuisines = ExcludeCuisines { unExcludeCuisines :: Text } deriving (P.Eq, P.Show)

-- ** ExcludeIngredients
newtype ExcludeIngredients = ExcludeIngredients { unExcludeIngredients :: Text } deriving (P.Eq, P.Show)

-- ** ExcludeTags
newtype ExcludeTags = ExcludeTags { unExcludeTags :: Text } deriving (P.Eq, P.Show)

-- ** FillIngredients
newtype FillIngredients = FillIngredients { unFillIngredients :: Bool } deriving (P.Eq, P.Show)

-- ** Flavors
newtype Flavors = Flavors { unFlavors :: Text } deriving (P.Eq, P.Show)

-- ** FoodName
newtype FoodName = FoodName { unFoodName :: Text } deriving (P.Eq, P.Show)

-- ** Genres
newtype Genres = Genres { unGenres :: Text } deriving (P.Eq, P.Show)

-- ** GlassTypes
newtype GlassTypes = GlassTypes { unGlassTypes :: Text } deriving (P.Eq, P.Show)

-- ** GroupResults
newtype GroupResults = GroupResults { unGroupResults :: Bool } deriving (P.Eq, P.Show)

-- ** HeadlinesOnly
newtype HeadlinesOnly = HeadlinesOnly { unHeadlinesOnly :: Bool } deriving (P.Eq, P.Show)

-- ** Height
newtype Height = Height { unHeight :: Int } deriving (P.Eq, P.Show)

-- ** Id
newtype Id = Id { unId :: Int } deriving (P.Eq, P.Show)

-- ** IncludeIngredients
newtype IncludeIngredients = IncludeIngredients { unIncludeIngredients :: Text } deriving (P.Eq, P.Show)

-- ** IncludeTags
newtype IncludeTags = IncludeTags { unIncludeTags :: Text } deriving (P.Eq, P.Show)

-- ** Ingredients
newtype Ingredients = Ingredients { unIngredients :: Text } deriving (P.Eq, P.Show)

-- ** Intolerances
newtype Intolerances = Intolerances { unIntolerances :: Text } deriving (P.Eq, P.Show)

-- ** IsOpen
newtype IsOpen = IsOpen { unIsOpen :: Bool } deriving (P.Eq, P.Show)

-- ** Isbn
newtype Isbn = Isbn { unIsbn :: Text } deriving (P.Eq, P.Show)

-- ** Key
newtype Key = Key { unKey :: Text } deriving (P.Eq, P.Show)

-- ** Keywords
newtype Keywords = Keywords { unKeywords :: Text } deriving (P.Eq, P.Show)

-- ** KeywordsInImage
newtype KeywordsInImage = KeywordsInImage { unKeywordsInImage :: Bool } deriving (P.Eq, P.Show)

-- ** Language
newtype Language = Language { unLanguage :: Text } deriving (P.Eq, P.Show)

-- ** Lat
newtype Lat = Lat { unLat :: Double } deriving (P.Eq, P.Show)

-- ** LatestPublishDate
newtype LatestPublishDate = LatestPublishDate { unLatestPublishDate :: Text } deriving (P.Eq, P.Show)

-- ** LatestPublishYear
newtype LatestPublishYear = LatestPublishYear { unLatestPublishYear :: Int } deriving (P.Eq, P.Show)

-- ** LocationFilter
newtype LocationFilter = LocationFilter { unLocationFilter :: Text } deriving (P.Eq, P.Show)

-- ** Lon
newtype Lon = Lon { unLon :: Double } deriving (P.Eq, P.Show)

-- ** MaxAgeDays
newtype MaxAgeDays = MaxAgeDays { unMaxAgeDays :: Int } deriving (P.Eq, P.Show)

-- ** MaxAlcohol
newtype MaxAlcohol = MaxAlcohol { unMaxAlcohol :: Double } deriving (P.Eq, P.Show)

-- ** MaxAlcoholPercent
newtype MaxAlcoholPercent = MaxAlcoholPercent { unMaxAlcoholPercent :: Double } deriving (P.Eq, P.Show)

-- ** MaxCaffeine
newtype MaxCaffeine = MaxCaffeine { unMaxCaffeine :: Double } deriving (P.Eq, P.Show)

-- ** MaxCalcium
newtype MaxCalcium = MaxCalcium { unMaxCalcium :: Double } deriving (P.Eq, P.Show)

-- ** MaxCalories
newtype MaxCalories = MaxCalories { unMaxCalories :: Double } deriving (P.Eq, P.Show)

-- ** MaxCarbs
newtype MaxCarbs = MaxCarbs { unMaxCarbs :: Double } deriving (P.Eq, P.Show)

-- ** MaxCholesterol
newtype MaxCholesterol = MaxCholesterol { unMaxCholesterol :: Double } deriving (P.Eq, P.Show)

-- ** MaxCholine
newtype MaxCholine = MaxCholine { unMaxCholine :: Double } deriving (P.Eq, P.Show)

-- ** MaxCopper
newtype MaxCopper = MaxCopper { unMaxCopper :: Double } deriving (P.Eq, P.Show)

-- ** MaxFat
newtype MaxFat = MaxFat { unMaxFat :: Double } deriving (P.Eq, P.Show)

-- ** MaxFiber
newtype MaxFiber = MaxFiber { unMaxFiber :: Double } deriving (P.Eq, P.Show)

-- ** MaxFluoride
newtype MaxFluoride = MaxFluoride { unMaxFluoride :: Double } deriving (P.Eq, P.Show)

-- ** MaxFolate
newtype MaxFolate = MaxFolate { unMaxFolate :: Double } deriving (P.Eq, P.Show)

-- ** MaxFolicAcid
newtype MaxFolicAcid = MaxFolicAcid { unMaxFolicAcid :: Double } deriving (P.Eq, P.Show)

-- ** MaxIodine
newtype MaxIodine = MaxIodine { unMaxIodine :: Double } deriving (P.Eq, P.Show)

-- ** MaxIron
newtype MaxIron = MaxIron { unMaxIron :: Double } deriving (P.Eq, P.Show)

-- ** MaxLength
newtype MaxLength = MaxLength { unMaxLength :: Double } deriving (P.Eq, P.Show)

-- ** MaxLengthInt
newtype MaxLengthInt = MaxLengthInt { unMaxLengthInt :: Int } deriving (P.Eq, P.Show)

-- ** MaxLines
newtype MaxLines = MaxLines { unMaxLines :: Int } deriving (P.Eq, P.Show)

-- ** MaxMagnesium
newtype MaxMagnesium = MaxMagnesium { unMaxMagnesium :: Double } deriving (P.Eq, P.Show)

-- ** MaxManganese
newtype MaxManganese = MaxManganese { unMaxManganese :: Double } deriving (P.Eq, P.Show)

-- ** MaxPhosphorus
newtype MaxPhosphorus = MaxPhosphorus { unMaxPhosphorus :: Double } deriving (P.Eq, P.Show)

-- ** MaxPotassium
newtype MaxPotassium = MaxPotassium { unMaxPotassium :: Double } deriving (P.Eq, P.Show)

-- ** MaxProtein
newtype MaxProtein = MaxProtein { unMaxProtein :: Double } deriving (P.Eq, P.Show)

-- ** MaxRating
newtype MaxRating = MaxRating { unMaxRating :: Double } deriving (P.Eq, P.Show)

-- ** MaxSaturatedFat
newtype MaxSaturatedFat = MaxSaturatedFat { unMaxSaturatedFat :: Double } deriving (P.Eq, P.Show)

-- ** MaxSelenium
newtype MaxSelenium = MaxSelenium { unMaxSelenium :: Double } deriving (P.Eq, P.Show)

-- ** MaxSentiment
newtype MaxSentiment = MaxSentiment { unMaxSentiment :: Double } deriving (P.Eq, P.Show)

-- ** MaxServings
newtype MaxServings = MaxServings { unMaxServings :: Int } deriving (P.Eq, P.Show)

-- ** MaxSodium
newtype MaxSodium = MaxSodium { unMaxSodium :: Double } deriving (P.Eq, P.Show)

-- ** MaxSugar
newtype MaxSugar = MaxSugar { unMaxSugar :: Double } deriving (P.Eq, P.Show)

-- ** MaxTime
newtype MaxTime = MaxTime { unMaxTime :: Int } deriving (P.Eq, P.Show)

-- ** MaxVitaminA
newtype MaxVitaminA = MaxVitaminA { unMaxVitaminA :: Double } deriving (P.Eq, P.Show)

-- ** MaxVitaminB1
newtype MaxVitaminB1 = MaxVitaminB1 { unMaxVitaminB1 :: Double } deriving (P.Eq, P.Show)

-- ** MaxVitaminB12
newtype MaxVitaminB12 = MaxVitaminB12 { unMaxVitaminB12 :: Double } deriving (P.Eq, P.Show)

-- ** MaxVitaminB2
newtype MaxVitaminB2 = MaxVitaminB2 { unMaxVitaminB2 :: Double } deriving (P.Eq, P.Show)

-- ** MaxVitaminB3
newtype MaxVitaminB3 = MaxVitaminB3 { unMaxVitaminB3 :: Double } deriving (P.Eq, P.Show)

-- ** MaxVitaminB5
newtype MaxVitaminB5 = MaxVitaminB5 { unMaxVitaminB5 :: Double } deriving (P.Eq, P.Show)

-- ** MaxVitaminB6
newtype MaxVitaminB6 = MaxVitaminB6 { unMaxVitaminB6 :: Double } deriving (P.Eq, P.Show)

-- ** MaxVitaminC
newtype MaxVitaminC = MaxVitaminC { unMaxVitaminC :: Double } deriving (P.Eq, P.Show)

-- ** MaxVitaminD
newtype MaxVitaminD = MaxVitaminD { unMaxVitaminD :: Double } deriving (P.Eq, P.Show)

-- ** MaxVitaminE
newtype MaxVitaminE = MaxVitaminE { unMaxVitaminE :: Double } deriving (P.Eq, P.Show)

-- ** MaxVitaminK
newtype MaxVitaminK = MaxVitaminK { unMaxVitaminK :: Double } deriving (P.Eq, P.Show)

-- ** MaxZinc
newtype MaxZinc = MaxZinc { unMaxZinc :: Double } deriving (P.Eq, P.Show)

-- ** MealType
newtype MealType = MealType { unMealType :: Text } deriving (P.Eq, P.Show)

-- ** MediaType
newtype MediaType = MediaType { unMediaType :: Text } deriving (P.Eq, P.Show)

-- ** MinAlcohol
newtype MinAlcohol = MinAlcohol { unMinAlcohol :: Double } deriving (P.Eq, P.Show)

-- ** MinAlcoholPercent
newtype MinAlcoholPercent = MinAlcoholPercent { unMinAlcoholPercent :: Double } deriving (P.Eq, P.Show)

-- ** MinCaffeine
newtype MinCaffeine = MinCaffeine { unMinCaffeine :: Double } deriving (P.Eq, P.Show)

-- ** MinCalcium
newtype MinCalcium = MinCalcium { unMinCalcium :: Double } deriving (P.Eq, P.Show)

-- ** MinCalories
newtype MinCalories = MinCalories { unMinCalories :: Double } deriving (P.Eq, P.Show)

-- ** MinCarbs
newtype MinCarbs = MinCarbs { unMinCarbs :: Double } deriving (P.Eq, P.Show)

-- ** MinCholesterol
newtype MinCholesterol = MinCholesterol { unMinCholesterol :: Double } deriving (P.Eq, P.Show)

-- ** MinCholine
newtype MinCholine = MinCholine { unMinCholine :: Double } deriving (P.Eq, P.Show)

-- ** MinCopper
newtype MinCopper = MinCopper { unMinCopper :: Double } deriving (P.Eq, P.Show)

-- ** MinFat
newtype MinFat = MinFat { unMinFat :: Double } deriving (P.Eq, P.Show)

-- ** MinFiber
newtype MinFiber = MinFiber { unMinFiber :: Double } deriving (P.Eq, P.Show)

-- ** MinFluoride
newtype MinFluoride = MinFluoride { unMinFluoride :: Double } deriving (P.Eq, P.Show)

-- ** MinFolate
newtype MinFolate = MinFolate { unMinFolate :: Double } deriving (P.Eq, P.Show)

-- ** MinFolicAcid
newtype MinFolicAcid = MinFolicAcid { unMinFolicAcid :: Double } deriving (P.Eq, P.Show)

-- ** MinIodine
newtype MinIodine = MinIodine { unMinIodine :: Double } deriving (P.Eq, P.Show)

-- ** MinIron
newtype MinIron = MinIron { unMinIron :: Double } deriving (P.Eq, P.Show)

-- ** MinLength
newtype MinLength = MinLength { unMinLength :: Int } deriving (P.Eq, P.Show)

-- ** MinLines
newtype MinLines = MinLines { unMinLines :: Int } deriving (P.Eq, P.Show)

-- ** MinMagnesium
newtype MinMagnesium = MinMagnesium { unMinMagnesium :: Double } deriving (P.Eq, P.Show)

-- ** MinManganese
newtype MinManganese = MinManganese { unMinManganese :: Double } deriving (P.Eq, P.Show)

-- ** MinPhosphorus
newtype MinPhosphorus = MinPhosphorus { unMinPhosphorus :: Double } deriving (P.Eq, P.Show)

-- ** MinPotassium
newtype MinPotassium = MinPotassium { unMinPotassium :: Double } deriving (P.Eq, P.Show)

-- ** MinProtein
newtype MinProtein = MinProtein { unMinProtein :: Double } deriving (P.Eq, P.Show)

-- ** MinRating
newtype MinRating = MinRating { unMinRating :: Double } deriving (P.Eq, P.Show)

-- ** MinSaturatedFat
newtype MinSaturatedFat = MinSaturatedFat { unMinSaturatedFat :: Double } deriving (P.Eq, P.Show)

-- ** MinSelenium
newtype MinSelenium = MinSelenium { unMinSelenium :: Double } deriving (P.Eq, P.Show)

-- ** MinSentiment
newtype MinSentiment = MinSentiment { unMinSentiment :: Double } deriving (P.Eq, P.Show)

-- ** MinServings
newtype MinServings = MinServings { unMinServings :: Int } deriving (P.Eq, P.Show)

-- ** MinSodium
newtype MinSodium = MinSodium { unMinSodium :: Double } deriving (P.Eq, P.Show)

-- ** MinSugar
newtype MinSugar = MinSugar { unMinSugar :: Double } deriving (P.Eq, P.Show)

-- ** MinVitaminA
newtype MinVitaminA = MinVitaminA { unMinVitaminA :: Double } deriving (P.Eq, P.Show)

-- ** MinVitaminB1
newtype MinVitaminB1 = MinVitaminB1 { unMinVitaminB1 :: Double } deriving (P.Eq, P.Show)

-- ** MinVitaminB12
newtype MinVitaminB12 = MinVitaminB12 { unMinVitaminB12 :: Double } deriving (P.Eq, P.Show)

-- ** MinVitaminB2
newtype MinVitaminB2 = MinVitaminB2 { unMinVitaminB2 :: Double } deriving (P.Eq, P.Show)

-- ** MinVitaminB3
newtype MinVitaminB3 = MinVitaminB3 { unMinVitaminB3 :: Double } deriving (P.Eq, P.Show)

-- ** MinVitaminB5
newtype MinVitaminB5 = MinVitaminB5 { unMinVitaminB5 :: Double } deriving (P.Eq, P.Show)

-- ** MinVitaminB6
newtype MinVitaminB6 = MinVitaminB6 { unMinVitaminB6 :: Double } deriving (P.Eq, P.Show)

-- ** MinVitaminC
newtype MinVitaminC = MinVitaminC { unMinVitaminC :: Double } deriving (P.Eq, P.Show)

-- ** MinVitaminD
newtype MinVitaminD = MinVitaminD { unMinVitaminD :: Double } deriving (P.Eq, P.Show)

-- ** MinVitaminE
newtype MinVitaminE = MinVitaminE { unMinVitaminE :: Double } deriving (P.Eq, P.Show)

-- ** MinVitaminK
newtype MinVitaminK = MinVitaminK { unMinVitaminK :: Double } deriving (P.Eq, P.Show)

-- ** MinZinc
newtype MinZinc = MinZinc { unMinZinc :: Double } deriving (P.Eq, P.Show)

-- ** Name
newtype Name = Name { unName :: Text } deriving (P.Eq, P.Show)

-- ** NewsSources
newtype NewsSources = NewsSources { unNewsSources :: Text } deriving (P.Eq, P.Show)

-- ** Number
newtype Number = Number { unNumber :: Int } deriving (P.Eq, P.Show)

-- ** Oclc
newtype Oclc = Oclc { unOclc :: Text } deriving (P.Eq, P.Show)

-- ** Offset
newtype Offset = Offset { unOffset :: Int } deriving (P.Eq, P.Show)

-- ** OnlyPublicDomain
newtype OnlyPublicDomain = OnlyPublicDomain { unOnlyPublicDomain :: Bool } deriving (P.Eq, P.Show)

-- ** Page
newtype Page = Page { unPage :: Int } deriving (P.Eq, P.Show)

-- ** ParamDate
newtype ParamDate = ParamDate { unParamDate :: Text } deriving (P.Eq, P.Show)

-- ** ParamText
newtype ParamText = ParamText { unParamText :: Text } deriving (P.Eq, P.Show)

-- ** Query
newtype Query = Query { unQuery :: Text } deriving (P.Eq, P.Show)

-- ** ReduceOils
newtype ReduceOils = ReduceOils { unReduceOils :: Bool } deriving (P.Eq, P.Show)

-- ** Servings
newtype Servings = Servings { unServings :: Int } deriving (P.Eq, P.Show)

-- ** Sort
newtype Sort = Sort { unSort :: Text } deriving (P.Eq, P.Show)

-- ** SortDirection
newtype SortDirection = SortDirection { unSortDirection :: Text } deriving (P.Eq, P.Show)

-- ** SourceAmount
newtype SourceAmount = SourceAmount { unSourceAmount :: Double } deriving (P.Eq, P.Show)

-- ** SourceCountries
newtype SourceCountries = SourceCountries { unSourceCountries :: Text } deriving (P.Eq, P.Show)

-- ** SourceCountry
newtype SourceCountry = SourceCountry { unSourceCountry :: Text } deriving (P.Eq, P.Show)

-- ** SourceUnit
newtype SourceUnit = SourceUnit { unSourceUnit :: Text } deriving (P.Eq, P.Show)

-- ** TargetUnit
newtype TargetUnit = TargetUnit { unTargetUnit :: Text } deriving (P.Eq, P.Show)

-- ** Title
newtype Title = Title { unTitle :: Text } deriving (P.Eq, P.Show)

-- ** Url
newtype Url = Url { unUrl :: Text } deriving (P.Eq, P.Show)

-- ** Value
newtype Value = Value { unValue :: Text } deriving (P.Eq, P.Show)

-- ** Width
newtype Width = Width { unWidth :: Int } deriving (P.Eq, P.Show)

-- ** Word
newtype Word = Word { unWord :: Text } deriving (P.Eq, P.Show)

-- * Models


-- ** ComputeNutrition200Response
-- | ComputeNutrition200Response
data ComputeNutrition200Response = ComputeNutrition200Response
  { computeNutrition200ResponseNutrients :: !(Maybe [SearchDrinks200ResponseDrinksInnerNutritionNutrientsInner]) -- ^ "nutrients"
  , computeNutrition200ResponseProperties :: !(Maybe [SearchDrinks200ResponseDrinksInnerNutritionFlavonoidsInner]) -- ^ "properties"
  , computeNutrition200ResponseFlavonoids :: !(Maybe [SearchRecipes200ResponseRecipesInnerNutritionNutrientsInner]) -- ^ "flavonoids"
  , computeNutrition200ResponseIngredientBreakdown :: !(Maybe [ComputeNutrition200ResponseIngredientBreakdownInner]) -- ^ "ingredient_breakdown"
  , computeNutrition200ResponseCaloricBreakdown :: !(Maybe SearchDrinks200ResponseDrinksInnerNutritionCaloricBreakdown) -- ^ "caloric_breakdown"
  , computeNutrition200ResponseWeightPerServing :: !(Maybe SearchDrinks200ResponseDrinksInnerNutritionWeightPerServing) -- ^ "weight_per_serving"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ComputeNutrition200Response
instance A.FromJSON ComputeNutrition200Response where
  parseJSON = A.withObject "ComputeNutrition200Response" $ \o ->
    ComputeNutrition200Response
      <$> (o .:? "nutrients")
      <*> (o .:? "properties")
      <*> (o .:? "flavonoids")
      <*> (o .:? "ingredient_breakdown")
      <*> (o .:? "caloric_breakdown")
      <*> (o .:? "weight_per_serving")

-- | ToJSON ComputeNutrition200Response
instance A.ToJSON ComputeNutrition200Response where
  toJSON ComputeNutrition200Response {..} =
   _omitNulls
      [ "nutrients" .= computeNutrition200ResponseNutrients
      , "properties" .= computeNutrition200ResponseProperties
      , "flavonoids" .= computeNutrition200ResponseFlavonoids
      , "ingredient_breakdown" .= computeNutrition200ResponseIngredientBreakdown
      , "caloric_breakdown" .= computeNutrition200ResponseCaloricBreakdown
      , "weight_per_serving" .= computeNutrition200ResponseWeightPerServing
      ]


-- | Construct a value of type 'ComputeNutrition200Response' (by applying it's required fields, if any)
mkComputeNutrition200Response
  :: ComputeNutrition200Response
mkComputeNutrition200Response =
  ComputeNutrition200Response
  { computeNutrition200ResponseNutrients = Nothing
  , computeNutrition200ResponseProperties = Nothing
  , computeNutrition200ResponseFlavonoids = Nothing
  , computeNutrition200ResponseIngredientBreakdown = Nothing
  , computeNutrition200ResponseCaloricBreakdown = Nothing
  , computeNutrition200ResponseWeightPerServing = Nothing
  }

-- ** ComputeNutrition200ResponseIngredientBreakdownInner
-- | ComputeNutrition200ResponseIngredientBreakdownInner
data ComputeNutrition200ResponseIngredientBreakdownInner = ComputeNutrition200ResponseIngredientBreakdownInner
  { computeNutrition200ResponseIngredientBreakdownInnerName :: !(Maybe Text) -- ^ "name"
  , computeNutrition200ResponseIngredientBreakdownInnerAmount :: !(Maybe Int) -- ^ "amount"
  , computeNutrition200ResponseIngredientBreakdownInnerUnit :: !(Maybe Text) -- ^ "unit"
  , computeNutrition200ResponseIngredientBreakdownInnerId :: !(Maybe Int) -- ^ "id"
  , computeNutrition200ResponseIngredientBreakdownInnerNutrients :: !(Maybe [ComputeNutrition200ResponseIngredientBreakdownInnerNutrientsInner]) -- ^ "nutrients"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ComputeNutrition200ResponseIngredientBreakdownInner
instance A.FromJSON ComputeNutrition200ResponseIngredientBreakdownInner where
  parseJSON = A.withObject "ComputeNutrition200ResponseIngredientBreakdownInner" $ \o ->
    ComputeNutrition200ResponseIngredientBreakdownInner
      <$> (o .:? "name")
      <*> (o .:? "amount")
      <*> (o .:? "unit")
      <*> (o .:? "id")
      <*> (o .:? "nutrients")

-- | ToJSON ComputeNutrition200ResponseIngredientBreakdownInner
instance A.ToJSON ComputeNutrition200ResponseIngredientBreakdownInner where
  toJSON ComputeNutrition200ResponseIngredientBreakdownInner {..} =
   _omitNulls
      [ "name" .= computeNutrition200ResponseIngredientBreakdownInnerName
      , "amount" .= computeNutrition200ResponseIngredientBreakdownInnerAmount
      , "unit" .= computeNutrition200ResponseIngredientBreakdownInnerUnit
      , "id" .= computeNutrition200ResponseIngredientBreakdownInnerId
      , "nutrients" .= computeNutrition200ResponseIngredientBreakdownInnerNutrients
      ]


-- | Construct a value of type 'ComputeNutrition200ResponseIngredientBreakdownInner' (by applying it's required fields, if any)
mkComputeNutrition200ResponseIngredientBreakdownInner
  :: ComputeNutrition200ResponseIngredientBreakdownInner
mkComputeNutrition200ResponseIngredientBreakdownInner =
  ComputeNutrition200ResponseIngredientBreakdownInner
  { computeNutrition200ResponseIngredientBreakdownInnerName = Nothing
  , computeNutrition200ResponseIngredientBreakdownInnerAmount = Nothing
  , computeNutrition200ResponseIngredientBreakdownInnerUnit = Nothing
  , computeNutrition200ResponseIngredientBreakdownInnerId = Nothing
  , computeNutrition200ResponseIngredientBreakdownInnerNutrients = Nothing
  }

-- ** ComputeNutrition200ResponseIngredientBreakdownInnerNutrientsInner
-- | ComputeNutrition200ResponseIngredientBreakdownInnerNutrientsInner
data ComputeNutrition200ResponseIngredientBreakdownInnerNutrientsInner = ComputeNutrition200ResponseIngredientBreakdownInnerNutrientsInner
  { computeNutrition200ResponseIngredientBreakdownInnerNutrientsInnerName :: !(Maybe Text) -- ^ "name"
  , computeNutrition200ResponseIngredientBreakdownInnerNutrientsInnerPercentOfDailyNeeds :: !(Maybe Int) -- ^ "percent_of_daily_needs"
  , computeNutrition200ResponseIngredientBreakdownInnerNutrientsInnerAmount :: !(Maybe Int) -- ^ "amount"
  , computeNutrition200ResponseIngredientBreakdownInnerNutrientsInnerUnit :: !(Maybe Text) -- ^ "unit"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ComputeNutrition200ResponseIngredientBreakdownInnerNutrientsInner
instance A.FromJSON ComputeNutrition200ResponseIngredientBreakdownInnerNutrientsInner where
  parseJSON = A.withObject "ComputeNutrition200ResponseIngredientBreakdownInnerNutrientsInner" $ \o ->
    ComputeNutrition200ResponseIngredientBreakdownInnerNutrientsInner
      <$> (o .:? "name")
      <*> (o .:? "percent_of_daily_needs")
      <*> (o .:? "amount")
      <*> (o .:? "unit")

-- | ToJSON ComputeNutrition200ResponseIngredientBreakdownInnerNutrientsInner
instance A.ToJSON ComputeNutrition200ResponseIngredientBreakdownInnerNutrientsInner where
  toJSON ComputeNutrition200ResponseIngredientBreakdownInnerNutrientsInner {..} =
   _omitNulls
      [ "name" .= computeNutrition200ResponseIngredientBreakdownInnerNutrientsInnerName
      , "percent_of_daily_needs" .= computeNutrition200ResponseIngredientBreakdownInnerNutrientsInnerPercentOfDailyNeeds
      , "amount" .= computeNutrition200ResponseIngredientBreakdownInnerNutrientsInnerAmount
      , "unit" .= computeNutrition200ResponseIngredientBreakdownInnerNutrientsInnerUnit
      ]


-- | Construct a value of type 'ComputeNutrition200ResponseIngredientBreakdownInnerNutrientsInner' (by applying it's required fields, if any)
mkComputeNutrition200ResponseIngredientBreakdownInnerNutrientsInner
  :: ComputeNutrition200ResponseIngredientBreakdownInnerNutrientsInner
mkComputeNutrition200ResponseIngredientBreakdownInnerNutrientsInner =
  ComputeNutrition200ResponseIngredientBreakdownInnerNutrientsInner
  { computeNutrition200ResponseIngredientBreakdownInnerNutrientsInnerName = Nothing
  , computeNutrition200ResponseIngredientBreakdownInnerNutrientsInnerPercentOfDailyNeeds = Nothing
  , computeNutrition200ResponseIngredientBreakdownInnerNutrientsInnerAmount = Nothing
  , computeNutrition200ResponseIngredientBreakdownInnerNutrientsInnerUnit = Nothing
  }

-- ** ConvertUnits200Response
-- | ConvertUnits200Response
data ConvertUnits200Response = ConvertUnits200Response
  { convertUnits200ResponseTargetAmount :: !(Maybe Double) -- ^ "target_amount"
  , convertUnits200ResponseTargetUnit :: !(Maybe Text) -- ^ "target_unit"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ConvertUnits200Response
instance A.FromJSON ConvertUnits200Response where
  parseJSON = A.withObject "ConvertUnits200Response" $ \o ->
    ConvertUnits200Response
      <$> (o .:? "target_amount")
      <*> (o .:? "target_unit")

-- | ToJSON ConvertUnits200Response
instance A.ToJSON ConvertUnits200Response where
  toJSON ConvertUnits200Response {..} =
   _omitNulls
      [ "target_amount" .= convertUnits200ResponseTargetAmount
      , "target_unit" .= convertUnits200ResponseTargetUnit
      ]


-- | Construct a value of type 'ConvertUnits200Response' (by applying it's required fields, if any)
mkConvertUnits200Response
  :: ConvertUnits200Response
mkConvertUnits200Response =
  ConvertUnits200Response
  { convertUnits200ResponseTargetAmount = Nothing
  , convertUnits200ResponseTargetUnit = Nothing
  }

-- ** CorrectSpelling200Response
-- | CorrectSpelling200Response
data CorrectSpelling200Response = CorrectSpelling200Response
  { correctSpelling200ResponseCorrectedText :: !(Maybe Text) -- ^ "corrected_text"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CorrectSpelling200Response
instance A.FromJSON CorrectSpelling200Response where
  parseJSON = A.withObject "CorrectSpelling200Response" $ \o ->
    CorrectSpelling200Response
      <$> (o .:? "corrected_text")

-- | ToJSON CorrectSpelling200Response
instance A.ToJSON CorrectSpelling200Response where
  toJSON CorrectSpelling200Response {..} =
   _omitNulls
      [ "corrected_text" .= correctSpelling200ResponseCorrectedText
      ]


-- | Construct a value of type 'CorrectSpelling200Response' (by applying it's required fields, if any)
mkCorrectSpelling200Response
  :: CorrectSpelling200Response
mkCorrectSpelling200Response =
  CorrectSpelling200Response
  { correctSpelling200ResponseCorrectedText = Nothing
  }

-- ** DetectGenderByName200Response
-- | DetectGenderByName200Response
data DetectGenderByName200Response = DetectGenderByName200Response
  { detectGenderByName200ResponseName :: !(Maybe Text) -- ^ "name"
  , detectGenderByName200ResponseProbabilityMale :: !(Maybe Double) -- ^ "probability_male"
  , detectGenderByName200ResponseProbabilityFemale :: !(Maybe Double) -- ^ "probability_female"
  , detectGenderByName200ResponsePopularity :: !(Maybe Double) -- ^ "popularity"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON DetectGenderByName200Response
instance A.FromJSON DetectGenderByName200Response where
  parseJSON = A.withObject "DetectGenderByName200Response" $ \o ->
    DetectGenderByName200Response
      <$> (o .:? "name")
      <*> (o .:? "probability_male")
      <*> (o .:? "probability_female")
      <*> (o .:? "popularity")

-- | ToJSON DetectGenderByName200Response
instance A.ToJSON DetectGenderByName200Response where
  toJSON DetectGenderByName200Response {..} =
   _omitNulls
      [ "name" .= detectGenderByName200ResponseName
      , "probability_male" .= detectGenderByName200ResponseProbabilityMale
      , "probability_female" .= detectGenderByName200ResponseProbabilityFemale
      , "popularity" .= detectGenderByName200ResponsePopularity
      ]


-- | Construct a value of type 'DetectGenderByName200Response' (by applying it's required fields, if any)
mkDetectGenderByName200Response
  :: DetectGenderByName200Response
mkDetectGenderByName200Response =
  DetectGenderByName200Response
  { detectGenderByName200ResponseName = Nothing
  , detectGenderByName200ResponseProbabilityMale = Nothing
  , detectGenderByName200ResponseProbabilityFemale = Nothing
  , detectGenderByName200ResponsePopularity = Nothing
  }

-- ** DetectLanguage200ResponseInner
-- | DetectLanguage200ResponseInner
data DetectLanguage200ResponseInner = DetectLanguage200ResponseInner
  { detectLanguage200ResponseInnerLanguage :: !(Maybe Text) -- ^ "language"
  , detectLanguage200ResponseInnerConfidence :: !(Maybe Double) -- ^ "confidence"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON DetectLanguage200ResponseInner
instance A.FromJSON DetectLanguage200ResponseInner where
  parseJSON = A.withObject "DetectLanguage200ResponseInner" $ \o ->
    DetectLanguage200ResponseInner
      <$> (o .:? "language")
      <*> (o .:? "confidence")

-- | ToJSON DetectLanguage200ResponseInner
instance A.ToJSON DetectLanguage200ResponseInner where
  toJSON DetectLanguage200ResponseInner {..} =
   _omitNulls
      [ "language" .= detectLanguage200ResponseInnerLanguage
      , "confidence" .= detectLanguage200ResponseInnerConfidence
      ]


-- | Construct a value of type 'DetectLanguage200ResponseInner' (by applying it's required fields, if any)
mkDetectLanguage200ResponseInner
  :: DetectLanguage200ResponseInner
mkDetectLanguage200ResponseInner =
  DetectLanguage200ResponseInner
  { detectLanguage200ResponseInnerLanguage = Nothing
  , detectLanguage200ResponseInnerConfidence = Nothing
  }

-- ** DetectMainImageColor200ResponseInner
-- | DetectMainImageColor200ResponseInner
data DetectMainImageColor200ResponseInner = DetectMainImageColor200ResponseInner
  { detectMainImageColor200ResponseInnerSpecificColor :: !(Maybe Text) -- ^ "specific_color"
  , detectMainImageColor200ResponseInnerMainColor :: !(Maybe Text) -- ^ "main_color"
  , detectMainImageColor200ResponseInnerHexCode :: !(Maybe Text) -- ^ "hex_code"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON DetectMainImageColor200ResponseInner
instance A.FromJSON DetectMainImageColor200ResponseInner where
  parseJSON = A.withObject "DetectMainImageColor200ResponseInner" $ \o ->
    DetectMainImageColor200ResponseInner
      <$> (o .:? "specific_color")
      <*> (o .:? "main_color")
      <*> (o .:? "hex_code")

-- | ToJSON DetectMainImageColor200ResponseInner
instance A.ToJSON DetectMainImageColor200ResponseInner where
  toJSON DetectMainImageColor200ResponseInner {..} =
   _omitNulls
      [ "specific_color" .= detectMainImageColor200ResponseInnerSpecificColor
      , "main_color" .= detectMainImageColor200ResponseInnerMainColor
      , "hex_code" .= detectMainImageColor200ResponseInnerHexCode
      ]


-- | Construct a value of type 'DetectMainImageColor200ResponseInner' (by applying it's required fields, if any)
mkDetectMainImageColor200ResponseInner
  :: DetectMainImageColor200ResponseInner
mkDetectMainImageColor200ResponseInner =
  DetectMainImageColor200ResponseInner
  { detectMainImageColor200ResponseInnerSpecificColor = Nothing
  , detectMainImageColor200ResponseInnerMainColor = Nothing
  , detectMainImageColor200ResponseInnerHexCode = Nothing
  }

-- ** DetectSentiment200Response
-- | DetectSentiment200Response
data DetectSentiment200Response = DetectSentiment200Response
  { detectSentiment200ResponseDocument :: !(Maybe DetectSentiment200ResponseDocument) -- ^ "document"
  , detectSentiment200ResponseSentences :: !(Maybe [DetectSentiment200ResponseSentencesInner]) -- ^ "sentences"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON DetectSentiment200Response
instance A.FromJSON DetectSentiment200Response where
  parseJSON = A.withObject "DetectSentiment200Response" $ \o ->
    DetectSentiment200Response
      <$> (o .:? "document")
      <*> (o .:? "sentences")

-- | ToJSON DetectSentiment200Response
instance A.ToJSON DetectSentiment200Response where
  toJSON DetectSentiment200Response {..} =
   _omitNulls
      [ "document" .= detectSentiment200ResponseDocument
      , "sentences" .= detectSentiment200ResponseSentences
      ]


-- | Construct a value of type 'DetectSentiment200Response' (by applying it's required fields, if any)
mkDetectSentiment200Response
  :: DetectSentiment200Response
mkDetectSentiment200Response =
  DetectSentiment200Response
  { detectSentiment200ResponseDocument = Nothing
  , detectSentiment200ResponseSentences = Nothing
  }

-- ** DetectSentiment200ResponseDocument
-- | DetectSentiment200ResponseDocument
data DetectSentiment200ResponseDocument = DetectSentiment200ResponseDocument
  { detectSentiment200ResponseDocumentSentiment :: !(Maybe Text) -- ^ "sentiment"
  , detectSentiment200ResponseDocumentConfidence :: !(Maybe Int) -- ^ "confidence"
  , detectSentiment200ResponseDocumentAverageConfidence :: !(Maybe Int) -- ^ "average_confidence"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON DetectSentiment200ResponseDocument
instance A.FromJSON DetectSentiment200ResponseDocument where
  parseJSON = A.withObject "DetectSentiment200ResponseDocument" $ \o ->
    DetectSentiment200ResponseDocument
      <$> (o .:? "sentiment")
      <*> (o .:? "confidence")
      <*> (o .:? "average_confidence")

-- | ToJSON DetectSentiment200ResponseDocument
instance A.ToJSON DetectSentiment200ResponseDocument where
  toJSON DetectSentiment200ResponseDocument {..} =
   _omitNulls
      [ "sentiment" .= detectSentiment200ResponseDocumentSentiment
      , "confidence" .= detectSentiment200ResponseDocumentConfidence
      , "average_confidence" .= detectSentiment200ResponseDocumentAverageConfidence
      ]


-- | Construct a value of type 'DetectSentiment200ResponseDocument' (by applying it's required fields, if any)
mkDetectSentiment200ResponseDocument
  :: DetectSentiment200ResponseDocument
mkDetectSentiment200ResponseDocument =
  DetectSentiment200ResponseDocument
  { detectSentiment200ResponseDocumentSentiment = Nothing
  , detectSentiment200ResponseDocumentConfidence = Nothing
  , detectSentiment200ResponseDocumentAverageConfidence = Nothing
  }

-- ** DetectSentiment200ResponseSentencesInner
-- | DetectSentiment200ResponseSentencesInner
data DetectSentiment200ResponseSentencesInner = DetectSentiment200ResponseSentencesInner
  { detectSentiment200ResponseSentencesInnerLength :: !(Maybe Int) -- ^ "length"
  , detectSentiment200ResponseSentencesInnerSentiment :: !(Maybe Text) -- ^ "sentiment"
  , detectSentiment200ResponseSentencesInnerOffset :: !(Maybe Int) -- ^ "offset"
  , detectSentiment200ResponseSentencesInnerConfidence :: !(Maybe Int) -- ^ "confidence"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON DetectSentiment200ResponseSentencesInner
instance A.FromJSON DetectSentiment200ResponseSentencesInner where
  parseJSON = A.withObject "DetectSentiment200ResponseSentencesInner" $ \o ->
    DetectSentiment200ResponseSentencesInner
      <$> (o .:? "length")
      <*> (o .:? "sentiment")
      <*> (o .:? "offset")
      <*> (o .:? "confidence")

-- | ToJSON DetectSentiment200ResponseSentencesInner
instance A.ToJSON DetectSentiment200ResponseSentencesInner where
  toJSON DetectSentiment200ResponseSentencesInner {..} =
   _omitNulls
      [ "length" .= detectSentiment200ResponseSentencesInnerLength
      , "sentiment" .= detectSentiment200ResponseSentencesInnerSentiment
      , "offset" .= detectSentiment200ResponseSentencesInnerOffset
      , "confidence" .= detectSentiment200ResponseSentencesInnerConfidence
      ]


-- | Construct a value of type 'DetectSentiment200ResponseSentencesInner' (by applying it's required fields, if any)
mkDetectSentiment200ResponseSentencesInner
  :: DetectSentiment200ResponseSentencesInner
mkDetectSentiment200ResponseSentencesInner =
  DetectSentiment200ResponseSentencesInner
  { detectSentiment200ResponseSentencesInnerLength = Nothing
  , detectSentiment200ResponseSentencesInnerSentiment = Nothing
  , detectSentiment200ResponseSentencesInnerOffset = Nothing
  , detectSentiment200ResponseSentencesInnerConfidence = Nothing
  }

-- ** ExtractAuthors200Response
-- | ExtractAuthors200Response
data ExtractAuthors200Response = ExtractAuthors200Response
  { extractAuthors200ResponseAuthors :: !(Maybe [ExtractAuthors200ResponseAuthorsInner]) -- ^ "authors"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ExtractAuthors200Response
instance A.FromJSON ExtractAuthors200Response where
  parseJSON = A.withObject "ExtractAuthors200Response" $ \o ->
    ExtractAuthors200Response
      <$> (o .:? "authors")

-- | ToJSON ExtractAuthors200Response
instance A.ToJSON ExtractAuthors200Response where
  toJSON ExtractAuthors200Response {..} =
   _omitNulls
      [ "authors" .= extractAuthors200ResponseAuthors
      ]


-- | Construct a value of type 'ExtractAuthors200Response' (by applying it's required fields, if any)
mkExtractAuthors200Response
  :: ExtractAuthors200Response
mkExtractAuthors200Response =
  ExtractAuthors200Response
  { extractAuthors200ResponseAuthors = Nothing
  }

-- ** ExtractAuthors200ResponseAuthorsInner
-- | ExtractAuthors200ResponseAuthorsInner
data ExtractAuthors200ResponseAuthorsInner = ExtractAuthors200ResponseAuthorsInner
  { extractAuthors200ResponseAuthorsInnerLink :: !(Maybe Text) -- ^ "link"
  , extractAuthors200ResponseAuthorsInnerName :: !(Maybe Text) -- ^ "name"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ExtractAuthors200ResponseAuthorsInner
instance A.FromJSON ExtractAuthors200ResponseAuthorsInner where
  parseJSON = A.withObject "ExtractAuthors200ResponseAuthorsInner" $ \o ->
    ExtractAuthors200ResponseAuthorsInner
      <$> (o .:? "link")
      <*> (o .:? "name")

-- | ToJSON ExtractAuthors200ResponseAuthorsInner
instance A.ToJSON ExtractAuthors200ResponseAuthorsInner where
  toJSON ExtractAuthors200ResponseAuthorsInner {..} =
   _omitNulls
      [ "link" .= extractAuthors200ResponseAuthorsInnerLink
      , "name" .= extractAuthors200ResponseAuthorsInnerName
      ]


-- | Construct a value of type 'ExtractAuthors200ResponseAuthorsInner' (by applying it's required fields, if any)
mkExtractAuthors200ResponseAuthorsInner
  :: ExtractAuthors200ResponseAuthorsInner
mkExtractAuthors200ResponseAuthorsInner =
  ExtractAuthors200ResponseAuthorsInner
  { extractAuthors200ResponseAuthorsInnerLink = Nothing
  , extractAuthors200ResponseAuthorsInnerName = Nothing
  }

-- ** ExtractContentFromAWebPage200Response
-- | ExtractContentFromAWebPage200Response
data ExtractContentFromAWebPage200Response = ExtractContentFromAWebPage200Response
  { extractContentFromAWebPage200ResponseTitle :: !(Maybe Text) -- ^ "title"
  , extractContentFromAWebPage200ResponseMainText :: !(Maybe Text) -- ^ "main_text"
  , extractContentFromAWebPage200ResponseMainHtml :: !(Maybe Text) -- ^ "main_html"
  , extractContentFromAWebPage200ResponseImages :: !(Maybe [Text]) -- ^ "images"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ExtractContentFromAWebPage200Response
instance A.FromJSON ExtractContentFromAWebPage200Response where
  parseJSON = A.withObject "ExtractContentFromAWebPage200Response" $ \o ->
    ExtractContentFromAWebPage200Response
      <$> (o .:? "title")
      <*> (o .:? "main_text")
      <*> (o .:? "main_html")
      <*> (o .:? "images")

-- | ToJSON ExtractContentFromAWebPage200Response
instance A.ToJSON ExtractContentFromAWebPage200Response where
  toJSON ExtractContentFromAWebPage200Response {..} =
   _omitNulls
      [ "title" .= extractContentFromAWebPage200ResponseTitle
      , "main_text" .= extractContentFromAWebPage200ResponseMainText
      , "main_html" .= extractContentFromAWebPage200ResponseMainHtml
      , "images" .= extractContentFromAWebPage200ResponseImages
      ]


-- | Construct a value of type 'ExtractContentFromAWebPage200Response' (by applying it's required fields, if any)
mkExtractContentFromAWebPage200Response
  :: ExtractContentFromAWebPage200Response
mkExtractContentFromAWebPage200Response =
  ExtractContentFromAWebPage200Response
  { extractContentFromAWebPage200ResponseTitle = Nothing
  , extractContentFromAWebPage200ResponseMainText = Nothing
  , extractContentFromAWebPage200ResponseMainHtml = Nothing
  , extractContentFromAWebPage200ResponseImages = Nothing
  }

-- ** ExtractDates200Response
-- | ExtractDates200Response
data ExtractDates200Response = ExtractDates200Response
  { extractDates200ResponseDates :: !(Maybe [ExtractDates200ResponseDatesInner]) -- ^ "dates"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ExtractDates200Response
instance A.FromJSON ExtractDates200Response where
  parseJSON = A.withObject "ExtractDates200Response" $ \o ->
    ExtractDates200Response
      <$> (o .:? "dates")

-- | ToJSON ExtractDates200Response
instance A.ToJSON ExtractDates200Response where
  toJSON ExtractDates200Response {..} =
   _omitNulls
      [ "dates" .= extractDates200ResponseDates
      ]


-- | Construct a value of type 'ExtractDates200Response' (by applying it's required fields, if any)
mkExtractDates200Response
  :: ExtractDates200Response
mkExtractDates200Response =
  ExtractDates200Response
  { extractDates200ResponseDates = Nothing
  }

-- ** ExtractDates200ResponseDatesInner
-- | ExtractDates200ResponseDatesInner
data ExtractDates200ResponseDatesInner = ExtractDates200ResponseDatesInner
  { extractDates200ResponseDatesInnerStartPosition :: !(Maybe Int) -- ^ "start_position"
  , extractDates200ResponseDatesInnerDate :: !(Maybe Text) -- ^ "date"
  , extractDates200ResponseDatesInnerNormalizedDate :: !(Maybe Double) -- ^ "normalized_date"
  , extractDates200ResponseDatesInnerTag :: !(Maybe Text) -- ^ "tag"
  , extractDates200ResponseDatesInnerEndPosition :: !(Maybe Int) -- ^ "end_position"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ExtractDates200ResponseDatesInner
instance A.FromJSON ExtractDates200ResponseDatesInner where
  parseJSON = A.withObject "ExtractDates200ResponseDatesInner" $ \o ->
    ExtractDates200ResponseDatesInner
      <$> (o .:? "start_position")
      <*> (o .:? "date")
      <*> (o .:? "normalized_date")
      <*> (o .:? "tag")
      <*> (o .:? "end_position")

-- | ToJSON ExtractDates200ResponseDatesInner
instance A.ToJSON ExtractDates200ResponseDatesInner where
  toJSON ExtractDates200ResponseDatesInner {..} =
   _omitNulls
      [ "start_position" .= extractDates200ResponseDatesInnerStartPosition
      , "date" .= extractDates200ResponseDatesInnerDate
      , "normalized_date" .= extractDates200ResponseDatesInnerNormalizedDate
      , "tag" .= extractDates200ResponseDatesInnerTag
      , "end_position" .= extractDates200ResponseDatesInnerEndPosition
      ]


-- | Construct a value of type 'ExtractDates200ResponseDatesInner' (by applying it's required fields, if any)
mkExtractDates200ResponseDatesInner
  :: ExtractDates200ResponseDatesInner
mkExtractDates200ResponseDatesInner =
  ExtractDates200ResponseDatesInner
  { extractDates200ResponseDatesInnerStartPosition = Nothing
  , extractDates200ResponseDatesInnerDate = Nothing
  , extractDates200ResponseDatesInnerNormalizedDate = Nothing
  , extractDates200ResponseDatesInnerTag = Nothing
  , extractDates200ResponseDatesInnerEndPosition = Nothing
  }

-- ** ExtractEntities200Response
-- | ExtractEntities200Response
data ExtractEntities200Response = ExtractEntities200Response
  { extractEntities200ResponseEntities :: !(Maybe [ExtractEntities200ResponseEntitiesInner]) -- ^ "entities"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ExtractEntities200Response
instance A.FromJSON ExtractEntities200Response where
  parseJSON = A.withObject "ExtractEntities200Response" $ \o ->
    ExtractEntities200Response
      <$> (o .:? "entities")

-- | ToJSON ExtractEntities200Response
instance A.ToJSON ExtractEntities200Response where
  toJSON ExtractEntities200Response {..} =
   _omitNulls
      [ "entities" .= extractEntities200ResponseEntities
      ]


-- | Construct a value of type 'ExtractEntities200Response' (by applying it's required fields, if any)
mkExtractEntities200Response
  :: ExtractEntities200Response
mkExtractEntities200Response =
  ExtractEntities200Response
  { extractEntities200ResponseEntities = Nothing
  }

-- ** ExtractEntities200ResponseEntitiesInner
-- | ExtractEntities200ResponseEntitiesInner
data ExtractEntities200ResponseEntitiesInner = ExtractEntities200ResponseEntitiesInner
  { extractEntities200ResponseEntitiesInnerStartPosition :: !(Maybe Int) -- ^ "start_position"
  , extractEntities200ResponseEntitiesInnerImage :: !(Maybe Text) -- ^ "image"
  , extractEntities200ResponseEntitiesInnerType :: !(Maybe Text) -- ^ "type"
  , extractEntities200ResponseEntitiesInnerValue :: !(Maybe Text) -- ^ "value"
  , extractEntities200ResponseEntitiesInnerEndPosition :: !(Maybe Int) -- ^ "end_position"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ExtractEntities200ResponseEntitiesInner
instance A.FromJSON ExtractEntities200ResponseEntitiesInner where
  parseJSON = A.withObject "ExtractEntities200ResponseEntitiesInner" $ \o ->
    ExtractEntities200ResponseEntitiesInner
      <$> (o .:? "start_position")
      <*> (o .:? "image")
      <*> (o .:? "type")
      <*> (o .:? "value")
      <*> (o .:? "end_position")

-- | ToJSON ExtractEntities200ResponseEntitiesInner
instance A.ToJSON ExtractEntities200ResponseEntitiesInner where
  toJSON ExtractEntities200ResponseEntitiesInner {..} =
   _omitNulls
      [ "start_position" .= extractEntities200ResponseEntitiesInnerStartPosition
      , "image" .= extractEntities200ResponseEntitiesInnerImage
      , "type" .= extractEntities200ResponseEntitiesInnerType
      , "value" .= extractEntities200ResponseEntitiesInnerValue
      , "end_position" .= extractEntities200ResponseEntitiesInnerEndPosition
      ]


-- | Construct a value of type 'ExtractEntities200ResponseEntitiesInner' (by applying it's required fields, if any)
mkExtractEntities200ResponseEntitiesInner
  :: ExtractEntities200ResponseEntitiesInner
mkExtractEntities200ResponseEntitiesInner =
  ExtractEntities200ResponseEntitiesInner
  { extractEntities200ResponseEntitiesInnerStartPosition = Nothing
  , extractEntities200ResponseEntitiesInnerImage = Nothing
  , extractEntities200ResponseEntitiesInnerType = Nothing
  , extractEntities200ResponseEntitiesInnerValue = Nothing
  , extractEntities200ResponseEntitiesInnerEndPosition = Nothing
  }

-- ** ExtractNews200Response
-- | ExtractNews200Response
data ExtractNews200Response = ExtractNews200Response
  { extractNews200ResponseTitle :: !(Maybe Text) -- ^ "title"
  , extractNews200ResponseText :: !(Maybe Text) -- ^ "text"
  , extractNews200ResponseUrl :: !(Maybe Text) -- ^ "url"
  , extractNews200ResponseImages :: !(Maybe [ExtractNews200ResponseImagesInner]) -- ^ "images"
  , extractNews200ResponseVideos :: !(Maybe [ExtractNews200ResponseVideosInner]) -- ^ "videos"
  , extractNews200ResponsePublishDate :: !(Maybe Text) -- ^ "publish_date"
  , extractNews200ResponseAuthors :: !(Maybe [Text]) -- ^ "authors"
  , extractNews200ResponseLanguage :: !(Maybe Text) -- ^ "language"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ExtractNews200Response
instance A.FromJSON ExtractNews200Response where
  parseJSON = A.withObject "ExtractNews200Response" $ \o ->
    ExtractNews200Response
      <$> (o .:? "title")
      <*> (o .:? "text")
      <*> (o .:? "url")
      <*> (o .:? "images")
      <*> (o .:? "videos")
      <*> (o .:? "publish_date")
      <*> (o .:? "authors")
      <*> (o .:? "language")

-- | ToJSON ExtractNews200Response
instance A.ToJSON ExtractNews200Response where
  toJSON ExtractNews200Response {..} =
   _omitNulls
      [ "title" .= extractNews200ResponseTitle
      , "text" .= extractNews200ResponseText
      , "url" .= extractNews200ResponseUrl
      , "images" .= extractNews200ResponseImages
      , "videos" .= extractNews200ResponseVideos
      , "publish_date" .= extractNews200ResponsePublishDate
      , "authors" .= extractNews200ResponseAuthors
      , "language" .= extractNews200ResponseLanguage
      ]


-- | Construct a value of type 'ExtractNews200Response' (by applying it's required fields, if any)
mkExtractNews200Response
  :: ExtractNews200Response
mkExtractNews200Response =
  ExtractNews200Response
  { extractNews200ResponseTitle = Nothing
  , extractNews200ResponseText = Nothing
  , extractNews200ResponseUrl = Nothing
  , extractNews200ResponseImages = Nothing
  , extractNews200ResponseVideos = Nothing
  , extractNews200ResponsePublishDate = Nothing
  , extractNews200ResponseAuthors = Nothing
  , extractNews200ResponseLanguage = Nothing
  }

-- ** ExtractNews200ResponseImagesInner
-- | ExtractNews200ResponseImagesInner
data ExtractNews200ResponseImagesInner = ExtractNews200ResponseImagesInner
  { extractNews200ResponseImagesInnerWidth :: !(Maybe Int) -- ^ "width"
  , extractNews200ResponseImagesInnerTitle :: !(Maybe Text) -- ^ "title"
  , extractNews200ResponseImagesInnerUrl :: !(Maybe Text) -- ^ "url"
  , extractNews200ResponseImagesInnerHeight :: !(Maybe Int) -- ^ "height"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ExtractNews200ResponseImagesInner
instance A.FromJSON ExtractNews200ResponseImagesInner where
  parseJSON = A.withObject "ExtractNews200ResponseImagesInner" $ \o ->
    ExtractNews200ResponseImagesInner
      <$> (o .:? "width")
      <*> (o .:? "title")
      <*> (o .:? "url")
      <*> (o .:? "height")

-- | ToJSON ExtractNews200ResponseImagesInner
instance A.ToJSON ExtractNews200ResponseImagesInner where
  toJSON ExtractNews200ResponseImagesInner {..} =
   _omitNulls
      [ "width" .= extractNews200ResponseImagesInnerWidth
      , "title" .= extractNews200ResponseImagesInnerTitle
      , "url" .= extractNews200ResponseImagesInnerUrl
      , "height" .= extractNews200ResponseImagesInnerHeight
      ]


-- | Construct a value of type 'ExtractNews200ResponseImagesInner' (by applying it's required fields, if any)
mkExtractNews200ResponseImagesInner
  :: ExtractNews200ResponseImagesInner
mkExtractNews200ResponseImagesInner =
  ExtractNews200ResponseImagesInner
  { extractNews200ResponseImagesInnerWidth = Nothing
  , extractNews200ResponseImagesInnerTitle = Nothing
  , extractNews200ResponseImagesInnerUrl = Nothing
  , extractNews200ResponseImagesInnerHeight = Nothing
  }

-- ** ExtractNews200ResponseVideosInner
-- | ExtractNews200ResponseVideosInner
data ExtractNews200ResponseVideosInner = ExtractNews200ResponseVideosInner
  { extractNews200ResponseVideosInnerSummary :: !(Maybe Text) -- ^ "summary"
  , extractNews200ResponseVideosInnerDuration :: !(Maybe Int) -- ^ "duration"
  , extractNews200ResponseVideosInnerThumbnail :: !(Maybe Text) -- ^ "thumbnail"
  , extractNews200ResponseVideosInnerTitle :: !(Maybe Text) -- ^ "title"
  , extractNews200ResponseVideosInnerUrl :: !(Maybe Text) -- ^ "url"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ExtractNews200ResponseVideosInner
instance A.FromJSON ExtractNews200ResponseVideosInner where
  parseJSON = A.withObject "ExtractNews200ResponseVideosInner" $ \o ->
    ExtractNews200ResponseVideosInner
      <$> (o .:? "summary")
      <*> (o .:? "duration")
      <*> (o .:? "thumbnail")
      <*> (o .:? "title")
      <*> (o .:? "url")

-- | ToJSON ExtractNews200ResponseVideosInner
instance A.ToJSON ExtractNews200ResponseVideosInner where
  toJSON ExtractNews200ResponseVideosInner {..} =
   _omitNulls
      [ "summary" .= extractNews200ResponseVideosInnerSummary
      , "duration" .= extractNews200ResponseVideosInnerDuration
      , "thumbnail" .= extractNews200ResponseVideosInnerThumbnail
      , "title" .= extractNews200ResponseVideosInnerTitle
      , "url" .= extractNews200ResponseVideosInnerUrl
      ]


-- | Construct a value of type 'ExtractNews200ResponseVideosInner' (by applying it's required fields, if any)
mkExtractNews200ResponseVideosInner
  :: ExtractNews200ResponseVideosInner
mkExtractNews200ResponseVideosInner =
  ExtractNews200ResponseVideosInner
  { extractNews200ResponseVideosInnerSummary = Nothing
  , extractNews200ResponseVideosInnerDuration = Nothing
  , extractNews200ResponseVideosInnerThumbnail = Nothing
  , extractNews200ResponseVideosInnerTitle = Nothing
  , extractNews200ResponseVideosInnerUrl = Nothing
  }

-- ** ExtractPublishDate200Response
-- | ExtractPublishDate200Response
data ExtractPublishDate200Response = ExtractPublishDate200Response
  { extractPublishDate200ResponsePublishDate :: !(Maybe Text) -- ^ "publish_date"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ExtractPublishDate200Response
instance A.FromJSON ExtractPublishDate200Response where
  parseJSON = A.withObject "ExtractPublishDate200Response" $ \o ->
    ExtractPublishDate200Response
      <$> (o .:? "publish_date")

-- | ToJSON ExtractPublishDate200Response
instance A.ToJSON ExtractPublishDate200Response where
  toJSON ExtractPublishDate200Response {..} =
   _omitNulls
      [ "publish_date" .= extractPublishDate200ResponsePublishDate
      ]


-- | Construct a value of type 'ExtractPublishDate200Response' (by applying it's required fields, if any)
mkExtractPublishDate200Response
  :: ExtractPublishDate200Response
mkExtractPublishDate200Response =
  ExtractPublishDate200Response
  { extractPublishDate200ResponsePublishDate = Nothing
  }

-- ** FindSimilarBooks200Response
-- | FindSimilarBooks200Response
data FindSimilarBooks200Response = FindSimilarBooks200Response
  { findSimilarBooks200ResponseSimilarBooks :: !(Maybe [SearchBooks200ResponseBooksInnerInner]) -- ^ "similar_books"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON FindSimilarBooks200Response
instance A.FromJSON FindSimilarBooks200Response where
  parseJSON = A.withObject "FindSimilarBooks200Response" $ \o ->
    FindSimilarBooks200Response
      <$> (o .:? "similar_books")

-- | ToJSON FindSimilarBooks200Response
instance A.ToJSON FindSimilarBooks200Response where
  toJSON FindSimilarBooks200Response {..} =
   _omitNulls
      [ "similar_books" .= findSimilarBooks200ResponseSimilarBooks
      ]


-- | Construct a value of type 'FindSimilarBooks200Response' (by applying it's required fields, if any)
mkFindSimilarBooks200Response
  :: FindSimilarBooks200Response
mkFindSimilarBooks200Response =
  FindSimilarBooks200Response
  { findSimilarBooks200ResponseSimilarBooks = Nothing
  }

-- ** GenerateNonsenseWord200Response
-- | GenerateNonsenseWord200Response
data GenerateNonsenseWord200Response = GenerateNonsenseWord200Response
  { generateNonsenseWord200ResponseWord :: !(Maybe Text) -- ^ "word"
  , generateNonsenseWord200ResponseRating :: !(Maybe Double) -- ^ "rating"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GenerateNonsenseWord200Response
instance A.FromJSON GenerateNonsenseWord200Response where
  parseJSON = A.withObject "GenerateNonsenseWord200Response" $ \o ->
    GenerateNonsenseWord200Response
      <$> (o .:? "word")
      <*> (o .:? "rating")

-- | ToJSON GenerateNonsenseWord200Response
instance A.ToJSON GenerateNonsenseWord200Response where
  toJSON GenerateNonsenseWord200Response {..} =
   _omitNulls
      [ "word" .= generateNonsenseWord200ResponseWord
      , "rating" .= generateNonsenseWord200ResponseRating
      ]


-- | Construct a value of type 'GenerateNonsenseWord200Response' (by applying it's required fields, if any)
mkGenerateNonsenseWord200Response
  :: GenerateNonsenseWord200Response
mkGenerateNonsenseWord200Response =
  GenerateNonsenseWord200Response
  { generateNonsenseWord200ResponseWord = Nothing
  , generateNonsenseWord200ResponseRating = Nothing
  }

-- ** ListWordSynonyms200Response
-- | ListWordSynonyms200Response
data ListWordSynonyms200Response = ListWordSynonyms200Response
  { listWordSynonyms200ResponseSynonyms :: !(Maybe [Text]) -- ^ "synonyms"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ListWordSynonyms200Response
instance A.FromJSON ListWordSynonyms200Response where
  parseJSON = A.withObject "ListWordSynonyms200Response" $ \o ->
    ListWordSynonyms200Response
      <$> (o .:? "synonyms")

-- | ToJSON ListWordSynonyms200Response
instance A.ToJSON ListWordSynonyms200Response where
  toJSON ListWordSynonyms200Response {..} =
   _omitNulls
      [ "synonyms" .= listWordSynonyms200ResponseSynonyms
      ]


-- | Construct a value of type 'ListWordSynonyms200Response' (by applying it's required fields, if any)
mkListWordSynonyms200Response
  :: ListWordSynonyms200Response
mkListWordSynonyms200Response =
  ListWordSynonyms200Response
  { listWordSynonyms200ResponseSynonyms = Nothing
  }

-- ** PluralizeWord200Response
-- | PluralizeWord200Response
data PluralizeWord200Response = PluralizeWord200Response
  { pluralizeWord200ResponseOriginal :: !(Maybe Text) -- ^ "original"
  , pluralizeWord200ResponsePlural :: !(Maybe Text) -- ^ "plural"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PluralizeWord200Response
instance A.FromJSON PluralizeWord200Response where
  parseJSON = A.withObject "PluralizeWord200Response" $ \o ->
    PluralizeWord200Response
      <$> (o .:? "original")
      <*> (o .:? "plural")

-- | ToJSON PluralizeWord200Response
instance A.ToJSON PluralizeWord200Response where
  toJSON PluralizeWord200Response {..} =
   _omitNulls
      [ "original" .= pluralizeWord200ResponseOriginal
      , "plural" .= pluralizeWord200ResponsePlural
      ]


-- | Construct a value of type 'PluralizeWord200Response' (by applying it's required fields, if any)
mkPluralizeWord200Response
  :: PluralizeWord200Response
mkPluralizeWord200Response =
  PluralizeWord200Response
  { pluralizeWord200ResponseOriginal = Nothing
  , pluralizeWord200ResponsePlural = Nothing
  }

-- ** RandomMeme200Response
-- | RandomMeme200Response
data RandomMeme200Response = RandomMeme200Response
  { randomMeme200ResponseDescription :: !(Maybe Text) -- ^ "description"
  , randomMeme200ResponseUrl :: !(Maybe Text) -- ^ "url"
  , randomMeme200ResponseType :: !(Maybe Text) -- ^ "type"
  , randomMeme200ResponseWidth :: !(Maybe Int) -- ^ "width"
  , randomMeme200ResponseHeight :: !(Maybe Int) -- ^ "height"
  , randomMeme200ResponseRatio :: !(Maybe Double) -- ^ "ratio"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RandomMeme200Response
instance A.FromJSON RandomMeme200Response where
  parseJSON = A.withObject "RandomMeme200Response" $ \o ->
    RandomMeme200Response
      <$> (o .:? "description")
      <*> (o .:? "url")
      <*> (o .:? "type")
      <*> (o .:? "width")
      <*> (o .:? "height")
      <*> (o .:? "ratio")

-- | ToJSON RandomMeme200Response
instance A.ToJSON RandomMeme200Response where
  toJSON RandomMeme200Response {..} =
   _omitNulls
      [ "description" .= randomMeme200ResponseDescription
      , "url" .= randomMeme200ResponseUrl
      , "type" .= randomMeme200ResponseType
      , "width" .= randomMeme200ResponseWidth
      , "height" .= randomMeme200ResponseHeight
      , "ratio" .= randomMeme200ResponseRatio
      ]


-- | Construct a value of type 'RandomMeme200Response' (by applying it's required fields, if any)
mkRandomMeme200Response
  :: RandomMeme200Response
mkRandomMeme200Response =
  RandomMeme200Response
  { randomMeme200ResponseDescription = Nothing
  , randomMeme200ResponseUrl = Nothing
  , randomMeme200ResponseType = Nothing
  , randomMeme200ResponseWidth = Nothing
  , randomMeme200ResponseHeight = Nothing
  , randomMeme200ResponseRatio = Nothing
  }

-- ** RandomPoem200Response
-- | RandomPoem200Response
data RandomPoem200Response = RandomPoem200Response
  { randomPoem200ResponseTitle :: !(Maybe Text) -- ^ "title"
  , randomPoem200ResponseAuthor :: !(Maybe Text) -- ^ "author"
  , randomPoem200ResponsePoem :: !(Maybe Text) -- ^ "poem"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RandomPoem200Response
instance A.FromJSON RandomPoem200Response where
  parseJSON = A.withObject "RandomPoem200Response" $ \o ->
    RandomPoem200Response
      <$> (o .:? "title")
      <*> (o .:? "author")
      <*> (o .:? "poem")

-- | ToJSON RandomPoem200Response
instance A.ToJSON RandomPoem200Response where
  toJSON RandomPoem200Response {..} =
   _omitNulls
      [ "title" .= randomPoem200ResponseTitle
      , "author" .= randomPoem200ResponseAuthor
      , "poem" .= randomPoem200ResponsePoem
      ]


-- | Construct a value of type 'RandomPoem200Response' (by applying it's required fields, if any)
mkRandomPoem200Response
  :: RandomPoem200Response
mkRandomPoem200Response =
  RandomPoem200Response
  { randomPoem200ResponseTitle = Nothing
  , randomPoem200ResponseAuthor = Nothing
  , randomPoem200ResponsePoem = Nothing
  }

-- ** RandomQuote200Response
-- | RandomQuote200Response
data RandomQuote200Response = RandomQuote200Response
  { randomQuote200ResponseAuthor :: !(Maybe Text) -- ^ "author"
  , randomQuote200ResponseQuote :: !(Maybe Text) -- ^ "quote"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RandomQuote200Response
instance A.FromJSON RandomQuote200Response where
  parseJSON = A.withObject "RandomQuote200Response" $ \o ->
    RandomQuote200Response
      <$> (o .:? "author")
      <*> (o .:? "quote")

-- | ToJSON RandomQuote200Response
instance A.ToJSON RandomQuote200Response where
  toJSON RandomQuote200Response {..} =
   _omitNulls
      [ "author" .= randomQuote200ResponseAuthor
      , "quote" .= randomQuote200ResponseQuote
      ]


-- | Construct a value of type 'RandomQuote200Response' (by applying it's required fields, if any)
mkRandomQuote200Response
  :: RandomQuote200Response
mkRandomQuote200Response =
  RandomQuote200Response
  { randomQuote200ResponseAuthor = Nothing
  , randomQuote200ResponseQuote = Nothing
  }

-- ** RandomRiddle200Response
-- | RandomRiddle200Response
data RandomRiddle200Response = RandomRiddle200Response
  { randomRiddle200ResponseRiddle :: !(Maybe Text) -- ^ "riddle"
  , randomRiddle200ResponseAnswer :: !(Maybe Text) -- ^ "answer"
  , randomRiddle200ResponseDifficulty :: !(Maybe Text) -- ^ "difficulty"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RandomRiddle200Response
instance A.FromJSON RandomRiddle200Response where
  parseJSON = A.withObject "RandomRiddle200Response" $ \o ->
    RandomRiddle200Response
      <$> (o .:? "riddle")
      <*> (o .:? "answer")
      <*> (o .:? "difficulty")

-- | ToJSON RandomRiddle200Response
instance A.ToJSON RandomRiddle200Response where
  toJSON RandomRiddle200Response {..} =
   _omitNulls
      [ "riddle" .= randomRiddle200ResponseRiddle
      , "answer" .= randomRiddle200ResponseAnswer
      , "difficulty" .= randomRiddle200ResponseDifficulty
      ]


-- | Construct a value of type 'RandomRiddle200Response' (by applying it's required fields, if any)
mkRandomRiddle200Response
  :: RandomRiddle200Response
mkRandomRiddle200Response =
  RandomRiddle200Response
  { randomRiddle200ResponseRiddle = Nothing
  , randomRiddle200ResponseAnswer = Nothing
  , randomRiddle200ResponseDifficulty = Nothing
  }

-- ** RandomTrivia200Response
-- | RandomTrivia200Response
data RandomTrivia200Response = RandomTrivia200Response
  { randomTrivia200ResponseTrivia :: !(Maybe Text) -- ^ "trivia"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RandomTrivia200Response
instance A.FromJSON RandomTrivia200Response where
  parseJSON = A.withObject "RandomTrivia200Response" $ \o ->
    RandomTrivia200Response
      <$> (o .:? "trivia")

-- | ToJSON RandomTrivia200Response
instance A.ToJSON RandomTrivia200Response where
  toJSON RandomTrivia200Response {..} =
   _omitNulls
      [ "trivia" .= randomTrivia200ResponseTrivia
      ]


-- | Construct a value of type 'RandomTrivia200Response' (by applying it's required fields, if any)
mkRandomTrivia200Response
  :: RandomTrivia200Response
mkRandomTrivia200Response =
  RandomTrivia200Response
  { randomTrivia200ResponseTrivia = Nothing
  }

-- ** ReadKeyValueFromStore200Response
-- | ReadKeyValueFromStore200Response
data ReadKeyValueFromStore200Response = ReadKeyValueFromStore200Response
  { readKeyValueFromStore200ResponseValue :: !(Maybe Text) -- ^ "value"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ReadKeyValueFromStore200Response
instance A.FromJSON ReadKeyValueFromStore200Response where
  parseJSON = A.withObject "ReadKeyValueFromStore200Response" $ \o ->
    ReadKeyValueFromStore200Response
      <$> (o .:? "value")

-- | ToJSON ReadKeyValueFromStore200Response
instance A.ToJSON ReadKeyValueFromStore200Response where
  toJSON ReadKeyValueFromStore200Response {..} =
   _omitNulls
      [ "value" .= readKeyValueFromStore200ResponseValue
      ]


-- | Construct a value of type 'ReadKeyValueFromStore200Response' (by applying it's required fields, if any)
mkReadKeyValueFromStore200Response
  :: ReadKeyValueFromStore200Response
mkReadKeyValueFromStore200Response =
  ReadKeyValueFromStore200Response
  { readKeyValueFromStore200ResponseValue = Nothing
  }

-- ** RetrievePageRank200Response
-- | RetrievePageRank200Response
data RetrievePageRank200Response = RetrievePageRank200Response
  { retrievePageRank200ResponsePageRank :: !(Maybe Double) -- ^ "page_rank"
  , retrievePageRank200ResponsePosition :: !(Maybe Int) -- ^ "position"
  , retrievePageRank200ResponsePercentile :: !(Maybe Double) -- ^ "percentile"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RetrievePageRank200Response
instance A.FromJSON RetrievePageRank200Response where
  parseJSON = A.withObject "RetrievePageRank200Response" $ \o ->
    RetrievePageRank200Response
      <$> (o .:? "page_rank")
      <*> (o .:? "position")
      <*> (o .:? "percentile")

-- | ToJSON RetrievePageRank200Response
instance A.ToJSON RetrievePageRank200Response where
  toJSON RetrievePageRank200Response {..} =
   _omitNulls
      [ "page_rank" .= retrievePageRank200ResponsePageRank
      , "position" .= retrievePageRank200ResponsePosition
      , "percentile" .= retrievePageRank200ResponsePercentile
      ]


-- | Construct a value of type 'RetrievePageRank200Response' (by applying it's required fields, if any)
mkRetrievePageRank200Response
  :: RetrievePageRank200Response
mkRetrievePageRank200Response =
  RetrievePageRank200Response
  { retrievePageRank200ResponsePageRank = Nothing
  , retrievePageRank200ResponsePosition = Nothing
  , retrievePageRank200ResponsePercentile = Nothing
  }

-- ** RetrieveRecipeInformation200Response
-- | RetrieveRecipeInformation200Response
data RetrieveRecipeInformation200Response = RetrieveRecipeInformation200Response
  { retrieveRecipeInformation200ResponseId :: !(Maybe Int) -- ^ "id"
  , retrieveRecipeInformation200ResponseTitle :: !(Maybe Text) -- ^ "title"
  , retrieveRecipeInformation200ResponseServings :: !(Maybe Int) -- ^ "servings"
  , retrieveRecipeInformation200ResponseImages :: !(Maybe [Text]) -- ^ "images"
  , retrieveRecipeInformation200ResponseDietaryProperties :: !(Maybe RetrieveRecipeInformation200ResponseDietaryProperties) -- ^ "dietary_properties"
  , retrieveRecipeInformation200ResponsePricePerServing :: !(Maybe Double) -- ^ "price_per_serving"
  , retrieveRecipeInformation200ResponseTimes :: !(Maybe RetrieveRecipeInformation200ResponseTimes) -- ^ "times"
  , retrieveRecipeInformation200ResponseNutrition :: !(Maybe RetrieveRecipeInformation200ResponseNutrition) -- ^ "nutrition"
  , retrieveRecipeInformation200ResponseTaste :: !(Maybe RetrieveRecipeInformation200ResponseTaste) -- ^ "taste"
  , retrieveRecipeInformation200ResponseCuisines :: !(Maybe [Text]) -- ^ "cuisines"
  , retrieveRecipeInformation200ResponseMealTypes :: !(Maybe [Text]) -- ^ "meal_types"
  , retrieveRecipeInformation200ResponseOccasions :: !(Maybe [Text]) -- ^ "occasions"
  , retrieveRecipeInformation200ResponseIngredients :: !(Maybe [RetrieveRecipeInformation200ResponseIngredientsInner]) -- ^ "ingredients"
  , retrieveRecipeInformation200ResponseInstructions :: !(Maybe [RetrieveRecipeInformation200ResponseInstructionsInner]) -- ^ "instructions"
  , retrieveRecipeInformation200ResponseCredits :: !(Maybe RetrieveRecipeInformation200ResponseCredits) -- ^ "credits"
  , retrieveRecipeInformation200ResponseScores :: !(Maybe RetrieveRecipeInformation200ResponseScores) -- ^ "scores"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RetrieveRecipeInformation200Response
instance A.FromJSON RetrieveRecipeInformation200Response where
  parseJSON = A.withObject "RetrieveRecipeInformation200Response" $ \o ->
    RetrieveRecipeInformation200Response
      <$> (o .:? "id")
      <*> (o .:? "title")
      <*> (o .:? "servings")
      <*> (o .:? "images")
      <*> (o .:? "dietary_properties")
      <*> (o .:? "price_per_serving")
      <*> (o .:? "times")
      <*> (o .:? "nutrition")
      <*> (o .:? "taste")
      <*> (o .:? "cuisines")
      <*> (o .:? "meal_types")
      <*> (o .:? "occasions")
      <*> (o .:? "ingredients")
      <*> (o .:? "instructions")
      <*> (o .:? "credits")
      <*> (o .:? "scores")

-- | ToJSON RetrieveRecipeInformation200Response
instance A.ToJSON RetrieveRecipeInformation200Response where
  toJSON RetrieveRecipeInformation200Response {..} =
   _omitNulls
      [ "id" .= retrieveRecipeInformation200ResponseId
      , "title" .= retrieveRecipeInformation200ResponseTitle
      , "servings" .= retrieveRecipeInformation200ResponseServings
      , "images" .= retrieveRecipeInformation200ResponseImages
      , "dietary_properties" .= retrieveRecipeInformation200ResponseDietaryProperties
      , "price_per_serving" .= retrieveRecipeInformation200ResponsePricePerServing
      , "times" .= retrieveRecipeInformation200ResponseTimes
      , "nutrition" .= retrieveRecipeInformation200ResponseNutrition
      , "taste" .= retrieveRecipeInformation200ResponseTaste
      , "cuisines" .= retrieveRecipeInformation200ResponseCuisines
      , "meal_types" .= retrieveRecipeInformation200ResponseMealTypes
      , "occasions" .= retrieveRecipeInformation200ResponseOccasions
      , "ingredients" .= retrieveRecipeInformation200ResponseIngredients
      , "instructions" .= retrieveRecipeInformation200ResponseInstructions
      , "credits" .= retrieveRecipeInformation200ResponseCredits
      , "scores" .= retrieveRecipeInformation200ResponseScores
      ]


-- | Construct a value of type 'RetrieveRecipeInformation200Response' (by applying it's required fields, if any)
mkRetrieveRecipeInformation200Response
  :: RetrieveRecipeInformation200Response
mkRetrieveRecipeInformation200Response =
  RetrieveRecipeInformation200Response
  { retrieveRecipeInformation200ResponseId = Nothing
  , retrieveRecipeInformation200ResponseTitle = Nothing
  , retrieveRecipeInformation200ResponseServings = Nothing
  , retrieveRecipeInformation200ResponseImages = Nothing
  , retrieveRecipeInformation200ResponseDietaryProperties = Nothing
  , retrieveRecipeInformation200ResponsePricePerServing = Nothing
  , retrieveRecipeInformation200ResponseTimes = Nothing
  , retrieveRecipeInformation200ResponseNutrition = Nothing
  , retrieveRecipeInformation200ResponseTaste = Nothing
  , retrieveRecipeInformation200ResponseCuisines = Nothing
  , retrieveRecipeInformation200ResponseMealTypes = Nothing
  , retrieveRecipeInformation200ResponseOccasions = Nothing
  , retrieveRecipeInformation200ResponseIngredients = Nothing
  , retrieveRecipeInformation200ResponseInstructions = Nothing
  , retrieveRecipeInformation200ResponseCredits = Nothing
  , retrieveRecipeInformation200ResponseScores = Nothing
  }

-- ** RetrieveRecipeInformation200ResponseCredits
-- | RetrieveRecipeInformation200ResponseCredits
data RetrieveRecipeInformation200ResponseCredits = RetrieveRecipeInformation200ResponseCredits
  { retrieveRecipeInformation200ResponseCreditsLicense :: !(Maybe Text) -- ^ "license"
  , retrieveRecipeInformation200ResponseCreditsText :: !(Maybe Text) -- ^ "text"
  , retrieveRecipeInformation200ResponseCreditsSourceName :: !(Maybe Text) -- ^ "source_name"
  , retrieveRecipeInformation200ResponseCreditsSourceUrl :: !(Maybe Text) -- ^ "source_url"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RetrieveRecipeInformation200ResponseCredits
instance A.FromJSON RetrieveRecipeInformation200ResponseCredits where
  parseJSON = A.withObject "RetrieveRecipeInformation200ResponseCredits" $ \o ->
    RetrieveRecipeInformation200ResponseCredits
      <$> (o .:? "license")
      <*> (o .:? "text")
      <*> (o .:? "source_name")
      <*> (o .:? "source_url")

-- | ToJSON RetrieveRecipeInformation200ResponseCredits
instance A.ToJSON RetrieveRecipeInformation200ResponseCredits where
  toJSON RetrieveRecipeInformation200ResponseCredits {..} =
   _omitNulls
      [ "license" .= retrieveRecipeInformation200ResponseCreditsLicense
      , "text" .= retrieveRecipeInformation200ResponseCreditsText
      , "source_name" .= retrieveRecipeInformation200ResponseCreditsSourceName
      , "source_url" .= retrieveRecipeInformation200ResponseCreditsSourceUrl
      ]


-- | Construct a value of type 'RetrieveRecipeInformation200ResponseCredits' (by applying it's required fields, if any)
mkRetrieveRecipeInformation200ResponseCredits
  :: RetrieveRecipeInformation200ResponseCredits
mkRetrieveRecipeInformation200ResponseCredits =
  RetrieveRecipeInformation200ResponseCredits
  { retrieveRecipeInformation200ResponseCreditsLicense = Nothing
  , retrieveRecipeInformation200ResponseCreditsText = Nothing
  , retrieveRecipeInformation200ResponseCreditsSourceName = Nothing
  , retrieveRecipeInformation200ResponseCreditsSourceUrl = Nothing
  }

-- ** RetrieveRecipeInformation200ResponseDietaryProperties
-- | RetrieveRecipeInformation200ResponseDietaryProperties
data RetrieveRecipeInformation200ResponseDietaryProperties = RetrieveRecipeInformation200ResponseDietaryProperties
  { retrieveRecipeInformation200ResponseDietaryPropertiesLowFodmap :: !(Maybe Bool) -- ^ "low_fodmap"
  , retrieveRecipeInformation200ResponseDietaryPropertiesVegetarian :: !(Maybe Bool) -- ^ "vegetarian"
  , retrieveRecipeInformation200ResponseDietaryPropertiesVegan :: !(Maybe Bool) -- ^ "vegan"
  , retrieveRecipeInformation200ResponseDietaryPropertiesGlutenFree :: !(Maybe Bool) -- ^ "gluten_free"
  , retrieveRecipeInformation200ResponseDietaryPropertiesDairyFree :: !(Maybe Bool) -- ^ "dairy_free"
  , retrieveRecipeInformation200ResponseDietaryPropertiesGaps :: !(Maybe Text) -- ^ "gaps"
  , retrieveRecipeInformation200ResponseDietaryPropertiesDiets :: !(Maybe [Text]) -- ^ "diets"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RetrieveRecipeInformation200ResponseDietaryProperties
instance A.FromJSON RetrieveRecipeInformation200ResponseDietaryProperties where
  parseJSON = A.withObject "RetrieveRecipeInformation200ResponseDietaryProperties" $ \o ->
    RetrieveRecipeInformation200ResponseDietaryProperties
      <$> (o .:? "low_fodmap")
      <*> (o .:? "vegetarian")
      <*> (o .:? "vegan")
      <*> (o .:? "gluten_free")
      <*> (o .:? "dairy_free")
      <*> (o .:? "gaps")
      <*> (o .:? "diets")

-- | ToJSON RetrieveRecipeInformation200ResponseDietaryProperties
instance A.ToJSON RetrieveRecipeInformation200ResponseDietaryProperties where
  toJSON RetrieveRecipeInformation200ResponseDietaryProperties {..} =
   _omitNulls
      [ "low_fodmap" .= retrieveRecipeInformation200ResponseDietaryPropertiesLowFodmap
      , "vegetarian" .= retrieveRecipeInformation200ResponseDietaryPropertiesVegetarian
      , "vegan" .= retrieveRecipeInformation200ResponseDietaryPropertiesVegan
      , "gluten_free" .= retrieveRecipeInformation200ResponseDietaryPropertiesGlutenFree
      , "dairy_free" .= retrieveRecipeInformation200ResponseDietaryPropertiesDairyFree
      , "gaps" .= retrieveRecipeInformation200ResponseDietaryPropertiesGaps
      , "diets" .= retrieveRecipeInformation200ResponseDietaryPropertiesDiets
      ]


-- | Construct a value of type 'RetrieveRecipeInformation200ResponseDietaryProperties' (by applying it's required fields, if any)
mkRetrieveRecipeInformation200ResponseDietaryProperties
  :: RetrieveRecipeInformation200ResponseDietaryProperties
mkRetrieveRecipeInformation200ResponseDietaryProperties =
  RetrieveRecipeInformation200ResponseDietaryProperties
  { retrieveRecipeInformation200ResponseDietaryPropertiesLowFodmap = Nothing
  , retrieveRecipeInformation200ResponseDietaryPropertiesVegetarian = Nothing
  , retrieveRecipeInformation200ResponseDietaryPropertiesVegan = Nothing
  , retrieveRecipeInformation200ResponseDietaryPropertiesGlutenFree = Nothing
  , retrieveRecipeInformation200ResponseDietaryPropertiesDairyFree = Nothing
  , retrieveRecipeInformation200ResponseDietaryPropertiesGaps = Nothing
  , retrieveRecipeInformation200ResponseDietaryPropertiesDiets = Nothing
  }

-- ** RetrieveRecipeInformation200ResponseIngredientsInner
-- | RetrieveRecipeInformation200ResponseIngredientsInner
data RetrieveRecipeInformation200ResponseIngredientsInner = RetrieveRecipeInformation200ResponseIngredientsInner
  { retrieveRecipeInformation200ResponseIngredientsInnerImage :: !(Maybe Text) -- ^ "image"
  , retrieveRecipeInformation200ResponseIngredientsInnerNameClean :: !(Maybe Text) -- ^ "name_clean"
  , retrieveRecipeInformation200ResponseIngredientsInnerAmount :: !(Maybe Double) -- ^ "amount"
  , retrieveRecipeInformation200ResponseIngredientsInnerUnit :: !(Maybe Text) -- ^ "unit"
  , retrieveRecipeInformation200ResponseIngredientsInnerMeasures :: !(Maybe RetrieveRecipeInformation200ResponseIngredientsInnerMeasures) -- ^ "measures"
  , retrieveRecipeInformation200ResponseIngredientsInnerOriginal :: !(Maybe Text) -- ^ "original"
  , retrieveRecipeInformation200ResponseIngredientsInnerMeta :: !(Maybe [Text]) -- ^ "meta"
  , retrieveRecipeInformation200ResponseIngredientsInnerOriginalName :: !(Maybe Text) -- ^ "original_name"
  , retrieveRecipeInformation200ResponseIngredientsInnerName :: !(Maybe Text) -- ^ "name"
  , retrieveRecipeInformation200ResponseIngredientsInnerId :: !(Maybe Int) -- ^ "id"
  , retrieveRecipeInformation200ResponseIngredientsInnerAisle :: !(Maybe Text) -- ^ "aisle"
  , retrieveRecipeInformation200ResponseIngredientsInnerConsistency :: !(Maybe Text) -- ^ "consistency"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RetrieveRecipeInformation200ResponseIngredientsInner
instance A.FromJSON RetrieveRecipeInformation200ResponseIngredientsInner where
  parseJSON = A.withObject "RetrieveRecipeInformation200ResponseIngredientsInner" $ \o ->
    RetrieveRecipeInformation200ResponseIngredientsInner
      <$> (o .:? "image")
      <*> (o .:? "name_clean")
      <*> (o .:? "amount")
      <*> (o .:? "unit")
      <*> (o .:? "measures")
      <*> (o .:? "original")
      <*> (o .:? "meta")
      <*> (o .:? "original_name")
      <*> (o .:? "name")
      <*> (o .:? "id")
      <*> (o .:? "aisle")
      <*> (o .:? "consistency")

-- | ToJSON RetrieveRecipeInformation200ResponseIngredientsInner
instance A.ToJSON RetrieveRecipeInformation200ResponseIngredientsInner where
  toJSON RetrieveRecipeInformation200ResponseIngredientsInner {..} =
   _omitNulls
      [ "image" .= retrieveRecipeInformation200ResponseIngredientsInnerImage
      , "name_clean" .= retrieveRecipeInformation200ResponseIngredientsInnerNameClean
      , "amount" .= retrieveRecipeInformation200ResponseIngredientsInnerAmount
      , "unit" .= retrieveRecipeInformation200ResponseIngredientsInnerUnit
      , "measures" .= retrieveRecipeInformation200ResponseIngredientsInnerMeasures
      , "original" .= retrieveRecipeInformation200ResponseIngredientsInnerOriginal
      , "meta" .= retrieveRecipeInformation200ResponseIngredientsInnerMeta
      , "original_name" .= retrieveRecipeInformation200ResponseIngredientsInnerOriginalName
      , "name" .= retrieveRecipeInformation200ResponseIngredientsInnerName
      , "id" .= retrieveRecipeInformation200ResponseIngredientsInnerId
      , "aisle" .= retrieveRecipeInformation200ResponseIngredientsInnerAisle
      , "consistency" .= retrieveRecipeInformation200ResponseIngredientsInnerConsistency
      ]


-- | Construct a value of type 'RetrieveRecipeInformation200ResponseIngredientsInner' (by applying it's required fields, if any)
mkRetrieveRecipeInformation200ResponseIngredientsInner
  :: RetrieveRecipeInformation200ResponseIngredientsInner
mkRetrieveRecipeInformation200ResponseIngredientsInner =
  RetrieveRecipeInformation200ResponseIngredientsInner
  { retrieveRecipeInformation200ResponseIngredientsInnerImage = Nothing
  , retrieveRecipeInformation200ResponseIngredientsInnerNameClean = Nothing
  , retrieveRecipeInformation200ResponseIngredientsInnerAmount = Nothing
  , retrieveRecipeInformation200ResponseIngredientsInnerUnit = Nothing
  , retrieveRecipeInformation200ResponseIngredientsInnerMeasures = Nothing
  , retrieveRecipeInformation200ResponseIngredientsInnerOriginal = Nothing
  , retrieveRecipeInformation200ResponseIngredientsInnerMeta = Nothing
  , retrieveRecipeInformation200ResponseIngredientsInnerOriginalName = Nothing
  , retrieveRecipeInformation200ResponseIngredientsInnerName = Nothing
  , retrieveRecipeInformation200ResponseIngredientsInnerId = Nothing
  , retrieveRecipeInformation200ResponseIngredientsInnerAisle = Nothing
  , retrieveRecipeInformation200ResponseIngredientsInnerConsistency = Nothing
  }

-- ** RetrieveRecipeInformation200ResponseIngredientsInnerMeasures
-- | RetrieveRecipeInformation200ResponseIngredientsInnerMeasures
data RetrieveRecipeInformation200ResponseIngredientsInnerMeasures = RetrieveRecipeInformation200ResponseIngredientsInnerMeasures
  { retrieveRecipeInformation200ResponseIngredientsInnerMeasuresMetric :: !(Maybe SearchDrinks200ResponseDrinksInnerIngredientsInnerMeasuresMetric) -- ^ "metric"
  , retrieveRecipeInformation200ResponseIngredientsInnerMeasuresUs :: !(Maybe SearchDrinks200ResponseDrinksInnerIngredientsInnerMeasuresMetric) -- ^ "us"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RetrieveRecipeInformation200ResponseIngredientsInnerMeasures
instance A.FromJSON RetrieveRecipeInformation200ResponseIngredientsInnerMeasures where
  parseJSON = A.withObject "RetrieveRecipeInformation200ResponseIngredientsInnerMeasures" $ \o ->
    RetrieveRecipeInformation200ResponseIngredientsInnerMeasures
      <$> (o .:? "metric")
      <*> (o .:? "us")

-- | ToJSON RetrieveRecipeInformation200ResponseIngredientsInnerMeasures
instance A.ToJSON RetrieveRecipeInformation200ResponseIngredientsInnerMeasures where
  toJSON RetrieveRecipeInformation200ResponseIngredientsInnerMeasures {..} =
   _omitNulls
      [ "metric" .= retrieveRecipeInformation200ResponseIngredientsInnerMeasuresMetric
      , "us" .= retrieveRecipeInformation200ResponseIngredientsInnerMeasuresUs
      ]


-- | Construct a value of type 'RetrieveRecipeInformation200ResponseIngredientsInnerMeasures' (by applying it's required fields, if any)
mkRetrieveRecipeInformation200ResponseIngredientsInnerMeasures
  :: RetrieveRecipeInformation200ResponseIngredientsInnerMeasures
mkRetrieveRecipeInformation200ResponseIngredientsInnerMeasures =
  RetrieveRecipeInformation200ResponseIngredientsInnerMeasures
  { retrieveRecipeInformation200ResponseIngredientsInnerMeasuresMetric = Nothing
  , retrieveRecipeInformation200ResponseIngredientsInnerMeasuresUs = Nothing
  }

-- ** RetrieveRecipeInformation200ResponseInstructionsInner
-- | RetrieveRecipeInformation200ResponseInstructionsInner
data RetrieveRecipeInformation200ResponseInstructionsInner = RetrieveRecipeInformation200ResponseInstructionsInner
  { retrieveRecipeInformation200ResponseInstructionsInnerName :: !(Maybe Text) -- ^ "name"
  , retrieveRecipeInformation200ResponseInstructionsInnerSteps :: !(Maybe [RetrieveRecipeInformation200ResponseInstructionsInnerStepsInner]) -- ^ "steps"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RetrieveRecipeInformation200ResponseInstructionsInner
instance A.FromJSON RetrieveRecipeInformation200ResponseInstructionsInner where
  parseJSON = A.withObject "RetrieveRecipeInformation200ResponseInstructionsInner" $ \o ->
    RetrieveRecipeInformation200ResponseInstructionsInner
      <$> (o .:? "name")
      <*> (o .:? "steps")

-- | ToJSON RetrieveRecipeInformation200ResponseInstructionsInner
instance A.ToJSON RetrieveRecipeInformation200ResponseInstructionsInner where
  toJSON RetrieveRecipeInformation200ResponseInstructionsInner {..} =
   _omitNulls
      [ "name" .= retrieveRecipeInformation200ResponseInstructionsInnerName
      , "steps" .= retrieveRecipeInformation200ResponseInstructionsInnerSteps
      ]


-- | Construct a value of type 'RetrieveRecipeInformation200ResponseInstructionsInner' (by applying it's required fields, if any)
mkRetrieveRecipeInformation200ResponseInstructionsInner
  :: RetrieveRecipeInformation200ResponseInstructionsInner
mkRetrieveRecipeInformation200ResponseInstructionsInner =
  RetrieveRecipeInformation200ResponseInstructionsInner
  { retrieveRecipeInformation200ResponseInstructionsInnerName = Nothing
  , retrieveRecipeInformation200ResponseInstructionsInnerSteps = Nothing
  }

-- ** RetrieveRecipeInformation200ResponseInstructionsInnerStepsInner
-- | RetrieveRecipeInformation200ResponseInstructionsInnerStepsInner
data RetrieveRecipeInformation200ResponseInstructionsInnerStepsInner = RetrieveRecipeInformation200ResponseInstructionsInnerStepsInner
  { retrieveRecipeInformation200ResponseInstructionsInnerStepsInnerNumber :: !(Maybe Int) -- ^ "number"
  , retrieveRecipeInformation200ResponseInstructionsInnerStepsInnerIngredients :: !(Maybe [SearchDrinks200ResponseDrinksInnerInstructionsInnerStepsInnerIngredientsInner]) -- ^ "ingredients"
  , retrieveRecipeInformation200ResponseInstructionsInnerStepsInnerEquipment :: !(Maybe [SearchDrinks200ResponseDrinksInnerInstructionsInnerStepsInnerIngredientsInner]) -- ^ "equipment"
  , retrieveRecipeInformation200ResponseInstructionsInnerStepsInnerStep :: !(Maybe Text) -- ^ "step"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RetrieveRecipeInformation200ResponseInstructionsInnerStepsInner
instance A.FromJSON RetrieveRecipeInformation200ResponseInstructionsInnerStepsInner where
  parseJSON = A.withObject "RetrieveRecipeInformation200ResponseInstructionsInnerStepsInner" $ \o ->
    RetrieveRecipeInformation200ResponseInstructionsInnerStepsInner
      <$> (o .:? "number")
      <*> (o .:? "ingredients")
      <*> (o .:? "equipment")
      <*> (o .:? "step")

-- | ToJSON RetrieveRecipeInformation200ResponseInstructionsInnerStepsInner
instance A.ToJSON RetrieveRecipeInformation200ResponseInstructionsInnerStepsInner where
  toJSON RetrieveRecipeInformation200ResponseInstructionsInnerStepsInner {..} =
   _omitNulls
      [ "number" .= retrieveRecipeInformation200ResponseInstructionsInnerStepsInnerNumber
      , "ingredients" .= retrieveRecipeInformation200ResponseInstructionsInnerStepsInnerIngredients
      , "equipment" .= retrieveRecipeInformation200ResponseInstructionsInnerStepsInnerEquipment
      , "step" .= retrieveRecipeInformation200ResponseInstructionsInnerStepsInnerStep
      ]


-- | Construct a value of type 'RetrieveRecipeInformation200ResponseInstructionsInnerStepsInner' (by applying it's required fields, if any)
mkRetrieveRecipeInformation200ResponseInstructionsInnerStepsInner
  :: RetrieveRecipeInformation200ResponseInstructionsInnerStepsInner
mkRetrieveRecipeInformation200ResponseInstructionsInnerStepsInner =
  RetrieveRecipeInformation200ResponseInstructionsInnerStepsInner
  { retrieveRecipeInformation200ResponseInstructionsInnerStepsInnerNumber = Nothing
  , retrieveRecipeInformation200ResponseInstructionsInnerStepsInnerIngredients = Nothing
  , retrieveRecipeInformation200ResponseInstructionsInnerStepsInnerEquipment = Nothing
  , retrieveRecipeInformation200ResponseInstructionsInnerStepsInnerStep = Nothing
  }

-- ** RetrieveRecipeInformation200ResponseNutrition
-- | RetrieveRecipeInformation200ResponseNutrition
data RetrieveRecipeInformation200ResponseNutrition = RetrieveRecipeInformation200ResponseNutrition
  { retrieveRecipeInformation200ResponseNutritionWeightPerServing :: !(Maybe SearchDrinks200ResponseDrinksInnerNutritionWeightPerServing) -- ^ "weight_per_serving"
  , retrieveRecipeInformation200ResponseNutritionCaloricBreakdown :: !(Maybe SearchDrinks200ResponseDrinksInnerNutritionCaloricBreakdown) -- ^ "caloric_breakdown"
  , retrieveRecipeInformation200ResponseNutritionFlavonoids :: !(Maybe [SearchDrinks200ResponseDrinksInnerNutritionFlavonoidsInner]) -- ^ "flavonoids"
  , retrieveRecipeInformation200ResponseNutritionIngredientBreakdown :: !(Maybe [RetrieveRecipeInformation200ResponseNutritionIngredientBreakdownInner]) -- ^ "ingredient_breakdown"
  , retrieveRecipeInformation200ResponseNutritionProperties :: !(Maybe [SearchRecipes200ResponseRecipesInnerNutritionNutrientsInner]) -- ^ "properties"
  , retrieveRecipeInformation200ResponseNutritionNutrients :: !(Maybe [SearchDrinks200ResponseDrinksInnerNutritionNutrientsInner]) -- ^ "nutrients"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RetrieveRecipeInformation200ResponseNutrition
instance A.FromJSON RetrieveRecipeInformation200ResponseNutrition where
  parseJSON = A.withObject "RetrieveRecipeInformation200ResponseNutrition" $ \o ->
    RetrieveRecipeInformation200ResponseNutrition
      <$> (o .:? "weight_per_serving")
      <*> (o .:? "caloric_breakdown")
      <*> (o .:? "flavonoids")
      <*> (o .:? "ingredient_breakdown")
      <*> (o .:? "properties")
      <*> (o .:? "nutrients")

-- | ToJSON RetrieveRecipeInformation200ResponseNutrition
instance A.ToJSON RetrieveRecipeInformation200ResponseNutrition where
  toJSON RetrieveRecipeInformation200ResponseNutrition {..} =
   _omitNulls
      [ "weight_per_serving" .= retrieveRecipeInformation200ResponseNutritionWeightPerServing
      , "caloric_breakdown" .= retrieveRecipeInformation200ResponseNutritionCaloricBreakdown
      , "flavonoids" .= retrieveRecipeInformation200ResponseNutritionFlavonoids
      , "ingredient_breakdown" .= retrieveRecipeInformation200ResponseNutritionIngredientBreakdown
      , "properties" .= retrieveRecipeInformation200ResponseNutritionProperties
      , "nutrients" .= retrieveRecipeInformation200ResponseNutritionNutrients
      ]


-- | Construct a value of type 'RetrieveRecipeInformation200ResponseNutrition' (by applying it's required fields, if any)
mkRetrieveRecipeInformation200ResponseNutrition
  :: RetrieveRecipeInformation200ResponseNutrition
mkRetrieveRecipeInformation200ResponseNutrition =
  RetrieveRecipeInformation200ResponseNutrition
  { retrieveRecipeInformation200ResponseNutritionWeightPerServing = Nothing
  , retrieveRecipeInformation200ResponseNutritionCaloricBreakdown = Nothing
  , retrieveRecipeInformation200ResponseNutritionFlavonoids = Nothing
  , retrieveRecipeInformation200ResponseNutritionIngredientBreakdown = Nothing
  , retrieveRecipeInformation200ResponseNutritionProperties = Nothing
  , retrieveRecipeInformation200ResponseNutritionNutrients = Nothing
  }

-- ** RetrieveRecipeInformation200ResponseNutritionIngredientBreakdownInner
-- | RetrieveRecipeInformation200ResponseNutritionIngredientBreakdownInner
data RetrieveRecipeInformation200ResponseNutritionIngredientBreakdownInner = RetrieveRecipeInformation200ResponseNutritionIngredientBreakdownInner
  { retrieveRecipeInformation200ResponseNutritionIngredientBreakdownInnerName :: !(Maybe Text) -- ^ "name"
  , retrieveRecipeInformation200ResponseNutritionIngredientBreakdownInnerAmount :: !(Maybe Double) -- ^ "amount"
  , retrieveRecipeInformation200ResponseNutritionIngredientBreakdownInnerUnit :: !(Maybe Text) -- ^ "unit"
  , retrieveRecipeInformation200ResponseNutritionIngredientBreakdownInnerId :: !(Maybe Int) -- ^ "id"
  , retrieveRecipeInformation200ResponseNutritionIngredientBreakdownInnerNutrients :: !(Maybe [SearchDrinks200ResponseDrinksInnerNutritionNutrientsInner]) -- ^ "nutrients"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RetrieveRecipeInformation200ResponseNutritionIngredientBreakdownInner
instance A.FromJSON RetrieveRecipeInformation200ResponseNutritionIngredientBreakdownInner where
  parseJSON = A.withObject "RetrieveRecipeInformation200ResponseNutritionIngredientBreakdownInner" $ \o ->
    RetrieveRecipeInformation200ResponseNutritionIngredientBreakdownInner
      <$> (o .:? "name")
      <*> (o .:? "amount")
      <*> (o .:? "unit")
      <*> (o .:? "id")
      <*> (o .:? "nutrients")

-- | ToJSON RetrieveRecipeInformation200ResponseNutritionIngredientBreakdownInner
instance A.ToJSON RetrieveRecipeInformation200ResponseNutritionIngredientBreakdownInner where
  toJSON RetrieveRecipeInformation200ResponseNutritionIngredientBreakdownInner {..} =
   _omitNulls
      [ "name" .= retrieveRecipeInformation200ResponseNutritionIngredientBreakdownInnerName
      , "amount" .= retrieveRecipeInformation200ResponseNutritionIngredientBreakdownInnerAmount
      , "unit" .= retrieveRecipeInformation200ResponseNutritionIngredientBreakdownInnerUnit
      , "id" .= retrieveRecipeInformation200ResponseNutritionIngredientBreakdownInnerId
      , "nutrients" .= retrieveRecipeInformation200ResponseNutritionIngredientBreakdownInnerNutrients
      ]


-- | Construct a value of type 'RetrieveRecipeInformation200ResponseNutritionIngredientBreakdownInner' (by applying it's required fields, if any)
mkRetrieveRecipeInformation200ResponseNutritionIngredientBreakdownInner
  :: RetrieveRecipeInformation200ResponseNutritionIngredientBreakdownInner
mkRetrieveRecipeInformation200ResponseNutritionIngredientBreakdownInner =
  RetrieveRecipeInformation200ResponseNutritionIngredientBreakdownInner
  { retrieveRecipeInformation200ResponseNutritionIngredientBreakdownInnerName = Nothing
  , retrieveRecipeInformation200ResponseNutritionIngredientBreakdownInnerAmount = Nothing
  , retrieveRecipeInformation200ResponseNutritionIngredientBreakdownInnerUnit = Nothing
  , retrieveRecipeInformation200ResponseNutritionIngredientBreakdownInnerId = Nothing
  , retrieveRecipeInformation200ResponseNutritionIngredientBreakdownInnerNutrients = Nothing
  }

-- ** RetrieveRecipeInformation200ResponseScores
-- | RetrieveRecipeInformation200ResponseScores
data RetrieveRecipeInformation200ResponseScores = RetrieveRecipeInformation200ResponseScores
  { retrieveRecipeInformation200ResponseScoresMetaScore :: !(Maybe Double) -- ^ "meta_score"
  , retrieveRecipeInformation200ResponseScoresWeightWatcherSmartPoints :: !(Maybe Int) -- ^ "weight_watcher_smart_points"
  , retrieveRecipeInformation200ResponseScoresHealthScore :: !(Maybe Int) -- ^ "health_score"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RetrieveRecipeInformation200ResponseScores
instance A.FromJSON RetrieveRecipeInformation200ResponseScores where
  parseJSON = A.withObject "RetrieveRecipeInformation200ResponseScores" $ \o ->
    RetrieveRecipeInformation200ResponseScores
      <$> (o .:? "meta_score")
      <*> (o .:? "weight_watcher_smart_points")
      <*> (o .:? "health_score")

-- | ToJSON RetrieveRecipeInformation200ResponseScores
instance A.ToJSON RetrieveRecipeInformation200ResponseScores where
  toJSON RetrieveRecipeInformation200ResponseScores {..} =
   _omitNulls
      [ "meta_score" .= retrieveRecipeInformation200ResponseScoresMetaScore
      , "weight_watcher_smart_points" .= retrieveRecipeInformation200ResponseScoresWeightWatcherSmartPoints
      , "health_score" .= retrieveRecipeInformation200ResponseScoresHealthScore
      ]


-- | Construct a value of type 'RetrieveRecipeInformation200ResponseScores' (by applying it's required fields, if any)
mkRetrieveRecipeInformation200ResponseScores
  :: RetrieveRecipeInformation200ResponseScores
mkRetrieveRecipeInformation200ResponseScores =
  RetrieveRecipeInformation200ResponseScores
  { retrieveRecipeInformation200ResponseScoresMetaScore = Nothing
  , retrieveRecipeInformation200ResponseScoresWeightWatcherSmartPoints = Nothing
  , retrieveRecipeInformation200ResponseScoresHealthScore = Nothing
  }

-- ** RetrieveRecipeInformation200ResponseTaste
-- | RetrieveRecipeInformation200ResponseTaste
data RetrieveRecipeInformation200ResponseTaste = RetrieveRecipeInformation200ResponseTaste
  { retrieveRecipeInformation200ResponseTasteFattiness :: !(Maybe Double) -- ^ "fattiness"
  , retrieveRecipeInformation200ResponseTasteSpiciness :: !(Maybe Int) -- ^ "spiciness"
  , retrieveRecipeInformation200ResponseTasteSaltiness :: !(Maybe Int) -- ^ "saltiness"
  , retrieveRecipeInformation200ResponseTasteBitterness :: !(Maybe Double) -- ^ "bitterness"
  , retrieveRecipeInformation200ResponseTasteSavoriness :: !(Maybe Double) -- ^ "savoriness"
  , retrieveRecipeInformation200ResponseTasteSweetness :: !(Maybe Double) -- ^ "sweetness"
  , retrieveRecipeInformation200ResponseTasteSourness :: !(Maybe Double) -- ^ "sourness"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RetrieveRecipeInformation200ResponseTaste
instance A.FromJSON RetrieveRecipeInformation200ResponseTaste where
  parseJSON = A.withObject "RetrieveRecipeInformation200ResponseTaste" $ \o ->
    RetrieveRecipeInformation200ResponseTaste
      <$> (o .:? "fattiness")
      <*> (o .:? "spiciness")
      <*> (o .:? "saltiness")
      <*> (o .:? "bitterness")
      <*> (o .:? "savoriness")
      <*> (o .:? "sweetness")
      <*> (o .:? "sourness")

-- | ToJSON RetrieveRecipeInformation200ResponseTaste
instance A.ToJSON RetrieveRecipeInformation200ResponseTaste where
  toJSON RetrieveRecipeInformation200ResponseTaste {..} =
   _omitNulls
      [ "fattiness" .= retrieveRecipeInformation200ResponseTasteFattiness
      , "spiciness" .= retrieveRecipeInformation200ResponseTasteSpiciness
      , "saltiness" .= retrieveRecipeInformation200ResponseTasteSaltiness
      , "bitterness" .= retrieveRecipeInformation200ResponseTasteBitterness
      , "savoriness" .= retrieveRecipeInformation200ResponseTasteSavoriness
      , "sweetness" .= retrieveRecipeInformation200ResponseTasteSweetness
      , "sourness" .= retrieveRecipeInformation200ResponseTasteSourness
      ]


-- | Construct a value of type 'RetrieveRecipeInformation200ResponseTaste' (by applying it's required fields, if any)
mkRetrieveRecipeInformation200ResponseTaste
  :: RetrieveRecipeInformation200ResponseTaste
mkRetrieveRecipeInformation200ResponseTaste =
  RetrieveRecipeInformation200ResponseTaste
  { retrieveRecipeInformation200ResponseTasteFattiness = Nothing
  , retrieveRecipeInformation200ResponseTasteSpiciness = Nothing
  , retrieveRecipeInformation200ResponseTasteSaltiness = Nothing
  , retrieveRecipeInformation200ResponseTasteBitterness = Nothing
  , retrieveRecipeInformation200ResponseTasteSavoriness = Nothing
  , retrieveRecipeInformation200ResponseTasteSweetness = Nothing
  , retrieveRecipeInformation200ResponseTasteSourness = Nothing
  }

-- ** RetrieveRecipeInformation200ResponseTimes
-- | RetrieveRecipeInformation200ResponseTimes
data RetrieveRecipeInformation200ResponseTimes = RetrieveRecipeInformation200ResponseTimes
  { retrieveRecipeInformation200ResponseTimesTotalMinutes :: !(Maybe Int) -- ^ "total_minutes"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RetrieveRecipeInformation200ResponseTimes
instance A.FromJSON RetrieveRecipeInformation200ResponseTimes where
  parseJSON = A.withObject "RetrieveRecipeInformation200ResponseTimes" $ \o ->
    RetrieveRecipeInformation200ResponseTimes
      <$> (o .:? "total_minutes")

-- | ToJSON RetrieveRecipeInformation200ResponseTimes
instance A.ToJSON RetrieveRecipeInformation200ResponseTimes where
  toJSON RetrieveRecipeInformation200ResponseTimes {..} =
   _omitNulls
      [ "total_minutes" .= retrieveRecipeInformation200ResponseTimesTotalMinutes
      ]


-- | Construct a value of type 'RetrieveRecipeInformation200ResponseTimes' (by applying it's required fields, if any)
mkRetrieveRecipeInformation200ResponseTimes
  :: RetrieveRecipeInformation200ResponseTimes
mkRetrieveRecipeInformation200ResponseTimes =
  RetrieveRecipeInformation200ResponseTimes
  { retrieveRecipeInformation200ResponseTimesTotalMinutes = Nothing
  }

-- ** ScoreReadability200Response
-- | ScoreReadability200Response
data ScoreReadability200Response = ScoreReadability200Response
  { scoreReadability200ResponseReadability :: !(Maybe ScoreText200ResponseReadability) -- ^ "readability"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ScoreReadability200Response
instance A.FromJSON ScoreReadability200Response where
  parseJSON = A.withObject "ScoreReadability200Response" $ \o ->
    ScoreReadability200Response
      <$> (o .:? "readability")

-- | ToJSON ScoreReadability200Response
instance A.ToJSON ScoreReadability200Response where
  toJSON ScoreReadability200Response {..} =
   _omitNulls
      [ "readability" .= scoreReadability200ResponseReadability
      ]


-- | Construct a value of type 'ScoreReadability200Response' (by applying it's required fields, if any)
mkScoreReadability200Response
  :: ScoreReadability200Response
mkScoreReadability200Response =
  ScoreReadability200Response
  { scoreReadability200ResponseReadability = Nothing
  }

-- ** ScoreText200Response
-- | ScoreText200Response
data ScoreText200Response = ScoreText200Response
  { scoreText200ResponseNumberOfWords :: !(Maybe Int) -- ^ "number_of_words"
  , scoreText200ResponseNumberOfSentences :: !(Maybe Int) -- ^ "number_of_sentences"
  , scoreText200ResponseReadability :: !(Maybe ScoreText200ResponseReadability) -- ^ "readability"
  , scoreText200ResponseSkimmability :: !(Maybe ScoreText200ResponseSkimmability) -- ^ "skimmability"
  , scoreText200ResponseInterestingness :: !(Maybe ScoreText200ResponseInterestingness) -- ^ "interestingness"
  , scoreText200ResponseStyle :: !(Maybe ScoreText200ResponseStyle) -- ^ "style"
  , scoreText200ResponseTotalScore :: !(Maybe Double) -- ^ "total_score"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ScoreText200Response
instance A.FromJSON ScoreText200Response where
  parseJSON = A.withObject "ScoreText200Response" $ \o ->
    ScoreText200Response
      <$> (o .:? "number_of_words")
      <*> (o .:? "number_of_sentences")
      <*> (o .:? "readability")
      <*> (o .:? "skimmability")
      <*> (o .:? "interestingness")
      <*> (o .:? "style")
      <*> (o .:? "total_score")

-- | ToJSON ScoreText200Response
instance A.ToJSON ScoreText200Response where
  toJSON ScoreText200Response {..} =
   _omitNulls
      [ "number_of_words" .= scoreText200ResponseNumberOfWords
      , "number_of_sentences" .= scoreText200ResponseNumberOfSentences
      , "readability" .= scoreText200ResponseReadability
      , "skimmability" .= scoreText200ResponseSkimmability
      , "interestingness" .= scoreText200ResponseInterestingness
      , "style" .= scoreText200ResponseStyle
      , "total_score" .= scoreText200ResponseTotalScore
      ]


-- | Construct a value of type 'ScoreText200Response' (by applying it's required fields, if any)
mkScoreText200Response
  :: ScoreText200Response
mkScoreText200Response =
  ScoreText200Response
  { scoreText200ResponseNumberOfWords = Nothing
  , scoreText200ResponseNumberOfSentences = Nothing
  , scoreText200ResponseReadability = Nothing
  , scoreText200ResponseSkimmability = Nothing
  , scoreText200ResponseInterestingness = Nothing
  , scoreText200ResponseStyle = Nothing
  , scoreText200ResponseTotalScore = Nothing
  }

-- ** ScoreText200ResponseInterestingness
-- | ScoreText200ResponseInterestingness
data ScoreText200ResponseInterestingness = ScoreText200ResponseInterestingness
  { scoreText200ResponseInterestingnessMainscores :: !(Maybe ScoreText200ResponseSkimmabilityMainscores) -- ^ "mainscores"
  , scoreText200ResponseInterestingnessSubscores :: !(Maybe ScoreText200ResponseInterestingnessSubscores) -- ^ "subscores"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ScoreText200ResponseInterestingness
instance A.FromJSON ScoreText200ResponseInterestingness where
  parseJSON = A.withObject "ScoreText200ResponseInterestingness" $ \o ->
    ScoreText200ResponseInterestingness
      <$> (o .:? "mainscores")
      <*> (o .:? "subscores")

-- | ToJSON ScoreText200ResponseInterestingness
instance A.ToJSON ScoreText200ResponseInterestingness where
  toJSON ScoreText200ResponseInterestingness {..} =
   _omitNulls
      [ "mainscores" .= scoreText200ResponseInterestingnessMainscores
      , "subscores" .= scoreText200ResponseInterestingnessSubscores
      ]


-- | Construct a value of type 'ScoreText200ResponseInterestingness' (by applying it's required fields, if any)
mkScoreText200ResponseInterestingness
  :: ScoreText200ResponseInterestingness
mkScoreText200ResponseInterestingness =
  ScoreText200ResponseInterestingness
  { scoreText200ResponseInterestingnessMainscores = Nothing
  , scoreText200ResponseInterestingnessSubscores = Nothing
  }

-- ** ScoreText200ResponseInterestingnessSubscores
-- | ScoreText200ResponseInterestingnessSubscores
data ScoreText200ResponseInterestingnessSubscores = ScoreText200ResponseInterestingnessSubscores
  { scoreText200ResponseInterestingnessSubscoresTitleRatingScore :: !(Maybe [Int]) -- ^ "title_rating_score"
  , scoreText200ResponseInterestingnessSubscoresQuoteScore :: !(Maybe [Int]) -- ^ "quote_score"
  , scoreText200ResponseInterestingnessSubscoresLengthScore :: !(Maybe [Int]) -- ^ "length_score"
  , scoreText200ResponseInterestingnessSubscoresLinkScore :: !(Maybe [Int]) -- ^ "link_score"
  , scoreText200ResponseInterestingnessSubscoresGoogleHitsScore :: !(Maybe [Int]) -- ^ "google_hits_score"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ScoreText200ResponseInterestingnessSubscores
instance A.FromJSON ScoreText200ResponseInterestingnessSubscores where
  parseJSON = A.withObject "ScoreText200ResponseInterestingnessSubscores" $ \o ->
    ScoreText200ResponseInterestingnessSubscores
      <$> (o .:? "title_rating_score")
      <*> (o .:? "quote_score")
      <*> (o .:? "length_score")
      <*> (o .:? "link_score")
      <*> (o .:? "google_hits_score")

-- | ToJSON ScoreText200ResponseInterestingnessSubscores
instance A.ToJSON ScoreText200ResponseInterestingnessSubscores where
  toJSON ScoreText200ResponseInterestingnessSubscores {..} =
   _omitNulls
      [ "title_rating_score" .= scoreText200ResponseInterestingnessSubscoresTitleRatingScore
      , "quote_score" .= scoreText200ResponseInterestingnessSubscoresQuoteScore
      , "length_score" .= scoreText200ResponseInterestingnessSubscoresLengthScore
      , "link_score" .= scoreText200ResponseInterestingnessSubscoresLinkScore
      , "google_hits_score" .= scoreText200ResponseInterestingnessSubscoresGoogleHitsScore
      ]


-- | Construct a value of type 'ScoreText200ResponseInterestingnessSubscores' (by applying it's required fields, if any)
mkScoreText200ResponseInterestingnessSubscores
  :: ScoreText200ResponseInterestingnessSubscores
mkScoreText200ResponseInterestingnessSubscores =
  ScoreText200ResponseInterestingnessSubscores
  { scoreText200ResponseInterestingnessSubscoresTitleRatingScore = Nothing
  , scoreText200ResponseInterestingnessSubscoresQuoteScore = Nothing
  , scoreText200ResponseInterestingnessSubscoresLengthScore = Nothing
  , scoreText200ResponseInterestingnessSubscoresLinkScore = Nothing
  , scoreText200ResponseInterestingnessSubscoresGoogleHitsScore = Nothing
  }

-- ** ScoreText200ResponseReadability
-- | ScoreText200ResponseReadability
data ScoreText200ResponseReadability = ScoreText200ResponseReadability
  { scoreText200ResponseReadabilityMainscores :: !(Maybe ScoreText200ResponseReadabilityMainscores) -- ^ "mainscores"
  , scoreText200ResponseReadabilitySubscores :: !(Maybe ScoreText200ResponseReadabilitySubscores) -- ^ "subscores"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ScoreText200ResponseReadability
instance A.FromJSON ScoreText200ResponseReadability where
  parseJSON = A.withObject "ScoreText200ResponseReadability" $ \o ->
    ScoreText200ResponseReadability
      <$> (o .:? "mainscores")
      <*> (o .:? "subscores")

-- | ToJSON ScoreText200ResponseReadability
instance A.ToJSON ScoreText200ResponseReadability where
  toJSON ScoreText200ResponseReadability {..} =
   _omitNulls
      [ "mainscores" .= scoreText200ResponseReadabilityMainscores
      , "subscores" .= scoreText200ResponseReadabilitySubscores
      ]


-- | Construct a value of type 'ScoreText200ResponseReadability' (by applying it's required fields, if any)
mkScoreText200ResponseReadability
  :: ScoreText200ResponseReadability
mkScoreText200ResponseReadability =
  ScoreText200ResponseReadability
  { scoreText200ResponseReadabilityMainscores = Nothing
  , scoreText200ResponseReadabilitySubscores = Nothing
  }

-- ** ScoreText200ResponseReadabilityMainscores
-- | ScoreText200ResponseReadabilityMainscores
data ScoreText200ResponseReadabilityMainscores = ScoreText200ResponseReadabilityMainscores
  { scoreText200ResponseReadabilityMainscoresTotalPossible :: !(Maybe Int) -- ^ "total_possible"
  , scoreText200ResponseReadabilityMainscoresTotal :: !(Maybe Int) -- ^ "total"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ScoreText200ResponseReadabilityMainscores
instance A.FromJSON ScoreText200ResponseReadabilityMainscores where
  parseJSON = A.withObject "ScoreText200ResponseReadabilityMainscores" $ \o ->
    ScoreText200ResponseReadabilityMainscores
      <$> (o .:? "total_possible")
      <*> (o .:? "total")

-- | ToJSON ScoreText200ResponseReadabilityMainscores
instance A.ToJSON ScoreText200ResponseReadabilityMainscores where
  toJSON ScoreText200ResponseReadabilityMainscores {..} =
   _omitNulls
      [ "total_possible" .= scoreText200ResponseReadabilityMainscoresTotalPossible
      , "total" .= scoreText200ResponseReadabilityMainscoresTotal
      ]


-- | Construct a value of type 'ScoreText200ResponseReadabilityMainscores' (by applying it's required fields, if any)
mkScoreText200ResponseReadabilityMainscores
  :: ScoreText200ResponseReadabilityMainscores
mkScoreText200ResponseReadabilityMainscores =
  ScoreText200ResponseReadabilityMainscores
  { scoreText200ResponseReadabilityMainscoresTotalPossible = Nothing
  , scoreText200ResponseReadabilityMainscoresTotal = Nothing
  }

-- ** ScoreText200ResponseReadabilitySubscores
-- | ScoreText200ResponseReadabilitySubscores
data ScoreText200ResponseReadabilitySubscores = ScoreText200ResponseReadabilitySubscores
  { scoreText200ResponseReadabilitySubscoresReadingTimeSeconds :: !(Maybe Int) -- ^ "reading_time_seconds"
  , scoreText200ResponseReadabilitySubscoresForcast :: !(Maybe Double) -- ^ "forcast"
  , scoreText200ResponseReadabilitySubscoresFlesch :: !(Maybe Double) -- ^ "flesch"
  , scoreText200ResponseReadabilitySubscoresSmog :: !(Maybe Double) -- ^ "smog"
  , scoreText200ResponseReadabilitySubscoresAri :: !(Maybe Double) -- ^ "ari"
  , scoreText200ResponseReadabilitySubscoresLix :: !(Maybe Double) -- ^ "lix"
  , scoreText200ResponseReadabilitySubscoresColemanLiau :: !(Maybe Double) -- ^ "coleman_liau"
  , scoreText200ResponseReadabilitySubscoresKincaid :: !(Maybe Double) -- ^ "kincaid"
  , scoreText200ResponseReadabilitySubscoresFog :: !(Maybe Double) -- ^ "fog"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ScoreText200ResponseReadabilitySubscores
instance A.FromJSON ScoreText200ResponseReadabilitySubscores where
  parseJSON = A.withObject "ScoreText200ResponseReadabilitySubscores" $ \o ->
    ScoreText200ResponseReadabilitySubscores
      <$> (o .:? "reading_time_seconds")
      <*> (o .:? "forcast")
      <*> (o .:? "flesch")
      <*> (o .:? "smog")
      <*> (o .:? "ari")
      <*> (o .:? "lix")
      <*> (o .:? "coleman_liau")
      <*> (o .:? "kincaid")
      <*> (o .:? "fog")

-- | ToJSON ScoreText200ResponseReadabilitySubscores
instance A.ToJSON ScoreText200ResponseReadabilitySubscores where
  toJSON ScoreText200ResponseReadabilitySubscores {..} =
   _omitNulls
      [ "reading_time_seconds" .= scoreText200ResponseReadabilitySubscoresReadingTimeSeconds
      , "forcast" .= scoreText200ResponseReadabilitySubscoresForcast
      , "flesch" .= scoreText200ResponseReadabilitySubscoresFlesch
      , "smog" .= scoreText200ResponseReadabilitySubscoresSmog
      , "ari" .= scoreText200ResponseReadabilitySubscoresAri
      , "lix" .= scoreText200ResponseReadabilitySubscoresLix
      , "coleman_liau" .= scoreText200ResponseReadabilitySubscoresColemanLiau
      , "kincaid" .= scoreText200ResponseReadabilitySubscoresKincaid
      , "fog" .= scoreText200ResponseReadabilitySubscoresFog
      ]


-- | Construct a value of type 'ScoreText200ResponseReadabilitySubscores' (by applying it's required fields, if any)
mkScoreText200ResponseReadabilitySubscores
  :: ScoreText200ResponseReadabilitySubscores
mkScoreText200ResponseReadabilitySubscores =
  ScoreText200ResponseReadabilitySubscores
  { scoreText200ResponseReadabilitySubscoresReadingTimeSeconds = Nothing
  , scoreText200ResponseReadabilitySubscoresForcast = Nothing
  , scoreText200ResponseReadabilitySubscoresFlesch = Nothing
  , scoreText200ResponseReadabilitySubscoresSmog = Nothing
  , scoreText200ResponseReadabilitySubscoresAri = Nothing
  , scoreText200ResponseReadabilitySubscoresLix = Nothing
  , scoreText200ResponseReadabilitySubscoresColemanLiau = Nothing
  , scoreText200ResponseReadabilitySubscoresKincaid = Nothing
  , scoreText200ResponseReadabilitySubscoresFog = Nothing
  }

-- ** ScoreText200ResponseSkimmability
-- | ScoreText200ResponseSkimmability
data ScoreText200ResponseSkimmability = ScoreText200ResponseSkimmability
  { scoreText200ResponseSkimmabilityMainscores :: !(Maybe ScoreText200ResponseSkimmabilityMainscores) -- ^ "mainscores"
  , scoreText200ResponseSkimmabilitySubscores :: !(Maybe ScoreText200ResponseSkimmabilitySubscores) -- ^ "subscores"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ScoreText200ResponseSkimmability
instance A.FromJSON ScoreText200ResponseSkimmability where
  parseJSON = A.withObject "ScoreText200ResponseSkimmability" $ \o ->
    ScoreText200ResponseSkimmability
      <$> (o .:? "mainscores")
      <*> (o .:? "subscores")

-- | ToJSON ScoreText200ResponseSkimmability
instance A.ToJSON ScoreText200ResponseSkimmability where
  toJSON ScoreText200ResponseSkimmability {..} =
   _omitNulls
      [ "mainscores" .= scoreText200ResponseSkimmabilityMainscores
      , "subscores" .= scoreText200ResponseSkimmabilitySubscores
      ]


-- | Construct a value of type 'ScoreText200ResponseSkimmability' (by applying it's required fields, if any)
mkScoreText200ResponseSkimmability
  :: ScoreText200ResponseSkimmability
mkScoreText200ResponseSkimmability =
  ScoreText200ResponseSkimmability
  { scoreText200ResponseSkimmabilityMainscores = Nothing
  , scoreText200ResponseSkimmabilitySubscores = Nothing
  }

-- ** ScoreText200ResponseSkimmabilityMainscores
-- | ScoreText200ResponseSkimmabilityMainscores
data ScoreText200ResponseSkimmabilityMainscores = ScoreText200ResponseSkimmabilityMainscores
  { scoreText200ResponseSkimmabilityMainscoresTotalPossible :: !(Maybe Int) -- ^ "total_possible"
  , scoreText200ResponseSkimmabilityMainscoresTotal :: !(Maybe Double) -- ^ "total"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ScoreText200ResponseSkimmabilityMainscores
instance A.FromJSON ScoreText200ResponseSkimmabilityMainscores where
  parseJSON = A.withObject "ScoreText200ResponseSkimmabilityMainscores" $ \o ->
    ScoreText200ResponseSkimmabilityMainscores
      <$> (o .:? "total_possible")
      <*> (o .:? "total")

-- | ToJSON ScoreText200ResponseSkimmabilityMainscores
instance A.ToJSON ScoreText200ResponseSkimmabilityMainscores where
  toJSON ScoreText200ResponseSkimmabilityMainscores {..} =
   _omitNulls
      [ "total_possible" .= scoreText200ResponseSkimmabilityMainscoresTotalPossible
      , "total" .= scoreText200ResponseSkimmabilityMainscoresTotal
      ]


-- | Construct a value of type 'ScoreText200ResponseSkimmabilityMainscores' (by applying it's required fields, if any)
mkScoreText200ResponseSkimmabilityMainscores
  :: ScoreText200ResponseSkimmabilityMainscores
mkScoreText200ResponseSkimmabilityMainscores =
  ScoreText200ResponseSkimmabilityMainscores
  { scoreText200ResponseSkimmabilityMainscoresTotalPossible = Nothing
  , scoreText200ResponseSkimmabilityMainscoresTotal = Nothing
  }

-- ** ScoreText200ResponseSkimmabilitySubscores
-- | ScoreText200ResponseSkimmabilitySubscores
data ScoreText200ResponseSkimmabilitySubscores = ScoreText200ResponseSkimmabilitySubscores
  { scoreText200ResponseSkimmabilitySubscoresBulletPointRatioScore :: !(Maybe [Int]) -- ^ "bullet_point_ratio_score"
  , scoreText200ResponseSkimmabilitySubscoresImageScore :: !(Maybe [Int]) -- ^ "image_score"
  , scoreText200ResponseSkimmabilitySubscoresHighlightedWordRatioScore :: !(Maybe [Int]) -- ^ "highlighted_word_ratio_score"
  , scoreText200ResponseSkimmabilitySubscoresVideoScore :: !(Maybe [Int]) -- ^ "video_score"
  , scoreText200ResponseSkimmabilitySubscoresParagraphScore :: !(Maybe [Int]) -- ^ "paragraph_score"
  , scoreText200ResponseSkimmabilitySubscoresParagraphHeadlineRatioScore :: !(Maybe [Int]) -- ^ "paragraph_headline_ratio_score"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ScoreText200ResponseSkimmabilitySubscores
instance A.FromJSON ScoreText200ResponseSkimmabilitySubscores where
  parseJSON = A.withObject "ScoreText200ResponseSkimmabilitySubscores" $ \o ->
    ScoreText200ResponseSkimmabilitySubscores
      <$> (o .:? "bullet_point_ratio_score")
      <*> (o .:? "image_score")
      <*> (o .:? "highlighted_word_ratio_score")
      <*> (o .:? "video_score")
      <*> (o .:? "paragraph_score")
      <*> (o .:? "paragraph_headline_ratio_score")

-- | ToJSON ScoreText200ResponseSkimmabilitySubscores
instance A.ToJSON ScoreText200ResponseSkimmabilitySubscores where
  toJSON ScoreText200ResponseSkimmabilitySubscores {..} =
   _omitNulls
      [ "bullet_point_ratio_score" .= scoreText200ResponseSkimmabilitySubscoresBulletPointRatioScore
      , "image_score" .= scoreText200ResponseSkimmabilitySubscoresImageScore
      , "highlighted_word_ratio_score" .= scoreText200ResponseSkimmabilitySubscoresHighlightedWordRatioScore
      , "video_score" .= scoreText200ResponseSkimmabilitySubscoresVideoScore
      , "paragraph_score" .= scoreText200ResponseSkimmabilitySubscoresParagraphScore
      , "paragraph_headline_ratio_score" .= scoreText200ResponseSkimmabilitySubscoresParagraphHeadlineRatioScore
      ]


-- | Construct a value of type 'ScoreText200ResponseSkimmabilitySubscores' (by applying it's required fields, if any)
mkScoreText200ResponseSkimmabilitySubscores
  :: ScoreText200ResponseSkimmabilitySubscores
mkScoreText200ResponseSkimmabilitySubscores =
  ScoreText200ResponseSkimmabilitySubscores
  { scoreText200ResponseSkimmabilitySubscoresBulletPointRatioScore = Nothing
  , scoreText200ResponseSkimmabilitySubscoresImageScore = Nothing
  , scoreText200ResponseSkimmabilitySubscoresHighlightedWordRatioScore = Nothing
  , scoreText200ResponseSkimmabilitySubscoresVideoScore = Nothing
  , scoreText200ResponseSkimmabilitySubscoresParagraphScore = Nothing
  , scoreText200ResponseSkimmabilitySubscoresParagraphHeadlineRatioScore = Nothing
  }

-- ** ScoreText200ResponseStyle
-- | ScoreText200ResponseStyle
data ScoreText200ResponseStyle = ScoreText200ResponseStyle
  { scoreText200ResponseStyleMainscores :: !(Maybe ScoreText200ResponseReadabilityMainscores) -- ^ "mainscores"
  , scoreText200ResponseStyleSubscores :: !(Maybe ScoreText200ResponseStyleSubscores) -- ^ "subscores"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ScoreText200ResponseStyle
instance A.FromJSON ScoreText200ResponseStyle where
  parseJSON = A.withObject "ScoreText200ResponseStyle" $ \o ->
    ScoreText200ResponseStyle
      <$> (o .:? "mainscores")
      <*> (o .:? "subscores")

-- | ToJSON ScoreText200ResponseStyle
instance A.ToJSON ScoreText200ResponseStyle where
  toJSON ScoreText200ResponseStyle {..} =
   _omitNulls
      [ "mainscores" .= scoreText200ResponseStyleMainscores
      , "subscores" .= scoreText200ResponseStyleSubscores
      ]


-- | Construct a value of type 'ScoreText200ResponseStyle' (by applying it's required fields, if any)
mkScoreText200ResponseStyle
  :: ScoreText200ResponseStyle
mkScoreText200ResponseStyle =
  ScoreText200ResponseStyle
  { scoreText200ResponseStyleMainscores = Nothing
  , scoreText200ResponseStyleSubscores = Nothing
  }

-- ** ScoreText200ResponseStyleSubscores
-- | ScoreText200ResponseStyleSubscores
data ScoreText200ResponseStyleSubscores = ScoreText200ResponseStyleSubscores
  { scoreText200ResponseStyleSubscoresAbbreviationScore :: !(Maybe [Int]) -- ^ "abbreviation_score"
  , scoreText200ResponseStyleSubscoresStyleScore :: !(Maybe [Int]) -- ^ "style_score"
  , scoreText200ResponseStyleSubscoresSpellingScore :: !(Maybe [Int]) -- ^ "spelling_score"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ScoreText200ResponseStyleSubscores
instance A.FromJSON ScoreText200ResponseStyleSubscores where
  parseJSON = A.withObject "ScoreText200ResponseStyleSubscores" $ \o ->
    ScoreText200ResponseStyleSubscores
      <$> (o .:? "abbreviation_score")
      <*> (o .:? "style_score")
      <*> (o .:? "spelling_score")

-- | ToJSON ScoreText200ResponseStyleSubscores
instance A.ToJSON ScoreText200ResponseStyleSubscores where
  toJSON ScoreText200ResponseStyleSubscores {..} =
   _omitNulls
      [ "abbreviation_score" .= scoreText200ResponseStyleSubscoresAbbreviationScore
      , "style_score" .= scoreText200ResponseStyleSubscoresStyleScore
      , "spelling_score" .= scoreText200ResponseStyleSubscoresSpellingScore
      ]


-- | Construct a value of type 'ScoreText200ResponseStyleSubscores' (by applying it's required fields, if any)
mkScoreText200ResponseStyleSubscores
  :: ScoreText200ResponseStyleSubscores
mkScoreText200ResponseStyleSubscores =
  ScoreText200ResponseStyleSubscores
  { scoreText200ResponseStyleSubscoresAbbreviationScore = Nothing
  , scoreText200ResponseStyleSubscoresStyleScore = Nothing
  , scoreText200ResponseStyleSubscoresSpellingScore = Nothing
  }

-- ** SearchBooks200Response
-- | SearchBooks200Response
data SearchBooks200Response = SearchBooks200Response
  { searchBooks200ResponseTotalResults :: !(Maybe Int) -- ^ "total_results"
  , searchBooks200ResponseNumber :: !(Maybe Int) -- ^ "number"
  , searchBooks200ResponseOffset :: !(Maybe Int) -- ^ "offset"
  , searchBooks200ResponseBooks :: !(Maybe [[SearchBooks200ResponseBooksInnerInner]]) -- ^ "books"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SearchBooks200Response
instance A.FromJSON SearchBooks200Response where
  parseJSON = A.withObject "SearchBooks200Response" $ \o ->
    SearchBooks200Response
      <$> (o .:? "total_results")
      <*> (o .:? "number")
      <*> (o .:? "offset")
      <*> (o .:? "books")

-- | ToJSON SearchBooks200Response
instance A.ToJSON SearchBooks200Response where
  toJSON SearchBooks200Response {..} =
   _omitNulls
      [ "total_results" .= searchBooks200ResponseTotalResults
      , "number" .= searchBooks200ResponseNumber
      , "offset" .= searchBooks200ResponseOffset
      , "books" .= searchBooks200ResponseBooks
      ]


-- | Construct a value of type 'SearchBooks200Response' (by applying it's required fields, if any)
mkSearchBooks200Response
  :: SearchBooks200Response
mkSearchBooks200Response =
  SearchBooks200Response
  { searchBooks200ResponseTotalResults = Nothing
  , searchBooks200ResponseNumber = Nothing
  , searchBooks200ResponseOffset = Nothing
  , searchBooks200ResponseBooks = Nothing
  }

-- ** SearchBooks200ResponseBooksInnerInner
-- | SearchBooks200ResponseBooksInnerInner
data SearchBooks200ResponseBooksInnerInner = SearchBooks200ResponseBooksInnerInner
  { searchBooks200ResponseBooksInnerInnerTitle :: !(Maybe Text) -- ^ "title"
  , searchBooks200ResponseBooksInnerInnerImage :: !(Maybe Text) -- ^ "image"
  , searchBooks200ResponseBooksInnerInnerId :: !(Maybe Int) -- ^ "id"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SearchBooks200ResponseBooksInnerInner
instance A.FromJSON SearchBooks200ResponseBooksInnerInner where
  parseJSON = A.withObject "SearchBooks200ResponseBooksInnerInner" $ \o ->
    SearchBooks200ResponseBooksInnerInner
      <$> (o .:? "title")
      <*> (o .:? "image")
      <*> (o .:? "id")

-- | ToJSON SearchBooks200ResponseBooksInnerInner
instance A.ToJSON SearchBooks200ResponseBooksInnerInner where
  toJSON SearchBooks200ResponseBooksInnerInner {..} =
   _omitNulls
      [ "title" .= searchBooks200ResponseBooksInnerInnerTitle
      , "image" .= searchBooks200ResponseBooksInnerInnerImage
      , "id" .= searchBooks200ResponseBooksInnerInnerId
      ]


-- | Construct a value of type 'SearchBooks200ResponseBooksInnerInner' (by applying it's required fields, if any)
mkSearchBooks200ResponseBooksInnerInner
  :: SearchBooks200ResponseBooksInnerInner
mkSearchBooks200ResponseBooksInnerInner =
  SearchBooks200ResponseBooksInnerInner
  { searchBooks200ResponseBooksInnerInnerTitle = Nothing
  , searchBooks200ResponseBooksInnerInnerImage = Nothing
  , searchBooks200ResponseBooksInnerInnerId = Nothing
  }

-- ** SearchDrinks200Response
-- | SearchDrinks200Response
data SearchDrinks200Response = SearchDrinks200Response
  { searchDrinks200ResponseOffset :: !(Maybe Int) -- ^ "offset"
  , searchDrinks200ResponseNumber :: !(Maybe Int) -- ^ "number"
  , searchDrinks200ResponseDrinks :: !(Maybe [SearchDrinks200ResponseDrinksInner]) -- ^ "drinks"
  , searchDrinks200ResponseTotalResults :: !(Maybe Int) -- ^ "total_results"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SearchDrinks200Response
instance A.FromJSON SearchDrinks200Response where
  parseJSON = A.withObject "SearchDrinks200Response" $ \o ->
    SearchDrinks200Response
      <$> (o .:? "offset")
      <*> (o .:? "number")
      <*> (o .:? "drinks")
      <*> (o .:? "total_results")

-- | ToJSON SearchDrinks200Response
instance A.ToJSON SearchDrinks200Response where
  toJSON SearchDrinks200Response {..} =
   _omitNulls
      [ "offset" .= searchDrinks200ResponseOffset
      , "number" .= searchDrinks200ResponseNumber
      , "drinks" .= searchDrinks200ResponseDrinks
      , "total_results" .= searchDrinks200ResponseTotalResults
      ]


-- | Construct a value of type 'SearchDrinks200Response' (by applying it's required fields, if any)
mkSearchDrinks200Response
  :: SearchDrinks200Response
mkSearchDrinks200Response =
  SearchDrinks200Response
  { searchDrinks200ResponseOffset = Nothing
  , searchDrinks200ResponseNumber = Nothing
  , searchDrinks200ResponseDrinks = Nothing
  , searchDrinks200ResponseTotalResults = Nothing
  }

-- ** SearchDrinks200ResponseDrinksInner
-- | SearchDrinks200ResponseDrinksInner
data SearchDrinks200ResponseDrinksInner = SearchDrinks200ResponseDrinksInner
  { searchDrinks200ResponseDrinksInnerFlavors :: !(Maybe [Text]) -- ^ "flavors"
  , searchDrinks200ResponseDrinksInnerInstructions :: !(Maybe [SearchDrinks200ResponseDrinksInnerInstructionsInner]) -- ^ "instructions"
  , searchDrinks200ResponseDrinksInnerImages :: !(Maybe [Text]) -- ^ "images"
  , searchDrinks200ResponseDrinksInnerNutrition :: !(Maybe SearchDrinks200ResponseDrinksInnerNutrition) -- ^ "nutrition"
  , searchDrinks200ResponseDrinksInnerGlassType :: !(Maybe Text) -- ^ "glass_type"
  , searchDrinks200ResponseDrinksInnerCredits :: !(Maybe SearchDrinks200ResponseDrinksInnerCredits) -- ^ "credits"
  , searchDrinks200ResponseDrinksInnerPricePerServing :: !(Maybe Double) -- ^ "price_per_serving"
  , searchDrinks200ResponseDrinksInnerDescription :: !(Maybe Text) -- ^ "description"
  , searchDrinks200ResponseDrinksInnerIngredients :: !(Maybe [SearchDrinks200ResponseDrinksInnerIngredientsInner]) -- ^ "ingredients"
  , searchDrinks200ResponseDrinksInnerId :: !(Maybe Int) -- ^ "id"
  , searchDrinks200ResponseDrinksInnerTitle :: !(Maybe Text) -- ^ "title"
  , searchDrinks200ResponseDrinksInnerCuisines :: !(Maybe [Text]) -- ^ "cuisines"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SearchDrinks200ResponseDrinksInner
instance A.FromJSON SearchDrinks200ResponseDrinksInner where
  parseJSON = A.withObject "SearchDrinks200ResponseDrinksInner" $ \o ->
    SearchDrinks200ResponseDrinksInner
      <$> (o .:? "flavors")
      <*> (o .:? "instructions")
      <*> (o .:? "images")
      <*> (o .:? "nutrition")
      <*> (o .:? "glass_type")
      <*> (o .:? "credits")
      <*> (o .:? "price_per_serving")
      <*> (o .:? "description")
      <*> (o .:? "ingredients")
      <*> (o .:? "id")
      <*> (o .:? "title")
      <*> (o .:? "cuisines")

-- | ToJSON SearchDrinks200ResponseDrinksInner
instance A.ToJSON SearchDrinks200ResponseDrinksInner where
  toJSON SearchDrinks200ResponseDrinksInner {..} =
   _omitNulls
      [ "flavors" .= searchDrinks200ResponseDrinksInnerFlavors
      , "instructions" .= searchDrinks200ResponseDrinksInnerInstructions
      , "images" .= searchDrinks200ResponseDrinksInnerImages
      , "nutrition" .= searchDrinks200ResponseDrinksInnerNutrition
      , "glass_type" .= searchDrinks200ResponseDrinksInnerGlassType
      , "credits" .= searchDrinks200ResponseDrinksInnerCredits
      , "price_per_serving" .= searchDrinks200ResponseDrinksInnerPricePerServing
      , "description" .= searchDrinks200ResponseDrinksInnerDescription
      , "ingredients" .= searchDrinks200ResponseDrinksInnerIngredients
      , "id" .= searchDrinks200ResponseDrinksInnerId
      , "title" .= searchDrinks200ResponseDrinksInnerTitle
      , "cuisines" .= searchDrinks200ResponseDrinksInnerCuisines
      ]


-- | Construct a value of type 'SearchDrinks200ResponseDrinksInner' (by applying it's required fields, if any)
mkSearchDrinks200ResponseDrinksInner
  :: SearchDrinks200ResponseDrinksInner
mkSearchDrinks200ResponseDrinksInner =
  SearchDrinks200ResponseDrinksInner
  { searchDrinks200ResponseDrinksInnerFlavors = Nothing
  , searchDrinks200ResponseDrinksInnerInstructions = Nothing
  , searchDrinks200ResponseDrinksInnerImages = Nothing
  , searchDrinks200ResponseDrinksInnerNutrition = Nothing
  , searchDrinks200ResponseDrinksInnerGlassType = Nothing
  , searchDrinks200ResponseDrinksInnerCredits = Nothing
  , searchDrinks200ResponseDrinksInnerPricePerServing = Nothing
  , searchDrinks200ResponseDrinksInnerDescription = Nothing
  , searchDrinks200ResponseDrinksInnerIngredients = Nothing
  , searchDrinks200ResponseDrinksInnerId = Nothing
  , searchDrinks200ResponseDrinksInnerTitle = Nothing
  , searchDrinks200ResponseDrinksInnerCuisines = Nothing
  }

-- ** SearchDrinks200ResponseDrinksInnerCredits
-- | SearchDrinks200ResponseDrinksInnerCredits
data SearchDrinks200ResponseDrinksInnerCredits = SearchDrinks200ResponseDrinksInnerCredits
  { searchDrinks200ResponseDrinksInnerCreditsText :: !(Maybe Text) -- ^ "text"
  , searchDrinks200ResponseDrinksInnerCreditsSourceName :: !(Maybe Text) -- ^ "source_name"
  , searchDrinks200ResponseDrinksInnerCreditsSourceUrl :: !(Maybe Text) -- ^ "source_url"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SearchDrinks200ResponseDrinksInnerCredits
instance A.FromJSON SearchDrinks200ResponseDrinksInnerCredits where
  parseJSON = A.withObject "SearchDrinks200ResponseDrinksInnerCredits" $ \o ->
    SearchDrinks200ResponseDrinksInnerCredits
      <$> (o .:? "text")
      <*> (o .:? "source_name")
      <*> (o .:? "source_url")

-- | ToJSON SearchDrinks200ResponseDrinksInnerCredits
instance A.ToJSON SearchDrinks200ResponseDrinksInnerCredits where
  toJSON SearchDrinks200ResponseDrinksInnerCredits {..} =
   _omitNulls
      [ "text" .= searchDrinks200ResponseDrinksInnerCreditsText
      , "source_name" .= searchDrinks200ResponseDrinksInnerCreditsSourceName
      , "source_url" .= searchDrinks200ResponseDrinksInnerCreditsSourceUrl
      ]


-- | Construct a value of type 'SearchDrinks200ResponseDrinksInnerCredits' (by applying it's required fields, if any)
mkSearchDrinks200ResponseDrinksInnerCredits
  :: SearchDrinks200ResponseDrinksInnerCredits
mkSearchDrinks200ResponseDrinksInnerCredits =
  SearchDrinks200ResponseDrinksInnerCredits
  { searchDrinks200ResponseDrinksInnerCreditsText = Nothing
  , searchDrinks200ResponseDrinksInnerCreditsSourceName = Nothing
  , searchDrinks200ResponseDrinksInnerCreditsSourceUrl = Nothing
  }

-- ** SearchDrinks200ResponseDrinksInnerIngredientsInner
-- | SearchDrinks200ResponseDrinksInnerIngredientsInner
data SearchDrinks200ResponseDrinksInnerIngredientsInner = SearchDrinks200ResponseDrinksInnerIngredientsInner
  { searchDrinks200ResponseDrinksInnerIngredientsInnerImage :: !(Maybe Text) -- ^ "image"
  , searchDrinks200ResponseDrinksInnerIngredientsInnerNameClean :: !(Maybe Text) -- ^ "name_clean"
  , searchDrinks200ResponseDrinksInnerIngredientsInnerAmount :: !(Maybe Int) -- ^ "amount"
  , searchDrinks200ResponseDrinksInnerIngredientsInnerUnit :: !(Maybe Text) -- ^ "unit"
  , searchDrinks200ResponseDrinksInnerIngredientsInnerMeasures :: !(Maybe SearchDrinks200ResponseDrinksInnerIngredientsInnerMeasures) -- ^ "measures"
  , searchDrinks200ResponseDrinksInnerIngredientsInnerOriginal :: !(Maybe Text) -- ^ "original"
  , searchDrinks200ResponseDrinksInnerIngredientsInnerMeta :: !(Maybe [Text]) -- ^ "meta"
  , searchDrinks200ResponseDrinksInnerIngredientsInnerOriginalName :: !(Maybe Text) -- ^ "original_name"
  , searchDrinks200ResponseDrinksInnerIngredientsInnerName :: !(Maybe Text) -- ^ "name"
  , searchDrinks200ResponseDrinksInnerIngredientsInnerId :: !(Maybe Int) -- ^ "id"
  , searchDrinks200ResponseDrinksInnerIngredientsInnerAisle :: !(Maybe Text) -- ^ "aisle"
  , searchDrinks200ResponseDrinksInnerIngredientsInnerConsistency :: !(Maybe Text) -- ^ "consistency"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SearchDrinks200ResponseDrinksInnerIngredientsInner
instance A.FromJSON SearchDrinks200ResponseDrinksInnerIngredientsInner where
  parseJSON = A.withObject "SearchDrinks200ResponseDrinksInnerIngredientsInner" $ \o ->
    SearchDrinks200ResponseDrinksInnerIngredientsInner
      <$> (o .:? "image")
      <*> (o .:? "name_clean")
      <*> (o .:? "amount")
      <*> (o .:? "unit")
      <*> (o .:? "measures")
      <*> (o .:? "original")
      <*> (o .:? "meta")
      <*> (o .:? "original_name")
      <*> (o .:? "name")
      <*> (o .:? "id")
      <*> (o .:? "aisle")
      <*> (o .:? "consistency")

-- | ToJSON SearchDrinks200ResponseDrinksInnerIngredientsInner
instance A.ToJSON SearchDrinks200ResponseDrinksInnerIngredientsInner where
  toJSON SearchDrinks200ResponseDrinksInnerIngredientsInner {..} =
   _omitNulls
      [ "image" .= searchDrinks200ResponseDrinksInnerIngredientsInnerImage
      , "name_clean" .= searchDrinks200ResponseDrinksInnerIngredientsInnerNameClean
      , "amount" .= searchDrinks200ResponseDrinksInnerIngredientsInnerAmount
      , "unit" .= searchDrinks200ResponseDrinksInnerIngredientsInnerUnit
      , "measures" .= searchDrinks200ResponseDrinksInnerIngredientsInnerMeasures
      , "original" .= searchDrinks200ResponseDrinksInnerIngredientsInnerOriginal
      , "meta" .= searchDrinks200ResponseDrinksInnerIngredientsInnerMeta
      , "original_name" .= searchDrinks200ResponseDrinksInnerIngredientsInnerOriginalName
      , "name" .= searchDrinks200ResponseDrinksInnerIngredientsInnerName
      , "id" .= searchDrinks200ResponseDrinksInnerIngredientsInnerId
      , "aisle" .= searchDrinks200ResponseDrinksInnerIngredientsInnerAisle
      , "consistency" .= searchDrinks200ResponseDrinksInnerIngredientsInnerConsistency
      ]


-- | Construct a value of type 'SearchDrinks200ResponseDrinksInnerIngredientsInner' (by applying it's required fields, if any)
mkSearchDrinks200ResponseDrinksInnerIngredientsInner
  :: SearchDrinks200ResponseDrinksInnerIngredientsInner
mkSearchDrinks200ResponseDrinksInnerIngredientsInner =
  SearchDrinks200ResponseDrinksInnerIngredientsInner
  { searchDrinks200ResponseDrinksInnerIngredientsInnerImage = Nothing
  , searchDrinks200ResponseDrinksInnerIngredientsInnerNameClean = Nothing
  , searchDrinks200ResponseDrinksInnerIngredientsInnerAmount = Nothing
  , searchDrinks200ResponseDrinksInnerIngredientsInnerUnit = Nothing
  , searchDrinks200ResponseDrinksInnerIngredientsInnerMeasures = Nothing
  , searchDrinks200ResponseDrinksInnerIngredientsInnerOriginal = Nothing
  , searchDrinks200ResponseDrinksInnerIngredientsInnerMeta = Nothing
  , searchDrinks200ResponseDrinksInnerIngredientsInnerOriginalName = Nothing
  , searchDrinks200ResponseDrinksInnerIngredientsInnerName = Nothing
  , searchDrinks200ResponseDrinksInnerIngredientsInnerId = Nothing
  , searchDrinks200ResponseDrinksInnerIngredientsInnerAisle = Nothing
  , searchDrinks200ResponseDrinksInnerIngredientsInnerConsistency = Nothing
  }

-- ** SearchDrinks200ResponseDrinksInnerIngredientsInnerMeasures
-- | SearchDrinks200ResponseDrinksInnerIngredientsInnerMeasures
data SearchDrinks200ResponseDrinksInnerIngredientsInnerMeasures = SearchDrinks200ResponseDrinksInnerIngredientsInnerMeasures
  { searchDrinks200ResponseDrinksInnerIngredientsInnerMeasuresMetric :: !(Maybe SearchDrinks200ResponseDrinksInnerIngredientsInnerMeasuresMetric) -- ^ "metric"
  , searchDrinks200ResponseDrinksInnerIngredientsInnerMeasuresUs :: !(Maybe SearchDrinks200ResponseDrinksInnerIngredientsInnerMeasuresUs) -- ^ "us"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SearchDrinks200ResponseDrinksInnerIngredientsInnerMeasures
instance A.FromJSON SearchDrinks200ResponseDrinksInnerIngredientsInnerMeasures where
  parseJSON = A.withObject "SearchDrinks200ResponseDrinksInnerIngredientsInnerMeasures" $ \o ->
    SearchDrinks200ResponseDrinksInnerIngredientsInnerMeasures
      <$> (o .:? "metric")
      <*> (o .:? "us")

-- | ToJSON SearchDrinks200ResponseDrinksInnerIngredientsInnerMeasures
instance A.ToJSON SearchDrinks200ResponseDrinksInnerIngredientsInnerMeasures where
  toJSON SearchDrinks200ResponseDrinksInnerIngredientsInnerMeasures {..} =
   _omitNulls
      [ "metric" .= searchDrinks200ResponseDrinksInnerIngredientsInnerMeasuresMetric
      , "us" .= searchDrinks200ResponseDrinksInnerIngredientsInnerMeasuresUs
      ]


-- | Construct a value of type 'SearchDrinks200ResponseDrinksInnerIngredientsInnerMeasures' (by applying it's required fields, if any)
mkSearchDrinks200ResponseDrinksInnerIngredientsInnerMeasures
  :: SearchDrinks200ResponseDrinksInnerIngredientsInnerMeasures
mkSearchDrinks200ResponseDrinksInnerIngredientsInnerMeasures =
  SearchDrinks200ResponseDrinksInnerIngredientsInnerMeasures
  { searchDrinks200ResponseDrinksInnerIngredientsInnerMeasuresMetric = Nothing
  , searchDrinks200ResponseDrinksInnerIngredientsInnerMeasuresUs = Nothing
  }

-- ** SearchDrinks200ResponseDrinksInnerIngredientsInnerMeasuresMetric
-- | SearchDrinks200ResponseDrinksInnerIngredientsInnerMeasuresMetric
data SearchDrinks200ResponseDrinksInnerIngredientsInnerMeasuresMetric = SearchDrinks200ResponseDrinksInnerIngredientsInnerMeasuresMetric
  { searchDrinks200ResponseDrinksInnerIngredientsInnerMeasuresMetricUnitShort :: !(Maybe Text) -- ^ "unit_short"
  , searchDrinks200ResponseDrinksInnerIngredientsInnerMeasuresMetricAmount :: !(Maybe Double) -- ^ "amount"
  , searchDrinks200ResponseDrinksInnerIngredientsInnerMeasuresMetricUnitLong :: !(Maybe Text) -- ^ "unit_long"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SearchDrinks200ResponseDrinksInnerIngredientsInnerMeasuresMetric
instance A.FromJSON SearchDrinks200ResponseDrinksInnerIngredientsInnerMeasuresMetric where
  parseJSON = A.withObject "SearchDrinks200ResponseDrinksInnerIngredientsInnerMeasuresMetric" $ \o ->
    SearchDrinks200ResponseDrinksInnerIngredientsInnerMeasuresMetric
      <$> (o .:? "unit_short")
      <*> (o .:? "amount")
      <*> (o .:? "unit_long")

-- | ToJSON SearchDrinks200ResponseDrinksInnerIngredientsInnerMeasuresMetric
instance A.ToJSON SearchDrinks200ResponseDrinksInnerIngredientsInnerMeasuresMetric where
  toJSON SearchDrinks200ResponseDrinksInnerIngredientsInnerMeasuresMetric {..} =
   _omitNulls
      [ "unit_short" .= searchDrinks200ResponseDrinksInnerIngredientsInnerMeasuresMetricUnitShort
      , "amount" .= searchDrinks200ResponseDrinksInnerIngredientsInnerMeasuresMetricAmount
      , "unit_long" .= searchDrinks200ResponseDrinksInnerIngredientsInnerMeasuresMetricUnitLong
      ]


-- | Construct a value of type 'SearchDrinks200ResponseDrinksInnerIngredientsInnerMeasuresMetric' (by applying it's required fields, if any)
mkSearchDrinks200ResponseDrinksInnerIngredientsInnerMeasuresMetric
  :: SearchDrinks200ResponseDrinksInnerIngredientsInnerMeasuresMetric
mkSearchDrinks200ResponseDrinksInnerIngredientsInnerMeasuresMetric =
  SearchDrinks200ResponseDrinksInnerIngredientsInnerMeasuresMetric
  { searchDrinks200ResponseDrinksInnerIngredientsInnerMeasuresMetricUnitShort = Nothing
  , searchDrinks200ResponseDrinksInnerIngredientsInnerMeasuresMetricAmount = Nothing
  , searchDrinks200ResponseDrinksInnerIngredientsInnerMeasuresMetricUnitLong = Nothing
  }

-- ** SearchDrinks200ResponseDrinksInnerIngredientsInnerMeasuresUs
-- | SearchDrinks200ResponseDrinksInnerIngredientsInnerMeasuresUs
data SearchDrinks200ResponseDrinksInnerIngredientsInnerMeasuresUs = SearchDrinks200ResponseDrinksInnerIngredientsInnerMeasuresUs
  { searchDrinks200ResponseDrinksInnerIngredientsInnerMeasuresUsUnitShort :: !(Maybe Text) -- ^ "unit_short"
  , searchDrinks200ResponseDrinksInnerIngredientsInnerMeasuresUsAmount :: !(Maybe Int) -- ^ "amount"
  , searchDrinks200ResponseDrinksInnerIngredientsInnerMeasuresUsUnitLong :: !(Maybe Text) -- ^ "unit_long"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SearchDrinks200ResponseDrinksInnerIngredientsInnerMeasuresUs
instance A.FromJSON SearchDrinks200ResponseDrinksInnerIngredientsInnerMeasuresUs where
  parseJSON = A.withObject "SearchDrinks200ResponseDrinksInnerIngredientsInnerMeasuresUs" $ \o ->
    SearchDrinks200ResponseDrinksInnerIngredientsInnerMeasuresUs
      <$> (o .:? "unit_short")
      <*> (o .:? "amount")
      <*> (o .:? "unit_long")

-- | ToJSON SearchDrinks200ResponseDrinksInnerIngredientsInnerMeasuresUs
instance A.ToJSON SearchDrinks200ResponseDrinksInnerIngredientsInnerMeasuresUs where
  toJSON SearchDrinks200ResponseDrinksInnerIngredientsInnerMeasuresUs {..} =
   _omitNulls
      [ "unit_short" .= searchDrinks200ResponseDrinksInnerIngredientsInnerMeasuresUsUnitShort
      , "amount" .= searchDrinks200ResponseDrinksInnerIngredientsInnerMeasuresUsAmount
      , "unit_long" .= searchDrinks200ResponseDrinksInnerIngredientsInnerMeasuresUsUnitLong
      ]


-- | Construct a value of type 'SearchDrinks200ResponseDrinksInnerIngredientsInnerMeasuresUs' (by applying it's required fields, if any)
mkSearchDrinks200ResponseDrinksInnerIngredientsInnerMeasuresUs
  :: SearchDrinks200ResponseDrinksInnerIngredientsInnerMeasuresUs
mkSearchDrinks200ResponseDrinksInnerIngredientsInnerMeasuresUs =
  SearchDrinks200ResponseDrinksInnerIngredientsInnerMeasuresUs
  { searchDrinks200ResponseDrinksInnerIngredientsInnerMeasuresUsUnitShort = Nothing
  , searchDrinks200ResponseDrinksInnerIngredientsInnerMeasuresUsAmount = Nothing
  , searchDrinks200ResponseDrinksInnerIngredientsInnerMeasuresUsUnitLong = Nothing
  }

-- ** SearchDrinks200ResponseDrinksInnerInstructionsInner
-- | SearchDrinks200ResponseDrinksInnerInstructionsInner
data SearchDrinks200ResponseDrinksInnerInstructionsInner = SearchDrinks200ResponseDrinksInnerInstructionsInner
  { searchDrinks200ResponseDrinksInnerInstructionsInnerName :: !(Maybe Text) -- ^ "name"
  , searchDrinks200ResponseDrinksInnerInstructionsInnerSteps :: !(Maybe [SearchDrinks200ResponseDrinksInnerInstructionsInnerStepsInner]) -- ^ "steps"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SearchDrinks200ResponseDrinksInnerInstructionsInner
instance A.FromJSON SearchDrinks200ResponseDrinksInnerInstructionsInner where
  parseJSON = A.withObject "SearchDrinks200ResponseDrinksInnerInstructionsInner" $ \o ->
    SearchDrinks200ResponseDrinksInnerInstructionsInner
      <$> (o .:? "name")
      <*> (o .:? "steps")

-- | ToJSON SearchDrinks200ResponseDrinksInnerInstructionsInner
instance A.ToJSON SearchDrinks200ResponseDrinksInnerInstructionsInner where
  toJSON SearchDrinks200ResponseDrinksInnerInstructionsInner {..} =
   _omitNulls
      [ "name" .= searchDrinks200ResponseDrinksInnerInstructionsInnerName
      , "steps" .= searchDrinks200ResponseDrinksInnerInstructionsInnerSteps
      ]


-- | Construct a value of type 'SearchDrinks200ResponseDrinksInnerInstructionsInner' (by applying it's required fields, if any)
mkSearchDrinks200ResponseDrinksInnerInstructionsInner
  :: SearchDrinks200ResponseDrinksInnerInstructionsInner
mkSearchDrinks200ResponseDrinksInnerInstructionsInner =
  SearchDrinks200ResponseDrinksInnerInstructionsInner
  { searchDrinks200ResponseDrinksInnerInstructionsInnerName = Nothing
  , searchDrinks200ResponseDrinksInnerInstructionsInnerSteps = Nothing
  }

-- ** SearchDrinks200ResponseDrinksInnerInstructionsInnerStepsInner
-- | SearchDrinks200ResponseDrinksInnerInstructionsInnerStepsInner
data SearchDrinks200ResponseDrinksInnerInstructionsInnerStepsInner = SearchDrinks200ResponseDrinksInnerInstructionsInnerStepsInner
  { searchDrinks200ResponseDrinksInnerInstructionsInnerStepsInnerNumber :: !(Maybe Int) -- ^ "number"
  , searchDrinks200ResponseDrinksInnerInstructionsInnerStepsInnerIngredients :: !(Maybe [SearchDrinks200ResponseDrinksInnerInstructionsInnerStepsInnerIngredientsInner]) -- ^ "ingredients"
  , searchDrinks200ResponseDrinksInnerInstructionsInnerStepsInnerEquipment :: !(Maybe [Text]) -- ^ "equipment"
  , searchDrinks200ResponseDrinksInnerInstructionsInnerStepsInnerStep :: !(Maybe Text) -- ^ "step"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SearchDrinks200ResponseDrinksInnerInstructionsInnerStepsInner
instance A.FromJSON SearchDrinks200ResponseDrinksInnerInstructionsInnerStepsInner where
  parseJSON = A.withObject "SearchDrinks200ResponseDrinksInnerInstructionsInnerStepsInner" $ \o ->
    SearchDrinks200ResponseDrinksInnerInstructionsInnerStepsInner
      <$> (o .:? "number")
      <*> (o .:? "ingredients")
      <*> (o .:? "equipment")
      <*> (o .:? "step")

-- | ToJSON SearchDrinks200ResponseDrinksInnerInstructionsInnerStepsInner
instance A.ToJSON SearchDrinks200ResponseDrinksInnerInstructionsInnerStepsInner where
  toJSON SearchDrinks200ResponseDrinksInnerInstructionsInnerStepsInner {..} =
   _omitNulls
      [ "number" .= searchDrinks200ResponseDrinksInnerInstructionsInnerStepsInnerNumber
      , "ingredients" .= searchDrinks200ResponseDrinksInnerInstructionsInnerStepsInnerIngredients
      , "equipment" .= searchDrinks200ResponseDrinksInnerInstructionsInnerStepsInnerEquipment
      , "step" .= searchDrinks200ResponseDrinksInnerInstructionsInnerStepsInnerStep
      ]


-- | Construct a value of type 'SearchDrinks200ResponseDrinksInnerInstructionsInnerStepsInner' (by applying it's required fields, if any)
mkSearchDrinks200ResponseDrinksInnerInstructionsInnerStepsInner
  :: SearchDrinks200ResponseDrinksInnerInstructionsInnerStepsInner
mkSearchDrinks200ResponseDrinksInnerInstructionsInnerStepsInner =
  SearchDrinks200ResponseDrinksInnerInstructionsInnerStepsInner
  { searchDrinks200ResponseDrinksInnerInstructionsInnerStepsInnerNumber = Nothing
  , searchDrinks200ResponseDrinksInnerInstructionsInnerStepsInnerIngredients = Nothing
  , searchDrinks200ResponseDrinksInnerInstructionsInnerStepsInnerEquipment = Nothing
  , searchDrinks200ResponseDrinksInnerInstructionsInnerStepsInnerStep = Nothing
  }

-- ** SearchDrinks200ResponseDrinksInnerInstructionsInnerStepsInnerIngredientsInner
-- | SearchDrinks200ResponseDrinksInnerInstructionsInnerStepsInnerIngredientsInner
data SearchDrinks200ResponseDrinksInnerInstructionsInnerStepsInnerIngredientsInner = SearchDrinks200ResponseDrinksInnerInstructionsInnerStepsInnerIngredientsInner
  { searchDrinks200ResponseDrinksInnerInstructionsInnerStepsInnerIngredientsInnerName :: !(Maybe Text) -- ^ "name"
  , searchDrinks200ResponseDrinksInnerInstructionsInnerStepsInnerIngredientsInnerImage :: !(Maybe Text) -- ^ "image"
  , searchDrinks200ResponseDrinksInnerInstructionsInnerStepsInnerIngredientsInnerId :: !(Maybe Int) -- ^ "id"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SearchDrinks200ResponseDrinksInnerInstructionsInnerStepsInnerIngredientsInner
instance A.FromJSON SearchDrinks200ResponseDrinksInnerInstructionsInnerStepsInnerIngredientsInner where
  parseJSON = A.withObject "SearchDrinks200ResponseDrinksInnerInstructionsInnerStepsInnerIngredientsInner" $ \o ->
    SearchDrinks200ResponseDrinksInnerInstructionsInnerStepsInnerIngredientsInner
      <$> (o .:? "name")
      <*> (o .:? "image")
      <*> (o .:? "id")

-- | ToJSON SearchDrinks200ResponseDrinksInnerInstructionsInnerStepsInnerIngredientsInner
instance A.ToJSON SearchDrinks200ResponseDrinksInnerInstructionsInnerStepsInnerIngredientsInner where
  toJSON SearchDrinks200ResponseDrinksInnerInstructionsInnerStepsInnerIngredientsInner {..} =
   _omitNulls
      [ "name" .= searchDrinks200ResponseDrinksInnerInstructionsInnerStepsInnerIngredientsInnerName
      , "image" .= searchDrinks200ResponseDrinksInnerInstructionsInnerStepsInnerIngredientsInnerImage
      , "id" .= searchDrinks200ResponseDrinksInnerInstructionsInnerStepsInnerIngredientsInnerId
      ]


-- | Construct a value of type 'SearchDrinks200ResponseDrinksInnerInstructionsInnerStepsInnerIngredientsInner' (by applying it's required fields, if any)
mkSearchDrinks200ResponseDrinksInnerInstructionsInnerStepsInnerIngredientsInner
  :: SearchDrinks200ResponseDrinksInnerInstructionsInnerStepsInnerIngredientsInner
mkSearchDrinks200ResponseDrinksInnerInstructionsInnerStepsInnerIngredientsInner =
  SearchDrinks200ResponseDrinksInnerInstructionsInnerStepsInnerIngredientsInner
  { searchDrinks200ResponseDrinksInnerInstructionsInnerStepsInnerIngredientsInnerName = Nothing
  , searchDrinks200ResponseDrinksInnerInstructionsInnerStepsInnerIngredientsInnerImage = Nothing
  , searchDrinks200ResponseDrinksInnerInstructionsInnerStepsInnerIngredientsInnerId = Nothing
  }

-- ** SearchDrinks200ResponseDrinksInnerNutrition
-- | SearchDrinks200ResponseDrinksInnerNutrition
data SearchDrinks200ResponseDrinksInnerNutrition = SearchDrinks200ResponseDrinksInnerNutrition
  { searchDrinks200ResponseDrinksInnerNutritionWeightPerServing :: !(Maybe SearchDrinks200ResponseDrinksInnerNutritionWeightPerServing) -- ^ "weight_per_serving"
  , searchDrinks200ResponseDrinksInnerNutritionCaloricBreakdown :: !(Maybe SearchDrinks200ResponseDrinksInnerNutritionCaloricBreakdown) -- ^ "caloric_breakdown"
  , searchDrinks200ResponseDrinksInnerNutritionFlavonoids :: !(Maybe [SearchDrinks200ResponseDrinksInnerNutritionFlavonoidsInner]) -- ^ "flavonoids"
  , searchDrinks200ResponseDrinksInnerNutritionIngredientBreakdown :: !(Maybe [SearchDrinks200ResponseDrinksInnerNutritionIngredientBreakdownInner]) -- ^ "ingredient_breakdown"
  , searchDrinks200ResponseDrinksInnerNutritionProperties :: !(Maybe [SearchDrinks200ResponseDrinksInnerNutritionFlavonoidsInner]) -- ^ "properties"
  , searchDrinks200ResponseDrinksInnerNutritionNutrients :: !(Maybe [SearchDrinks200ResponseDrinksInnerNutritionNutrientsInner]) -- ^ "nutrients"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SearchDrinks200ResponseDrinksInnerNutrition
instance A.FromJSON SearchDrinks200ResponseDrinksInnerNutrition where
  parseJSON = A.withObject "SearchDrinks200ResponseDrinksInnerNutrition" $ \o ->
    SearchDrinks200ResponseDrinksInnerNutrition
      <$> (o .:? "weight_per_serving")
      <*> (o .:? "caloric_breakdown")
      <*> (o .:? "flavonoids")
      <*> (o .:? "ingredient_breakdown")
      <*> (o .:? "properties")
      <*> (o .:? "nutrients")

-- | ToJSON SearchDrinks200ResponseDrinksInnerNutrition
instance A.ToJSON SearchDrinks200ResponseDrinksInnerNutrition where
  toJSON SearchDrinks200ResponseDrinksInnerNutrition {..} =
   _omitNulls
      [ "weight_per_serving" .= searchDrinks200ResponseDrinksInnerNutritionWeightPerServing
      , "caloric_breakdown" .= searchDrinks200ResponseDrinksInnerNutritionCaloricBreakdown
      , "flavonoids" .= searchDrinks200ResponseDrinksInnerNutritionFlavonoids
      , "ingredient_breakdown" .= searchDrinks200ResponseDrinksInnerNutritionIngredientBreakdown
      , "properties" .= searchDrinks200ResponseDrinksInnerNutritionProperties
      , "nutrients" .= searchDrinks200ResponseDrinksInnerNutritionNutrients
      ]


-- | Construct a value of type 'SearchDrinks200ResponseDrinksInnerNutrition' (by applying it's required fields, if any)
mkSearchDrinks200ResponseDrinksInnerNutrition
  :: SearchDrinks200ResponseDrinksInnerNutrition
mkSearchDrinks200ResponseDrinksInnerNutrition =
  SearchDrinks200ResponseDrinksInnerNutrition
  { searchDrinks200ResponseDrinksInnerNutritionWeightPerServing = Nothing
  , searchDrinks200ResponseDrinksInnerNutritionCaloricBreakdown = Nothing
  , searchDrinks200ResponseDrinksInnerNutritionFlavonoids = Nothing
  , searchDrinks200ResponseDrinksInnerNutritionIngredientBreakdown = Nothing
  , searchDrinks200ResponseDrinksInnerNutritionProperties = Nothing
  , searchDrinks200ResponseDrinksInnerNutritionNutrients = Nothing
  }

-- ** SearchDrinks200ResponseDrinksInnerNutritionCaloricBreakdown
-- | SearchDrinks200ResponseDrinksInnerNutritionCaloricBreakdown
data SearchDrinks200ResponseDrinksInnerNutritionCaloricBreakdown = SearchDrinks200ResponseDrinksInnerNutritionCaloricBreakdown
  { searchDrinks200ResponseDrinksInnerNutritionCaloricBreakdownPercentFat :: !(Maybe Double) -- ^ "percent_fat"
  , searchDrinks200ResponseDrinksInnerNutritionCaloricBreakdownPercentCarbs :: !(Maybe Double) -- ^ "percent_carbs"
  , searchDrinks200ResponseDrinksInnerNutritionCaloricBreakdownPercentProtein :: !(Maybe Double) -- ^ "percent_protein"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SearchDrinks200ResponseDrinksInnerNutritionCaloricBreakdown
instance A.FromJSON SearchDrinks200ResponseDrinksInnerNutritionCaloricBreakdown where
  parseJSON = A.withObject "SearchDrinks200ResponseDrinksInnerNutritionCaloricBreakdown" $ \o ->
    SearchDrinks200ResponseDrinksInnerNutritionCaloricBreakdown
      <$> (o .:? "percent_fat")
      <*> (o .:? "percent_carbs")
      <*> (o .:? "percent_protein")

-- | ToJSON SearchDrinks200ResponseDrinksInnerNutritionCaloricBreakdown
instance A.ToJSON SearchDrinks200ResponseDrinksInnerNutritionCaloricBreakdown where
  toJSON SearchDrinks200ResponseDrinksInnerNutritionCaloricBreakdown {..} =
   _omitNulls
      [ "percent_fat" .= searchDrinks200ResponseDrinksInnerNutritionCaloricBreakdownPercentFat
      , "percent_carbs" .= searchDrinks200ResponseDrinksInnerNutritionCaloricBreakdownPercentCarbs
      , "percent_protein" .= searchDrinks200ResponseDrinksInnerNutritionCaloricBreakdownPercentProtein
      ]


-- | Construct a value of type 'SearchDrinks200ResponseDrinksInnerNutritionCaloricBreakdown' (by applying it's required fields, if any)
mkSearchDrinks200ResponseDrinksInnerNutritionCaloricBreakdown
  :: SearchDrinks200ResponseDrinksInnerNutritionCaloricBreakdown
mkSearchDrinks200ResponseDrinksInnerNutritionCaloricBreakdown =
  SearchDrinks200ResponseDrinksInnerNutritionCaloricBreakdown
  { searchDrinks200ResponseDrinksInnerNutritionCaloricBreakdownPercentFat = Nothing
  , searchDrinks200ResponseDrinksInnerNutritionCaloricBreakdownPercentCarbs = Nothing
  , searchDrinks200ResponseDrinksInnerNutritionCaloricBreakdownPercentProtein = Nothing
  }

-- ** SearchDrinks200ResponseDrinksInnerNutritionFlavonoidsInner
-- | SearchDrinks200ResponseDrinksInnerNutritionFlavonoidsInner
data SearchDrinks200ResponseDrinksInnerNutritionFlavonoidsInner = SearchDrinks200ResponseDrinksInnerNutritionFlavonoidsInner
  { searchDrinks200ResponseDrinksInnerNutritionFlavonoidsInnerName :: !(Maybe Text) -- ^ "name"
  , searchDrinks200ResponseDrinksInnerNutritionFlavonoidsInnerAmount :: !(Maybe Int) -- ^ "amount"
  , searchDrinks200ResponseDrinksInnerNutritionFlavonoidsInnerUnit :: !(Maybe Text) -- ^ "unit"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SearchDrinks200ResponseDrinksInnerNutritionFlavonoidsInner
instance A.FromJSON SearchDrinks200ResponseDrinksInnerNutritionFlavonoidsInner where
  parseJSON = A.withObject "SearchDrinks200ResponseDrinksInnerNutritionFlavonoidsInner" $ \o ->
    SearchDrinks200ResponseDrinksInnerNutritionFlavonoidsInner
      <$> (o .:? "name")
      <*> (o .:? "amount")
      <*> (o .:? "unit")

-- | ToJSON SearchDrinks200ResponseDrinksInnerNutritionFlavonoidsInner
instance A.ToJSON SearchDrinks200ResponseDrinksInnerNutritionFlavonoidsInner where
  toJSON SearchDrinks200ResponseDrinksInnerNutritionFlavonoidsInner {..} =
   _omitNulls
      [ "name" .= searchDrinks200ResponseDrinksInnerNutritionFlavonoidsInnerName
      , "amount" .= searchDrinks200ResponseDrinksInnerNutritionFlavonoidsInnerAmount
      , "unit" .= searchDrinks200ResponseDrinksInnerNutritionFlavonoidsInnerUnit
      ]


-- | Construct a value of type 'SearchDrinks200ResponseDrinksInnerNutritionFlavonoidsInner' (by applying it's required fields, if any)
mkSearchDrinks200ResponseDrinksInnerNutritionFlavonoidsInner
  :: SearchDrinks200ResponseDrinksInnerNutritionFlavonoidsInner
mkSearchDrinks200ResponseDrinksInnerNutritionFlavonoidsInner =
  SearchDrinks200ResponseDrinksInnerNutritionFlavonoidsInner
  { searchDrinks200ResponseDrinksInnerNutritionFlavonoidsInnerName = Nothing
  , searchDrinks200ResponseDrinksInnerNutritionFlavonoidsInnerAmount = Nothing
  , searchDrinks200ResponseDrinksInnerNutritionFlavonoidsInnerUnit = Nothing
  }

-- ** SearchDrinks200ResponseDrinksInnerNutritionIngredientBreakdownInner
-- | SearchDrinks200ResponseDrinksInnerNutritionIngredientBreakdownInner
data SearchDrinks200ResponseDrinksInnerNutritionIngredientBreakdownInner = SearchDrinks200ResponseDrinksInnerNutritionIngredientBreakdownInner
  { searchDrinks200ResponseDrinksInnerNutritionIngredientBreakdownInnerName :: !(Maybe Text) -- ^ "name"
  , searchDrinks200ResponseDrinksInnerNutritionIngredientBreakdownInnerAmount :: !(Maybe Int) -- ^ "amount"
  , searchDrinks200ResponseDrinksInnerNutritionIngredientBreakdownInnerUnit :: !(Maybe Text) -- ^ "unit"
  , searchDrinks200ResponseDrinksInnerNutritionIngredientBreakdownInnerId :: !(Maybe Int) -- ^ "id"
  , searchDrinks200ResponseDrinksInnerNutritionIngredientBreakdownInnerNutrients :: !(Maybe [SearchDrinks200ResponseDrinksInnerNutritionIngredientBreakdownInnerNutrientsInner]) -- ^ "nutrients"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SearchDrinks200ResponseDrinksInnerNutritionIngredientBreakdownInner
instance A.FromJSON SearchDrinks200ResponseDrinksInnerNutritionIngredientBreakdownInner where
  parseJSON = A.withObject "SearchDrinks200ResponseDrinksInnerNutritionIngredientBreakdownInner" $ \o ->
    SearchDrinks200ResponseDrinksInnerNutritionIngredientBreakdownInner
      <$> (o .:? "name")
      <*> (o .:? "amount")
      <*> (o .:? "unit")
      <*> (o .:? "id")
      <*> (o .:? "nutrients")

-- | ToJSON SearchDrinks200ResponseDrinksInnerNutritionIngredientBreakdownInner
instance A.ToJSON SearchDrinks200ResponseDrinksInnerNutritionIngredientBreakdownInner where
  toJSON SearchDrinks200ResponseDrinksInnerNutritionIngredientBreakdownInner {..} =
   _omitNulls
      [ "name" .= searchDrinks200ResponseDrinksInnerNutritionIngredientBreakdownInnerName
      , "amount" .= searchDrinks200ResponseDrinksInnerNutritionIngredientBreakdownInnerAmount
      , "unit" .= searchDrinks200ResponseDrinksInnerNutritionIngredientBreakdownInnerUnit
      , "id" .= searchDrinks200ResponseDrinksInnerNutritionIngredientBreakdownInnerId
      , "nutrients" .= searchDrinks200ResponseDrinksInnerNutritionIngredientBreakdownInnerNutrients
      ]


-- | Construct a value of type 'SearchDrinks200ResponseDrinksInnerNutritionIngredientBreakdownInner' (by applying it's required fields, if any)
mkSearchDrinks200ResponseDrinksInnerNutritionIngredientBreakdownInner
  :: SearchDrinks200ResponseDrinksInnerNutritionIngredientBreakdownInner
mkSearchDrinks200ResponseDrinksInnerNutritionIngredientBreakdownInner =
  SearchDrinks200ResponseDrinksInnerNutritionIngredientBreakdownInner
  { searchDrinks200ResponseDrinksInnerNutritionIngredientBreakdownInnerName = Nothing
  , searchDrinks200ResponseDrinksInnerNutritionIngredientBreakdownInnerAmount = Nothing
  , searchDrinks200ResponseDrinksInnerNutritionIngredientBreakdownInnerUnit = Nothing
  , searchDrinks200ResponseDrinksInnerNutritionIngredientBreakdownInnerId = Nothing
  , searchDrinks200ResponseDrinksInnerNutritionIngredientBreakdownInnerNutrients = Nothing
  }

-- ** SearchDrinks200ResponseDrinksInnerNutritionIngredientBreakdownInnerNutrientsInner
-- | SearchDrinks200ResponseDrinksInnerNutritionIngredientBreakdownInnerNutrientsInner
data SearchDrinks200ResponseDrinksInnerNutritionIngredientBreakdownInnerNutrientsInner = SearchDrinks200ResponseDrinksInnerNutritionIngredientBreakdownInnerNutrientsInner
  { searchDrinks200ResponseDrinksInnerNutritionIngredientBreakdownInnerNutrientsInnerName :: !(Maybe Text) -- ^ "name"
  , searchDrinks200ResponseDrinksInnerNutritionIngredientBreakdownInnerNutrientsInnerPercentOfDailyNeeds :: !(Maybe Double) -- ^ "percent_of_daily_needs"
  , searchDrinks200ResponseDrinksInnerNutritionIngredientBreakdownInnerNutrientsInnerAmount :: !(Maybe Int) -- ^ "amount"
  , searchDrinks200ResponseDrinksInnerNutritionIngredientBreakdownInnerNutrientsInnerUnit :: !(Maybe Text) -- ^ "unit"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SearchDrinks200ResponseDrinksInnerNutritionIngredientBreakdownInnerNutrientsInner
instance A.FromJSON SearchDrinks200ResponseDrinksInnerNutritionIngredientBreakdownInnerNutrientsInner where
  parseJSON = A.withObject "SearchDrinks200ResponseDrinksInnerNutritionIngredientBreakdownInnerNutrientsInner" $ \o ->
    SearchDrinks200ResponseDrinksInnerNutritionIngredientBreakdownInnerNutrientsInner
      <$> (o .:? "name")
      <*> (o .:? "percent_of_daily_needs")
      <*> (o .:? "amount")
      <*> (o .:? "unit")

-- | ToJSON SearchDrinks200ResponseDrinksInnerNutritionIngredientBreakdownInnerNutrientsInner
instance A.ToJSON SearchDrinks200ResponseDrinksInnerNutritionIngredientBreakdownInnerNutrientsInner where
  toJSON SearchDrinks200ResponseDrinksInnerNutritionIngredientBreakdownInnerNutrientsInner {..} =
   _omitNulls
      [ "name" .= searchDrinks200ResponseDrinksInnerNutritionIngredientBreakdownInnerNutrientsInnerName
      , "percent_of_daily_needs" .= searchDrinks200ResponseDrinksInnerNutritionIngredientBreakdownInnerNutrientsInnerPercentOfDailyNeeds
      , "amount" .= searchDrinks200ResponseDrinksInnerNutritionIngredientBreakdownInnerNutrientsInnerAmount
      , "unit" .= searchDrinks200ResponseDrinksInnerNutritionIngredientBreakdownInnerNutrientsInnerUnit
      ]


-- | Construct a value of type 'SearchDrinks200ResponseDrinksInnerNutritionIngredientBreakdownInnerNutrientsInner' (by applying it's required fields, if any)
mkSearchDrinks200ResponseDrinksInnerNutritionIngredientBreakdownInnerNutrientsInner
  :: SearchDrinks200ResponseDrinksInnerNutritionIngredientBreakdownInnerNutrientsInner
mkSearchDrinks200ResponseDrinksInnerNutritionIngredientBreakdownInnerNutrientsInner =
  SearchDrinks200ResponseDrinksInnerNutritionIngredientBreakdownInnerNutrientsInner
  { searchDrinks200ResponseDrinksInnerNutritionIngredientBreakdownInnerNutrientsInnerName = Nothing
  , searchDrinks200ResponseDrinksInnerNutritionIngredientBreakdownInnerNutrientsInnerPercentOfDailyNeeds = Nothing
  , searchDrinks200ResponseDrinksInnerNutritionIngredientBreakdownInnerNutrientsInnerAmount = Nothing
  , searchDrinks200ResponseDrinksInnerNutritionIngredientBreakdownInnerNutrientsInnerUnit = Nothing
  }

-- ** SearchDrinks200ResponseDrinksInnerNutritionNutrientsInner
-- | SearchDrinks200ResponseDrinksInnerNutritionNutrientsInner
data SearchDrinks200ResponseDrinksInnerNutritionNutrientsInner = SearchDrinks200ResponseDrinksInnerNutritionNutrientsInner
  { searchDrinks200ResponseDrinksInnerNutritionNutrientsInnerName :: !(Maybe Text) -- ^ "name"
  , searchDrinks200ResponseDrinksInnerNutritionNutrientsInnerPercentOfDailyNeeds :: !(Maybe Double) -- ^ "percent_of_daily_needs"
  , searchDrinks200ResponseDrinksInnerNutritionNutrientsInnerAmount :: !(Maybe Double) -- ^ "amount"
  , searchDrinks200ResponseDrinksInnerNutritionNutrientsInnerUnit :: !(Maybe Text) -- ^ "unit"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SearchDrinks200ResponseDrinksInnerNutritionNutrientsInner
instance A.FromJSON SearchDrinks200ResponseDrinksInnerNutritionNutrientsInner where
  parseJSON = A.withObject "SearchDrinks200ResponseDrinksInnerNutritionNutrientsInner" $ \o ->
    SearchDrinks200ResponseDrinksInnerNutritionNutrientsInner
      <$> (o .:? "name")
      <*> (o .:? "percent_of_daily_needs")
      <*> (o .:? "amount")
      <*> (o .:? "unit")

-- | ToJSON SearchDrinks200ResponseDrinksInnerNutritionNutrientsInner
instance A.ToJSON SearchDrinks200ResponseDrinksInnerNutritionNutrientsInner where
  toJSON SearchDrinks200ResponseDrinksInnerNutritionNutrientsInner {..} =
   _omitNulls
      [ "name" .= searchDrinks200ResponseDrinksInnerNutritionNutrientsInnerName
      , "percent_of_daily_needs" .= searchDrinks200ResponseDrinksInnerNutritionNutrientsInnerPercentOfDailyNeeds
      , "amount" .= searchDrinks200ResponseDrinksInnerNutritionNutrientsInnerAmount
      , "unit" .= searchDrinks200ResponseDrinksInnerNutritionNutrientsInnerUnit
      ]


-- | Construct a value of type 'SearchDrinks200ResponseDrinksInnerNutritionNutrientsInner' (by applying it's required fields, if any)
mkSearchDrinks200ResponseDrinksInnerNutritionNutrientsInner
  :: SearchDrinks200ResponseDrinksInnerNutritionNutrientsInner
mkSearchDrinks200ResponseDrinksInnerNutritionNutrientsInner =
  SearchDrinks200ResponseDrinksInnerNutritionNutrientsInner
  { searchDrinks200ResponseDrinksInnerNutritionNutrientsInnerName = Nothing
  , searchDrinks200ResponseDrinksInnerNutritionNutrientsInnerPercentOfDailyNeeds = Nothing
  , searchDrinks200ResponseDrinksInnerNutritionNutrientsInnerAmount = Nothing
  , searchDrinks200ResponseDrinksInnerNutritionNutrientsInnerUnit = Nothing
  }

-- ** SearchDrinks200ResponseDrinksInnerNutritionWeightPerServing
-- | SearchDrinks200ResponseDrinksInnerNutritionWeightPerServing
data SearchDrinks200ResponseDrinksInnerNutritionWeightPerServing = SearchDrinks200ResponseDrinksInnerNutritionWeightPerServing
  { searchDrinks200ResponseDrinksInnerNutritionWeightPerServingAmount :: !(Maybe Int) -- ^ "amount"
  , searchDrinks200ResponseDrinksInnerNutritionWeightPerServingUnit :: !(Maybe Text) -- ^ "unit"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SearchDrinks200ResponseDrinksInnerNutritionWeightPerServing
instance A.FromJSON SearchDrinks200ResponseDrinksInnerNutritionWeightPerServing where
  parseJSON = A.withObject "SearchDrinks200ResponseDrinksInnerNutritionWeightPerServing" $ \o ->
    SearchDrinks200ResponseDrinksInnerNutritionWeightPerServing
      <$> (o .:? "amount")
      <*> (o .:? "unit")

-- | ToJSON SearchDrinks200ResponseDrinksInnerNutritionWeightPerServing
instance A.ToJSON SearchDrinks200ResponseDrinksInnerNutritionWeightPerServing where
  toJSON SearchDrinks200ResponseDrinksInnerNutritionWeightPerServing {..} =
   _omitNulls
      [ "amount" .= searchDrinks200ResponseDrinksInnerNutritionWeightPerServingAmount
      , "unit" .= searchDrinks200ResponseDrinksInnerNutritionWeightPerServingUnit
      ]


-- | Construct a value of type 'SearchDrinks200ResponseDrinksInnerNutritionWeightPerServing' (by applying it's required fields, if any)
mkSearchDrinks200ResponseDrinksInnerNutritionWeightPerServing
  :: SearchDrinks200ResponseDrinksInnerNutritionWeightPerServing
mkSearchDrinks200ResponseDrinksInnerNutritionWeightPerServing =
  SearchDrinks200ResponseDrinksInnerNutritionWeightPerServing
  { searchDrinks200ResponseDrinksInnerNutritionWeightPerServingAmount = Nothing
  , searchDrinks200ResponseDrinksInnerNutritionWeightPerServingUnit = Nothing
  }

-- ** SearchGifs200Response
-- | SearchGifs200Response
data SearchGifs200Response = SearchGifs200Response
  { searchGifs200ResponseImages :: !(Maybe [SearchGifs200ResponseImagesInner]) -- ^ "images"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SearchGifs200Response
instance A.FromJSON SearchGifs200Response where
  parseJSON = A.withObject "SearchGifs200Response" $ \o ->
    SearchGifs200Response
      <$> (o .:? "images")

-- | ToJSON SearchGifs200Response
instance A.ToJSON SearchGifs200Response where
  toJSON SearchGifs200Response {..} =
   _omitNulls
      [ "images" .= searchGifs200ResponseImages
      ]


-- | Construct a value of type 'SearchGifs200Response' (by applying it's required fields, if any)
mkSearchGifs200Response
  :: SearchGifs200Response
mkSearchGifs200Response =
  SearchGifs200Response
  { searchGifs200ResponseImages = Nothing
  }

-- ** SearchGifs200ResponseImagesInner
-- | SearchGifs200ResponseImagesInner
data SearchGifs200ResponseImagesInner = SearchGifs200ResponseImagesInner
  { searchGifs200ResponseImagesInnerWidth :: !(Maybe Int) -- ^ "width"
  , searchGifs200ResponseImagesInnerUrl :: !(Maybe Text) -- ^ "url"
  , searchGifs200ResponseImagesInnerHeight :: !(Maybe Int) -- ^ "height"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SearchGifs200ResponseImagesInner
instance A.FromJSON SearchGifs200ResponseImagesInner where
  parseJSON = A.withObject "SearchGifs200ResponseImagesInner" $ \o ->
    SearchGifs200ResponseImagesInner
      <$> (o .:? "width")
      <*> (o .:? "url")
      <*> (o .:? "height")

-- | ToJSON SearchGifs200ResponseImagesInner
instance A.ToJSON SearchGifs200ResponseImagesInner where
  toJSON SearchGifs200ResponseImagesInner {..} =
   _omitNulls
      [ "width" .= searchGifs200ResponseImagesInnerWidth
      , "url" .= searchGifs200ResponseImagesInnerUrl
      , "height" .= searchGifs200ResponseImagesInnerHeight
      ]


-- | Construct a value of type 'SearchGifs200ResponseImagesInner' (by applying it's required fields, if any)
mkSearchGifs200ResponseImagesInner
  :: SearchGifs200ResponseImagesInner
mkSearchGifs200ResponseImagesInner =
  SearchGifs200ResponseImagesInner
  { searchGifs200ResponseImagesInnerWidth = Nothing
  , searchGifs200ResponseImagesInnerUrl = Nothing
  , searchGifs200ResponseImagesInnerHeight = Nothing
  }

-- ** SearchIcons200Response
-- | SearchIcons200Response
data SearchIcons200Response = SearchIcons200Response
  { searchIcons200ResponseIcons :: !(Maybe [SearchRoyaltyFreeImages200ResponseImagesInner]) -- ^ "icons"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SearchIcons200Response
instance A.FromJSON SearchIcons200Response where
  parseJSON = A.withObject "SearchIcons200Response" $ \o ->
    SearchIcons200Response
      <$> (o .:? "icons")

-- | ToJSON SearchIcons200Response
instance A.ToJSON SearchIcons200Response where
  toJSON SearchIcons200Response {..} =
   _omitNulls
      [ "icons" .= searchIcons200ResponseIcons
      ]


-- | Construct a value of type 'SearchIcons200Response' (by applying it's required fields, if any)
mkSearchIcons200Response
  :: SearchIcons200Response
mkSearchIcons200Response =
  SearchIcons200Response
  { searchIcons200ResponseIcons = Nothing
  }

-- ** SearchJokes200Response
-- | SearchJokes200Response
data SearchJokes200Response = SearchJokes200Response
  { searchJokes200ResponseJokes :: !(Maybe [SearchJokes200ResponseJokesInner]) -- ^ "jokes"
  , searchJokes200ResponseAvailable :: !(Maybe Int) -- ^ "available"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SearchJokes200Response
instance A.FromJSON SearchJokes200Response where
  parseJSON = A.withObject "SearchJokes200Response" $ \o ->
    SearchJokes200Response
      <$> (o .:? "jokes")
      <*> (o .:? "available")

-- | ToJSON SearchJokes200Response
instance A.ToJSON SearchJokes200Response where
  toJSON SearchJokes200Response {..} =
   _omitNulls
      [ "jokes" .= searchJokes200ResponseJokes
      , "available" .= searchJokes200ResponseAvailable
      ]


-- | Construct a value of type 'SearchJokes200Response' (by applying it's required fields, if any)
mkSearchJokes200Response
  :: SearchJokes200Response
mkSearchJokes200Response =
  SearchJokes200Response
  { searchJokes200ResponseJokes = Nothing
  , searchJokes200ResponseAvailable = Nothing
  }

-- ** SearchJokes200ResponseJokesInner
-- | SearchJokes200ResponseJokesInner
data SearchJokes200ResponseJokesInner = SearchJokes200ResponseJokesInner
  { searchJokes200ResponseJokesInnerJoke :: !(Maybe Text) -- ^ "joke"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SearchJokes200ResponseJokesInner
instance A.FromJSON SearchJokes200ResponseJokesInner where
  parseJSON = A.withObject "SearchJokes200ResponseJokesInner" $ \o ->
    SearchJokes200ResponseJokesInner
      <$> (o .:? "joke")

-- | ToJSON SearchJokes200ResponseJokesInner
instance A.ToJSON SearchJokes200ResponseJokesInner where
  toJSON SearchJokes200ResponseJokesInner {..} =
   _omitNulls
      [ "joke" .= searchJokes200ResponseJokesInnerJoke
      ]


-- | Construct a value of type 'SearchJokes200ResponseJokesInner' (by applying it's required fields, if any)
mkSearchJokes200ResponseJokesInner
  :: SearchJokes200ResponseJokesInner
mkSearchJokes200ResponseJokesInner =
  SearchJokes200ResponseJokesInner
  { searchJokes200ResponseJokesInnerJoke = Nothing
  }

-- ** SearchMemes200Response
-- | SearchMemes200Response
data SearchMemes200Response = SearchMemes200Response
  { searchMemes200ResponseMemes :: !(Maybe [SearchMemes200ResponseMemesInner]) -- ^ "memes"
  , searchMemes200ResponseAvailable :: !(Maybe Int) -- ^ "available"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SearchMemes200Response
instance A.FromJSON SearchMemes200Response where
  parseJSON = A.withObject "SearchMemes200Response" $ \o ->
    SearchMemes200Response
      <$> (o .:? "memes")
      <*> (o .:? "available")

-- | ToJSON SearchMemes200Response
instance A.ToJSON SearchMemes200Response where
  toJSON SearchMemes200Response {..} =
   _omitNulls
      [ "memes" .= searchMemes200ResponseMemes
      , "available" .= searchMemes200ResponseAvailable
      ]


-- | Construct a value of type 'SearchMemes200Response' (by applying it's required fields, if any)
mkSearchMemes200Response
  :: SearchMemes200Response
mkSearchMemes200Response =
  SearchMemes200Response
  { searchMemes200ResponseMemes = Nothing
  , searchMemes200ResponseAvailable = Nothing
  }

-- ** SearchMemes200ResponseMemesInner
-- | SearchMemes200ResponseMemesInner
data SearchMemes200ResponseMemesInner = SearchMemes200ResponseMemesInner
  { searchMemes200ResponseMemesInnerType :: !(Maybe Text) -- ^ "type"
  , searchMemes200ResponseMemesInnerDescription :: !(Maybe Text) -- ^ "description"
  , searchMemes200ResponseMemesInnerUrl :: !(Maybe Text) -- ^ "url"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SearchMemes200ResponseMemesInner
instance A.FromJSON SearchMemes200ResponseMemesInner where
  parseJSON = A.withObject "SearchMemes200ResponseMemesInner" $ \o ->
    SearchMemes200ResponseMemesInner
      <$> (o .:? "type")
      <*> (o .:? "description")
      <*> (o .:? "url")

-- | ToJSON SearchMemes200ResponseMemesInner
instance A.ToJSON SearchMemes200ResponseMemesInner where
  toJSON SearchMemes200ResponseMemesInner {..} =
   _omitNulls
      [ "type" .= searchMemes200ResponseMemesInnerType
      , "description" .= searchMemes200ResponseMemesInnerDescription
      , "url" .= searchMemes200ResponseMemesInnerUrl
      ]


-- | Construct a value of type 'SearchMemes200ResponseMemesInner' (by applying it's required fields, if any)
mkSearchMemes200ResponseMemesInner
  :: SearchMemes200ResponseMemesInner
mkSearchMemes200ResponseMemesInner =
  SearchMemes200ResponseMemesInner
  { searchMemes200ResponseMemesInnerType = Nothing
  , searchMemes200ResponseMemesInnerDescription = Nothing
  , searchMemes200ResponseMemesInnerUrl = Nothing
  }

-- ** SearchNews200Response
-- | SearchNews200Response
data SearchNews200Response = SearchNews200Response
  { searchNews200ResponseOffset :: !(Maybe Int) -- ^ "offset"
  , searchNews200ResponseNumber :: !(Maybe Int) -- ^ "number"
  , searchNews200ResponseAvailable :: !(Maybe Int) -- ^ "available"
  , searchNews200ResponseNews :: !(Maybe [SearchNews200ResponseNewsInner]) -- ^ "news"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SearchNews200Response
instance A.FromJSON SearchNews200Response where
  parseJSON = A.withObject "SearchNews200Response" $ \o ->
    SearchNews200Response
      <$> (o .:? "offset")
      <*> (o .:? "number")
      <*> (o .:? "available")
      <*> (o .:? "news")

-- | ToJSON SearchNews200Response
instance A.ToJSON SearchNews200Response where
  toJSON SearchNews200Response {..} =
   _omitNulls
      [ "offset" .= searchNews200ResponseOffset
      , "number" .= searchNews200ResponseNumber
      , "available" .= searchNews200ResponseAvailable
      , "news" .= searchNews200ResponseNews
      ]


-- | Construct a value of type 'SearchNews200Response' (by applying it's required fields, if any)
mkSearchNews200Response
  :: SearchNews200Response
mkSearchNews200Response =
  SearchNews200Response
  { searchNews200ResponseOffset = Nothing
  , searchNews200ResponseNumber = Nothing
  , searchNews200ResponseAvailable = Nothing
  , searchNews200ResponseNews = Nothing
  }

-- ** SearchNews200ResponseNewsInner
-- | SearchNews200ResponseNewsInner
data SearchNews200ResponseNewsInner = SearchNews200ResponseNewsInner
  { searchNews200ResponseNewsInnerSummary :: !(Maybe Text) -- ^ "summary"
  , searchNews200ResponseNewsInnerImage :: !(Maybe Text) -- ^ "image"
  , searchNews200ResponseNewsInnerSentiment :: !(Maybe Double) -- ^ "sentiment"
  , searchNews200ResponseNewsInnerLanguage :: !(Maybe Text) -- ^ "language"
  , searchNews200ResponseNewsInnerVideo :: !(Maybe Text) -- ^ "video"
  , searchNews200ResponseNewsInnerTitle :: !(Maybe Text) -- ^ "title"
  , searchNews200ResponseNewsInnerUrl :: !(Maybe Text) -- ^ "url"
  , searchNews200ResponseNewsInnerSourceCountry :: !(Maybe Text) -- ^ "source_country"
  , searchNews200ResponseNewsInnerId :: !(Maybe Int) -- ^ "id"
  , searchNews200ResponseNewsInnerText :: !(Maybe Text) -- ^ "text"
  , searchNews200ResponseNewsInnerCategory :: !(Maybe Text) -- ^ "category"
  , searchNews200ResponseNewsInnerPublishDate :: !(Maybe Text) -- ^ "publish_date"
  , searchNews200ResponseNewsInnerAuthors :: !(Maybe [Text]) -- ^ "authors"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SearchNews200ResponseNewsInner
instance A.FromJSON SearchNews200ResponseNewsInner where
  parseJSON = A.withObject "SearchNews200ResponseNewsInner" $ \o ->
    SearchNews200ResponseNewsInner
      <$> (o .:? "summary")
      <*> (o .:? "image")
      <*> (o .:? "sentiment")
      <*> (o .:? "language")
      <*> (o .:? "video")
      <*> (o .:? "title")
      <*> (o .:? "url")
      <*> (o .:? "source_country")
      <*> (o .:? "id")
      <*> (o .:? "text")
      <*> (o .:? "category")
      <*> (o .:? "publish_date")
      <*> (o .:? "authors")

-- | ToJSON SearchNews200ResponseNewsInner
instance A.ToJSON SearchNews200ResponseNewsInner where
  toJSON SearchNews200ResponseNewsInner {..} =
   _omitNulls
      [ "summary" .= searchNews200ResponseNewsInnerSummary
      , "image" .= searchNews200ResponseNewsInnerImage
      , "sentiment" .= searchNews200ResponseNewsInnerSentiment
      , "language" .= searchNews200ResponseNewsInnerLanguage
      , "video" .= searchNews200ResponseNewsInnerVideo
      , "title" .= searchNews200ResponseNewsInnerTitle
      , "url" .= searchNews200ResponseNewsInnerUrl
      , "source_country" .= searchNews200ResponseNewsInnerSourceCountry
      , "id" .= searchNews200ResponseNewsInnerId
      , "text" .= searchNews200ResponseNewsInnerText
      , "category" .= searchNews200ResponseNewsInnerCategory
      , "publish_date" .= searchNews200ResponseNewsInnerPublishDate
      , "authors" .= searchNews200ResponseNewsInnerAuthors
      ]


-- | Construct a value of type 'SearchNews200ResponseNewsInner' (by applying it's required fields, if any)
mkSearchNews200ResponseNewsInner
  :: SearchNews200ResponseNewsInner
mkSearchNews200ResponseNewsInner =
  SearchNews200ResponseNewsInner
  { searchNews200ResponseNewsInnerSummary = Nothing
  , searchNews200ResponseNewsInnerImage = Nothing
  , searchNews200ResponseNewsInnerSentiment = Nothing
  , searchNews200ResponseNewsInnerLanguage = Nothing
  , searchNews200ResponseNewsInnerVideo = Nothing
  , searchNews200ResponseNewsInnerTitle = Nothing
  , searchNews200ResponseNewsInnerUrl = Nothing
  , searchNews200ResponseNewsInnerSourceCountry = Nothing
  , searchNews200ResponseNewsInnerId = Nothing
  , searchNews200ResponseNewsInnerText = Nothing
  , searchNews200ResponseNewsInnerCategory = Nothing
  , searchNews200ResponseNewsInnerPublishDate = Nothing
  , searchNews200ResponseNewsInnerAuthors = Nothing
  }

-- ** SearchRecipes200Response
-- | SearchRecipes200Response
data SearchRecipes200Response = SearchRecipes200Response
  { searchRecipes200ResponseOffset :: !(Maybe Int) -- ^ "offset"
  , searchRecipes200ResponseNumber :: !(Maybe Int) -- ^ "number"
  , searchRecipes200ResponseRecipes :: !(Maybe [SearchRecipes200ResponseRecipesInner]) -- ^ "recipes"
  , searchRecipes200ResponseTotalResults :: !(Maybe Int) -- ^ "total_results"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SearchRecipes200Response
instance A.FromJSON SearchRecipes200Response where
  parseJSON = A.withObject "SearchRecipes200Response" $ \o ->
    SearchRecipes200Response
      <$> (o .:? "offset")
      <*> (o .:? "number")
      <*> (o .:? "recipes")
      <*> (o .:? "total_results")

-- | ToJSON SearchRecipes200Response
instance A.ToJSON SearchRecipes200Response where
  toJSON SearchRecipes200Response {..} =
   _omitNulls
      [ "offset" .= searchRecipes200ResponseOffset
      , "number" .= searchRecipes200ResponseNumber
      , "recipes" .= searchRecipes200ResponseRecipes
      , "total_results" .= searchRecipes200ResponseTotalResults
      ]


-- | Construct a value of type 'SearchRecipes200Response' (by applying it's required fields, if any)
mkSearchRecipes200Response
  :: SearchRecipes200Response
mkSearchRecipes200Response =
  SearchRecipes200Response
  { searchRecipes200ResponseOffset = Nothing
  , searchRecipes200ResponseNumber = Nothing
  , searchRecipes200ResponseRecipes = Nothing
  , searchRecipes200ResponseTotalResults = Nothing
  }

-- ** SearchRecipes200ResponseRecipesInner
-- | SearchRecipes200ResponseRecipesInner
data SearchRecipes200ResponseRecipesInner = SearchRecipes200ResponseRecipesInner
  { searchRecipes200ResponseRecipesInnerImages :: !(Maybe [Text]) -- ^ "images"
  , searchRecipes200ResponseRecipesInnerNutrition :: !(Maybe SearchRecipes200ResponseRecipesInnerNutrition) -- ^ "nutrition"
  , searchRecipes200ResponseRecipesInnerId :: !(Maybe Int) -- ^ "id"
  , searchRecipes200ResponseRecipesInnerTitle :: !(Maybe Text) -- ^ "title"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SearchRecipes200ResponseRecipesInner
instance A.FromJSON SearchRecipes200ResponseRecipesInner where
  parseJSON = A.withObject "SearchRecipes200ResponseRecipesInner" $ \o ->
    SearchRecipes200ResponseRecipesInner
      <$> (o .:? "images")
      <*> (o .:? "nutrition")
      <*> (o .:? "id")
      <*> (o .:? "title")

-- | ToJSON SearchRecipes200ResponseRecipesInner
instance A.ToJSON SearchRecipes200ResponseRecipesInner where
  toJSON SearchRecipes200ResponseRecipesInner {..} =
   _omitNulls
      [ "images" .= searchRecipes200ResponseRecipesInnerImages
      , "nutrition" .= searchRecipes200ResponseRecipesInnerNutrition
      , "id" .= searchRecipes200ResponseRecipesInnerId
      , "title" .= searchRecipes200ResponseRecipesInnerTitle
      ]


-- | Construct a value of type 'SearchRecipes200ResponseRecipesInner' (by applying it's required fields, if any)
mkSearchRecipes200ResponseRecipesInner
  :: SearchRecipes200ResponseRecipesInner
mkSearchRecipes200ResponseRecipesInner =
  SearchRecipes200ResponseRecipesInner
  { searchRecipes200ResponseRecipesInnerImages = Nothing
  , searchRecipes200ResponseRecipesInnerNutrition = Nothing
  , searchRecipes200ResponseRecipesInnerId = Nothing
  , searchRecipes200ResponseRecipesInnerTitle = Nothing
  }

-- ** SearchRecipes200ResponseRecipesInnerNutrition
-- | SearchRecipes200ResponseRecipesInnerNutrition
data SearchRecipes200ResponseRecipesInnerNutrition = SearchRecipes200ResponseRecipesInnerNutrition
  { searchRecipes200ResponseRecipesInnerNutritionNutrients :: !(Maybe [SearchRecipes200ResponseRecipesInnerNutritionNutrientsInner]) -- ^ "nutrients"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SearchRecipes200ResponseRecipesInnerNutrition
instance A.FromJSON SearchRecipes200ResponseRecipesInnerNutrition where
  parseJSON = A.withObject "SearchRecipes200ResponseRecipesInnerNutrition" $ \o ->
    SearchRecipes200ResponseRecipesInnerNutrition
      <$> (o .:? "nutrients")

-- | ToJSON SearchRecipes200ResponseRecipesInnerNutrition
instance A.ToJSON SearchRecipes200ResponseRecipesInnerNutrition where
  toJSON SearchRecipes200ResponseRecipesInnerNutrition {..} =
   _omitNulls
      [ "nutrients" .= searchRecipes200ResponseRecipesInnerNutritionNutrients
      ]


-- | Construct a value of type 'SearchRecipes200ResponseRecipesInnerNutrition' (by applying it's required fields, if any)
mkSearchRecipes200ResponseRecipesInnerNutrition
  :: SearchRecipes200ResponseRecipesInnerNutrition
mkSearchRecipes200ResponseRecipesInnerNutrition =
  SearchRecipes200ResponseRecipesInnerNutrition
  { searchRecipes200ResponseRecipesInnerNutritionNutrients = Nothing
  }

-- ** SearchRecipes200ResponseRecipesInnerNutritionNutrientsInner
-- | SearchRecipes200ResponseRecipesInnerNutritionNutrientsInner
data SearchRecipes200ResponseRecipesInnerNutritionNutrientsInner = SearchRecipes200ResponseRecipesInnerNutritionNutrientsInner
  { searchRecipes200ResponseRecipesInnerNutritionNutrientsInnerName :: !(Maybe Text) -- ^ "name"
  , searchRecipes200ResponseRecipesInnerNutritionNutrientsInnerAmount :: !(Maybe Double) -- ^ "amount"
  , searchRecipes200ResponseRecipesInnerNutritionNutrientsInnerUnit :: !(Maybe Text) -- ^ "unit"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SearchRecipes200ResponseRecipesInnerNutritionNutrientsInner
instance A.FromJSON SearchRecipes200ResponseRecipesInnerNutritionNutrientsInner where
  parseJSON = A.withObject "SearchRecipes200ResponseRecipesInnerNutritionNutrientsInner" $ \o ->
    SearchRecipes200ResponseRecipesInnerNutritionNutrientsInner
      <$> (o .:? "name")
      <*> (o .:? "amount")
      <*> (o .:? "unit")

-- | ToJSON SearchRecipes200ResponseRecipesInnerNutritionNutrientsInner
instance A.ToJSON SearchRecipes200ResponseRecipesInnerNutritionNutrientsInner where
  toJSON SearchRecipes200ResponseRecipesInnerNutritionNutrientsInner {..} =
   _omitNulls
      [ "name" .= searchRecipes200ResponseRecipesInnerNutritionNutrientsInnerName
      , "amount" .= searchRecipes200ResponseRecipesInnerNutritionNutrientsInnerAmount
      , "unit" .= searchRecipes200ResponseRecipesInnerNutritionNutrientsInnerUnit
      ]


-- | Construct a value of type 'SearchRecipes200ResponseRecipesInnerNutritionNutrientsInner' (by applying it's required fields, if any)
mkSearchRecipes200ResponseRecipesInnerNutritionNutrientsInner
  :: SearchRecipes200ResponseRecipesInnerNutritionNutrientsInner
mkSearchRecipes200ResponseRecipesInnerNutritionNutrientsInner =
  SearchRecipes200ResponseRecipesInnerNutritionNutrientsInner
  { searchRecipes200ResponseRecipesInnerNutritionNutrientsInnerName = Nothing
  , searchRecipes200ResponseRecipesInnerNutritionNutrientsInnerAmount = Nothing
  , searchRecipes200ResponseRecipesInnerNutritionNutrientsInnerUnit = Nothing
  }

-- ** SearchRestaurants200Response
-- | SearchRestaurants200Response
data SearchRestaurants200Response = SearchRestaurants200Response
  { searchRestaurants200ResponseRestaurants :: !(Maybe [SearchRestaurants200ResponseRestaurantsInner]) -- ^ "restaurants"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SearchRestaurants200Response
instance A.FromJSON SearchRestaurants200Response where
  parseJSON = A.withObject "SearchRestaurants200Response" $ \o ->
    SearchRestaurants200Response
      <$> (o .:? "restaurants")

-- | ToJSON SearchRestaurants200Response
instance A.ToJSON SearchRestaurants200Response where
  toJSON SearchRestaurants200Response {..} =
   _omitNulls
      [ "restaurants" .= searchRestaurants200ResponseRestaurants
      ]


-- | Construct a value of type 'SearchRestaurants200Response' (by applying it's required fields, if any)
mkSearchRestaurants200Response
  :: SearchRestaurants200Response
mkSearchRestaurants200Response =
  SearchRestaurants200Response
  { searchRestaurants200ResponseRestaurants = Nothing
  }

-- ** SearchRestaurants200ResponseRestaurantsInner
-- | SearchRestaurants200ResponseRestaurantsInner
data SearchRestaurants200ResponseRestaurantsInner = SearchRestaurants200ResponseRestaurantsInner
  { searchRestaurants200ResponseRestaurantsInnerOffersThirdPartyDelivery :: !(Maybe Bool) -- ^ "offers_third_party_delivery"
  , searchRestaurants200ResponseRestaurantsInnerAddress :: !(Maybe SearchRestaurants200ResponseRestaurantsInnerAddress) -- ^ "address"
  , searchRestaurants200ResponseRestaurantsInnerSupportsUpcCodes :: !(Maybe Bool) -- ^ "supports_upc_codes"
  , searchRestaurants200ResponseRestaurantsInnerIsOpen :: !(Maybe Bool) -- ^ "is_open"
  , searchRestaurants200ResponseRestaurantsInnerDescription :: !(Maybe Text) -- ^ "description"
  , searchRestaurants200ResponseRestaurantsInnerWeightedRatingValue :: !(Maybe Int) -- ^ "weighted_rating_value"
  , searchRestaurants200ResponseRestaurantsInnerType :: !(Maybe Text) -- ^ "type"
  , searchRestaurants200ResponseRestaurantsInnerOffersFirstPartyDelivery :: !(Maybe Bool) -- ^ "offers_first_party_delivery"
  , searchRestaurants200ResponseRestaurantsInnerAggregatedRatingCount :: !(Maybe Int) -- ^ "aggregated_rating_count"
  , searchRestaurants200ResponseRestaurantsInnerPickupEnabled :: !(Maybe Bool) -- ^ "pickup_enabled"
  , searchRestaurants200ResponseRestaurantsInnerCuisines :: !(Maybe [Text]) -- ^ "cuisines"
  , searchRestaurants200ResponseRestaurantsInnerMiles :: !(Maybe Double) -- ^ "miles"
  , searchRestaurants200ResponseRestaurantsInnerDollarSigns :: !(Maybe Int) -- ^ "dollar_signs"
  , searchRestaurants200ResponseRestaurantsInnerDeliveryEnabled :: !(Maybe Bool) -- ^ "delivery_enabled"
  , searchRestaurants200ResponseRestaurantsInnerName :: !(Maybe Text) -- ^ "name"
  , searchRestaurants200ResponseRestaurantsInnerPhoneNumber :: !(Maybe Double) -- ^ "phone_number"
  , searchRestaurants200ResponseRestaurantsInnerId :: !(Maybe Text) -- ^ "_id"
  , searchRestaurants200ResponseRestaurantsInnerLocalHours :: !(Maybe SearchRestaurants200ResponseRestaurantsInnerLocalHours) -- ^ "local_hours"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SearchRestaurants200ResponseRestaurantsInner
instance A.FromJSON SearchRestaurants200ResponseRestaurantsInner where
  parseJSON = A.withObject "SearchRestaurants200ResponseRestaurantsInner" $ \o ->
    SearchRestaurants200ResponseRestaurantsInner
      <$> (o .:? "offers_third_party_delivery")
      <*> (o .:? "address")
      <*> (o .:? "supports_upc_codes")
      <*> (o .:? "is_open")
      <*> (o .:? "description")
      <*> (o .:? "weighted_rating_value")
      <*> (o .:? "type")
      <*> (o .:? "offers_first_party_delivery")
      <*> (o .:? "aggregated_rating_count")
      <*> (o .:? "pickup_enabled")
      <*> (o .:? "cuisines")
      <*> (o .:? "miles")
      <*> (o .:? "dollar_signs")
      <*> (o .:? "delivery_enabled")
      <*> (o .:? "name")
      <*> (o .:? "phone_number")
      <*> (o .:? "_id")
      <*> (o .:? "local_hours")

-- | ToJSON SearchRestaurants200ResponseRestaurantsInner
instance A.ToJSON SearchRestaurants200ResponseRestaurantsInner where
  toJSON SearchRestaurants200ResponseRestaurantsInner {..} =
   _omitNulls
      [ "offers_third_party_delivery" .= searchRestaurants200ResponseRestaurantsInnerOffersThirdPartyDelivery
      , "address" .= searchRestaurants200ResponseRestaurantsInnerAddress
      , "supports_upc_codes" .= searchRestaurants200ResponseRestaurantsInnerSupportsUpcCodes
      , "is_open" .= searchRestaurants200ResponseRestaurantsInnerIsOpen
      , "description" .= searchRestaurants200ResponseRestaurantsInnerDescription
      , "weighted_rating_value" .= searchRestaurants200ResponseRestaurantsInnerWeightedRatingValue
      , "type" .= searchRestaurants200ResponseRestaurantsInnerType
      , "offers_first_party_delivery" .= searchRestaurants200ResponseRestaurantsInnerOffersFirstPartyDelivery
      , "aggregated_rating_count" .= searchRestaurants200ResponseRestaurantsInnerAggregatedRatingCount
      , "pickup_enabled" .= searchRestaurants200ResponseRestaurantsInnerPickupEnabled
      , "cuisines" .= searchRestaurants200ResponseRestaurantsInnerCuisines
      , "miles" .= searchRestaurants200ResponseRestaurantsInnerMiles
      , "dollar_signs" .= searchRestaurants200ResponseRestaurantsInnerDollarSigns
      , "delivery_enabled" .= searchRestaurants200ResponseRestaurantsInnerDeliveryEnabled
      , "name" .= searchRestaurants200ResponseRestaurantsInnerName
      , "phone_number" .= searchRestaurants200ResponseRestaurantsInnerPhoneNumber
      , "_id" .= searchRestaurants200ResponseRestaurantsInnerId
      , "local_hours" .= searchRestaurants200ResponseRestaurantsInnerLocalHours
      ]


-- | Construct a value of type 'SearchRestaurants200ResponseRestaurantsInner' (by applying it's required fields, if any)
mkSearchRestaurants200ResponseRestaurantsInner
  :: SearchRestaurants200ResponseRestaurantsInner
mkSearchRestaurants200ResponseRestaurantsInner =
  SearchRestaurants200ResponseRestaurantsInner
  { searchRestaurants200ResponseRestaurantsInnerOffersThirdPartyDelivery = Nothing
  , searchRestaurants200ResponseRestaurantsInnerAddress = Nothing
  , searchRestaurants200ResponseRestaurantsInnerSupportsUpcCodes = Nothing
  , searchRestaurants200ResponseRestaurantsInnerIsOpen = Nothing
  , searchRestaurants200ResponseRestaurantsInnerDescription = Nothing
  , searchRestaurants200ResponseRestaurantsInnerWeightedRatingValue = Nothing
  , searchRestaurants200ResponseRestaurantsInnerType = Nothing
  , searchRestaurants200ResponseRestaurantsInnerOffersFirstPartyDelivery = Nothing
  , searchRestaurants200ResponseRestaurantsInnerAggregatedRatingCount = Nothing
  , searchRestaurants200ResponseRestaurantsInnerPickupEnabled = Nothing
  , searchRestaurants200ResponseRestaurantsInnerCuisines = Nothing
  , searchRestaurants200ResponseRestaurantsInnerMiles = Nothing
  , searchRestaurants200ResponseRestaurantsInnerDollarSigns = Nothing
  , searchRestaurants200ResponseRestaurantsInnerDeliveryEnabled = Nothing
  , searchRestaurants200ResponseRestaurantsInnerName = Nothing
  , searchRestaurants200ResponseRestaurantsInnerPhoneNumber = Nothing
  , searchRestaurants200ResponseRestaurantsInnerId = Nothing
  , searchRestaurants200ResponseRestaurantsInnerLocalHours = Nothing
  }

-- ** SearchRestaurants200ResponseRestaurantsInnerAddress
-- | SearchRestaurants200ResponseRestaurantsInnerAddress
data SearchRestaurants200ResponseRestaurantsInnerAddress = SearchRestaurants200ResponseRestaurantsInnerAddress
  { searchRestaurants200ResponseRestaurantsInnerAddressZipcode :: !(Maybe Text) -- ^ "zipcode"
  , searchRestaurants200ResponseRestaurantsInnerAddressCountry :: !(Maybe Text) -- ^ "country"
  , searchRestaurants200ResponseRestaurantsInnerAddressCity :: !(Maybe Text) -- ^ "city"
  , searchRestaurants200ResponseRestaurantsInnerAddressLatitude :: !(Maybe Double) -- ^ "latitude"
  , searchRestaurants200ResponseRestaurantsInnerAddressLon :: !(Maybe Double) -- ^ "lon"
  , searchRestaurants200ResponseRestaurantsInnerAddressStreetAddr2 :: !(Maybe Text) -- ^ "street_addr_2"
  , searchRestaurants200ResponseRestaurantsInnerAddressState :: !(Maybe Text) -- ^ "state"
  , searchRestaurants200ResponseRestaurantsInnerAddressStreetAddr :: !(Maybe Text) -- ^ "street_addr"
  , searchRestaurants200ResponseRestaurantsInnerAddressLat :: !(Maybe Double) -- ^ "lat"
  , searchRestaurants200ResponseRestaurantsInnerAddressLongitude :: !(Maybe Double) -- ^ "longitude"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SearchRestaurants200ResponseRestaurantsInnerAddress
instance A.FromJSON SearchRestaurants200ResponseRestaurantsInnerAddress where
  parseJSON = A.withObject "SearchRestaurants200ResponseRestaurantsInnerAddress" $ \o ->
    SearchRestaurants200ResponseRestaurantsInnerAddress
      <$> (o .:? "zipcode")
      <*> (o .:? "country")
      <*> (o .:? "city")
      <*> (o .:? "latitude")
      <*> (o .:? "lon")
      <*> (o .:? "street_addr_2")
      <*> (o .:? "state")
      <*> (o .:? "street_addr")
      <*> (o .:? "lat")
      <*> (o .:? "longitude")

-- | ToJSON SearchRestaurants200ResponseRestaurantsInnerAddress
instance A.ToJSON SearchRestaurants200ResponseRestaurantsInnerAddress where
  toJSON SearchRestaurants200ResponseRestaurantsInnerAddress {..} =
   _omitNulls
      [ "zipcode" .= searchRestaurants200ResponseRestaurantsInnerAddressZipcode
      , "country" .= searchRestaurants200ResponseRestaurantsInnerAddressCountry
      , "city" .= searchRestaurants200ResponseRestaurantsInnerAddressCity
      , "latitude" .= searchRestaurants200ResponseRestaurantsInnerAddressLatitude
      , "lon" .= searchRestaurants200ResponseRestaurantsInnerAddressLon
      , "street_addr_2" .= searchRestaurants200ResponseRestaurantsInnerAddressStreetAddr2
      , "state" .= searchRestaurants200ResponseRestaurantsInnerAddressState
      , "street_addr" .= searchRestaurants200ResponseRestaurantsInnerAddressStreetAddr
      , "lat" .= searchRestaurants200ResponseRestaurantsInnerAddressLat
      , "longitude" .= searchRestaurants200ResponseRestaurantsInnerAddressLongitude
      ]


-- | Construct a value of type 'SearchRestaurants200ResponseRestaurantsInnerAddress' (by applying it's required fields, if any)
mkSearchRestaurants200ResponseRestaurantsInnerAddress
  :: SearchRestaurants200ResponseRestaurantsInnerAddress
mkSearchRestaurants200ResponseRestaurantsInnerAddress =
  SearchRestaurants200ResponseRestaurantsInnerAddress
  { searchRestaurants200ResponseRestaurantsInnerAddressZipcode = Nothing
  , searchRestaurants200ResponseRestaurantsInnerAddressCountry = Nothing
  , searchRestaurants200ResponseRestaurantsInnerAddressCity = Nothing
  , searchRestaurants200ResponseRestaurantsInnerAddressLatitude = Nothing
  , searchRestaurants200ResponseRestaurantsInnerAddressLon = Nothing
  , searchRestaurants200ResponseRestaurantsInnerAddressStreetAddr2 = Nothing
  , searchRestaurants200ResponseRestaurantsInnerAddressState = Nothing
  , searchRestaurants200ResponseRestaurantsInnerAddressStreetAddr = Nothing
  , searchRestaurants200ResponseRestaurantsInnerAddressLat = Nothing
  , searchRestaurants200ResponseRestaurantsInnerAddressLongitude = Nothing
  }

-- ** SearchRestaurants200ResponseRestaurantsInnerLocalHours
-- | SearchRestaurants200ResponseRestaurantsInnerLocalHours
data SearchRestaurants200ResponseRestaurantsInnerLocalHours = SearchRestaurants200ResponseRestaurantsInnerLocalHours
  { searchRestaurants200ResponseRestaurantsInnerLocalHoursOperational :: !(Maybe SearchRestaurants200ResponseRestaurantsInnerLocalHoursOperational) -- ^ "operational"
  , searchRestaurants200ResponseRestaurantsInnerLocalHoursDelivery :: !(Maybe SearchRestaurants200ResponseRestaurantsInnerLocalHoursOperational) -- ^ "delivery"
  , searchRestaurants200ResponseRestaurantsInnerLocalHoursPickup :: !(Maybe SearchRestaurants200ResponseRestaurantsInnerLocalHoursOperational) -- ^ "pickup"
  , searchRestaurants200ResponseRestaurantsInnerLocalHoursDineIn :: !(Maybe SearchRestaurants200ResponseRestaurantsInnerLocalHoursOperational) -- ^ "dine_in"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SearchRestaurants200ResponseRestaurantsInnerLocalHours
instance A.FromJSON SearchRestaurants200ResponseRestaurantsInnerLocalHours where
  parseJSON = A.withObject "SearchRestaurants200ResponseRestaurantsInnerLocalHours" $ \o ->
    SearchRestaurants200ResponseRestaurantsInnerLocalHours
      <$> (o .:? "operational")
      <*> (o .:? "delivery")
      <*> (o .:? "pickup")
      <*> (o .:? "dine_in")

-- | ToJSON SearchRestaurants200ResponseRestaurantsInnerLocalHours
instance A.ToJSON SearchRestaurants200ResponseRestaurantsInnerLocalHours where
  toJSON SearchRestaurants200ResponseRestaurantsInnerLocalHours {..} =
   _omitNulls
      [ "operational" .= searchRestaurants200ResponseRestaurantsInnerLocalHoursOperational
      , "delivery" .= searchRestaurants200ResponseRestaurantsInnerLocalHoursDelivery
      , "pickup" .= searchRestaurants200ResponseRestaurantsInnerLocalHoursPickup
      , "dine_in" .= searchRestaurants200ResponseRestaurantsInnerLocalHoursDineIn
      ]


-- | Construct a value of type 'SearchRestaurants200ResponseRestaurantsInnerLocalHours' (by applying it's required fields, if any)
mkSearchRestaurants200ResponseRestaurantsInnerLocalHours
  :: SearchRestaurants200ResponseRestaurantsInnerLocalHours
mkSearchRestaurants200ResponseRestaurantsInnerLocalHours =
  SearchRestaurants200ResponseRestaurantsInnerLocalHours
  { searchRestaurants200ResponseRestaurantsInnerLocalHoursOperational = Nothing
  , searchRestaurants200ResponseRestaurantsInnerLocalHoursDelivery = Nothing
  , searchRestaurants200ResponseRestaurantsInnerLocalHoursPickup = Nothing
  , searchRestaurants200ResponseRestaurantsInnerLocalHoursDineIn = Nothing
  }

-- ** SearchRestaurants200ResponseRestaurantsInnerLocalHoursOperational
-- | SearchRestaurants200ResponseRestaurantsInnerLocalHoursOperational
data SearchRestaurants200ResponseRestaurantsInnerLocalHoursOperational = SearchRestaurants200ResponseRestaurantsInnerLocalHoursOperational
  { searchRestaurants200ResponseRestaurantsInnerLocalHoursOperationalSunday :: !(Maybe Text) -- ^ "sunday"
  , searchRestaurants200ResponseRestaurantsInnerLocalHoursOperationalSaturday :: !(Maybe Text) -- ^ "saturday"
  , searchRestaurants200ResponseRestaurantsInnerLocalHoursOperationalTuesday :: !(Maybe Text) -- ^ "tuesday"
  , searchRestaurants200ResponseRestaurantsInnerLocalHoursOperationalThursday :: !(Maybe Text) -- ^ "thursday"
  , searchRestaurants200ResponseRestaurantsInnerLocalHoursOperationalFriday :: !(Maybe Text) -- ^ "friday"
  , searchRestaurants200ResponseRestaurantsInnerLocalHoursOperationalWednesday :: !(Maybe Text) -- ^ "wednesday"
  , searchRestaurants200ResponseRestaurantsInnerLocalHoursOperationalMonday :: !(Maybe Text) -- ^ "monday"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SearchRestaurants200ResponseRestaurantsInnerLocalHoursOperational
instance A.FromJSON SearchRestaurants200ResponseRestaurantsInnerLocalHoursOperational where
  parseJSON = A.withObject "SearchRestaurants200ResponseRestaurantsInnerLocalHoursOperational" $ \o ->
    SearchRestaurants200ResponseRestaurantsInnerLocalHoursOperational
      <$> (o .:? "sunday")
      <*> (o .:? "saturday")
      <*> (o .:? "tuesday")
      <*> (o .:? "thursday")
      <*> (o .:? "friday")
      <*> (o .:? "wednesday")
      <*> (o .:? "monday")

-- | ToJSON SearchRestaurants200ResponseRestaurantsInnerLocalHoursOperational
instance A.ToJSON SearchRestaurants200ResponseRestaurantsInnerLocalHoursOperational where
  toJSON SearchRestaurants200ResponseRestaurantsInnerLocalHoursOperational {..} =
   _omitNulls
      [ "sunday" .= searchRestaurants200ResponseRestaurantsInnerLocalHoursOperationalSunday
      , "saturday" .= searchRestaurants200ResponseRestaurantsInnerLocalHoursOperationalSaturday
      , "tuesday" .= searchRestaurants200ResponseRestaurantsInnerLocalHoursOperationalTuesday
      , "thursday" .= searchRestaurants200ResponseRestaurantsInnerLocalHoursOperationalThursday
      , "friday" .= searchRestaurants200ResponseRestaurantsInnerLocalHoursOperationalFriday
      , "wednesday" .= searchRestaurants200ResponseRestaurantsInnerLocalHoursOperationalWednesday
      , "monday" .= searchRestaurants200ResponseRestaurantsInnerLocalHoursOperationalMonday
      ]


-- | Construct a value of type 'SearchRestaurants200ResponseRestaurantsInnerLocalHoursOperational' (by applying it's required fields, if any)
mkSearchRestaurants200ResponseRestaurantsInnerLocalHoursOperational
  :: SearchRestaurants200ResponseRestaurantsInnerLocalHoursOperational
mkSearchRestaurants200ResponseRestaurantsInnerLocalHoursOperational =
  SearchRestaurants200ResponseRestaurantsInnerLocalHoursOperational
  { searchRestaurants200ResponseRestaurantsInnerLocalHoursOperationalSunday = Nothing
  , searchRestaurants200ResponseRestaurantsInnerLocalHoursOperationalSaturday = Nothing
  , searchRestaurants200ResponseRestaurantsInnerLocalHoursOperationalTuesday = Nothing
  , searchRestaurants200ResponseRestaurantsInnerLocalHoursOperationalThursday = Nothing
  , searchRestaurants200ResponseRestaurantsInnerLocalHoursOperationalFriday = Nothing
  , searchRestaurants200ResponseRestaurantsInnerLocalHoursOperationalWednesday = Nothing
  , searchRestaurants200ResponseRestaurantsInnerLocalHoursOperationalMonday = Nothing
  }

-- ** SearchRoyaltyFreeImages200Response
-- | SearchRoyaltyFreeImages200Response
data SearchRoyaltyFreeImages200Response = SearchRoyaltyFreeImages200Response
  { searchRoyaltyFreeImages200ResponseImages :: !(Maybe [SearchRoyaltyFreeImages200ResponseImagesInner]) -- ^ "images"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SearchRoyaltyFreeImages200Response
instance A.FromJSON SearchRoyaltyFreeImages200Response where
  parseJSON = A.withObject "SearchRoyaltyFreeImages200Response" $ \o ->
    SearchRoyaltyFreeImages200Response
      <$> (o .:? "images")

-- | ToJSON SearchRoyaltyFreeImages200Response
instance A.ToJSON SearchRoyaltyFreeImages200Response where
  toJSON SearchRoyaltyFreeImages200Response {..} =
   _omitNulls
      [ "images" .= searchRoyaltyFreeImages200ResponseImages
      ]


-- | Construct a value of type 'SearchRoyaltyFreeImages200Response' (by applying it's required fields, if any)
mkSearchRoyaltyFreeImages200Response
  :: SearchRoyaltyFreeImages200Response
mkSearchRoyaltyFreeImages200Response =
  SearchRoyaltyFreeImages200Response
  { searchRoyaltyFreeImages200ResponseImages = Nothing
  }

-- ** SearchRoyaltyFreeImages200ResponseImagesInner
-- | SearchRoyaltyFreeImages200ResponseImagesInner
data SearchRoyaltyFreeImages200ResponseImagesInner = SearchRoyaltyFreeImages200ResponseImagesInner
  { searchRoyaltyFreeImages200ResponseImagesInnerWidth :: !(Maybe Int) -- ^ "width"
  , searchRoyaltyFreeImages200ResponseImagesInnerLicense :: !(Maybe SearchRoyaltyFreeImages200ResponseImagesInnerLicense) -- ^ "license"
  , searchRoyaltyFreeImages200ResponseImagesInnerThumbnail :: !(Maybe Text) -- ^ "thumbnail"
  , searchRoyaltyFreeImages200ResponseImagesInnerId :: !(Maybe Text) -- ^ "id"
  , searchRoyaltyFreeImages200ResponseImagesInnerUrl :: !(Maybe Text) -- ^ "url"
  , searchRoyaltyFreeImages200ResponseImagesInnerHeight :: !(Maybe Int) -- ^ "height"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SearchRoyaltyFreeImages200ResponseImagesInner
instance A.FromJSON SearchRoyaltyFreeImages200ResponseImagesInner where
  parseJSON = A.withObject "SearchRoyaltyFreeImages200ResponseImagesInner" $ \o ->
    SearchRoyaltyFreeImages200ResponseImagesInner
      <$> (o .:? "width")
      <*> (o .:? "license")
      <*> (o .:? "thumbnail")
      <*> (o .:? "id")
      <*> (o .:? "url")
      <*> (o .:? "height")

-- | ToJSON SearchRoyaltyFreeImages200ResponseImagesInner
instance A.ToJSON SearchRoyaltyFreeImages200ResponseImagesInner where
  toJSON SearchRoyaltyFreeImages200ResponseImagesInner {..} =
   _omitNulls
      [ "width" .= searchRoyaltyFreeImages200ResponseImagesInnerWidth
      , "license" .= searchRoyaltyFreeImages200ResponseImagesInnerLicense
      , "thumbnail" .= searchRoyaltyFreeImages200ResponseImagesInnerThumbnail
      , "id" .= searchRoyaltyFreeImages200ResponseImagesInnerId
      , "url" .= searchRoyaltyFreeImages200ResponseImagesInnerUrl
      , "height" .= searchRoyaltyFreeImages200ResponseImagesInnerHeight
      ]


-- | Construct a value of type 'SearchRoyaltyFreeImages200ResponseImagesInner' (by applying it's required fields, if any)
mkSearchRoyaltyFreeImages200ResponseImagesInner
  :: SearchRoyaltyFreeImages200ResponseImagesInner
mkSearchRoyaltyFreeImages200ResponseImagesInner =
  SearchRoyaltyFreeImages200ResponseImagesInner
  { searchRoyaltyFreeImages200ResponseImagesInnerWidth = Nothing
  , searchRoyaltyFreeImages200ResponseImagesInnerLicense = Nothing
  , searchRoyaltyFreeImages200ResponseImagesInnerThumbnail = Nothing
  , searchRoyaltyFreeImages200ResponseImagesInnerId = Nothing
  , searchRoyaltyFreeImages200ResponseImagesInnerUrl = Nothing
  , searchRoyaltyFreeImages200ResponseImagesInnerHeight = Nothing
  }

-- ** SearchRoyaltyFreeImages200ResponseImagesInnerLicense
-- | SearchRoyaltyFreeImages200ResponseImagesInnerLicense
data SearchRoyaltyFreeImages200ResponseImagesInnerLicense = SearchRoyaltyFreeImages200ResponseImagesInnerLicense
  { searchRoyaltyFreeImages200ResponseImagesInnerLicenseName :: !(Maybe Text) -- ^ "name"
  , searchRoyaltyFreeImages200ResponseImagesInnerLicenseLink :: !(Maybe Text) -- ^ "link"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SearchRoyaltyFreeImages200ResponseImagesInnerLicense
instance A.FromJSON SearchRoyaltyFreeImages200ResponseImagesInnerLicense where
  parseJSON = A.withObject "SearchRoyaltyFreeImages200ResponseImagesInnerLicense" $ \o ->
    SearchRoyaltyFreeImages200ResponseImagesInnerLicense
      <$> (o .:? "name")
      <*> (o .:? "link")

-- | ToJSON SearchRoyaltyFreeImages200ResponseImagesInnerLicense
instance A.ToJSON SearchRoyaltyFreeImages200ResponseImagesInnerLicense where
  toJSON SearchRoyaltyFreeImages200ResponseImagesInnerLicense {..} =
   _omitNulls
      [ "name" .= searchRoyaltyFreeImages200ResponseImagesInnerLicenseName
      , "link" .= searchRoyaltyFreeImages200ResponseImagesInnerLicenseLink
      ]


-- | Construct a value of type 'SearchRoyaltyFreeImages200ResponseImagesInnerLicense' (by applying it's required fields, if any)
mkSearchRoyaltyFreeImages200ResponseImagesInnerLicense
  :: SearchRoyaltyFreeImages200ResponseImagesInnerLicense
mkSearchRoyaltyFreeImages200ResponseImagesInnerLicense =
  SearchRoyaltyFreeImages200ResponseImagesInnerLicense
  { searchRoyaltyFreeImages200ResponseImagesInnerLicenseName = Nothing
  , searchRoyaltyFreeImages200ResponseImagesInnerLicenseLink = Nothing
  }

-- ** SearchWeb200Response
-- | SearchWeb200Response
data SearchWeb200Response = SearchWeb200Response
  { searchWeb200ResponseResults :: !(Maybe [SearchWeb200ResponseResultsInner]) -- ^ "results"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SearchWeb200Response
instance A.FromJSON SearchWeb200Response where
  parseJSON = A.withObject "SearchWeb200Response" $ \o ->
    SearchWeb200Response
      <$> (o .:? "results")

-- | ToJSON SearchWeb200Response
instance A.ToJSON SearchWeb200Response where
  toJSON SearchWeb200Response {..} =
   _omitNulls
      [ "results" .= searchWeb200ResponseResults
      ]


-- | Construct a value of type 'SearchWeb200Response' (by applying it's required fields, if any)
mkSearchWeb200Response
  :: SearchWeb200Response
mkSearchWeb200Response =
  SearchWeb200Response
  { searchWeb200ResponseResults = Nothing
  }

-- ** SearchWeb200ResponseResultsInner
-- | SearchWeb200ResponseResultsInner
data SearchWeb200ResponseResultsInner = SearchWeb200ResponseResultsInner
  { searchWeb200ResponseResultsInnerTitle :: !(Maybe Text) -- ^ "title"
  , searchWeb200ResponseResultsInnerSummary :: !(Maybe Text) -- ^ "summary"
  , searchWeb200ResponseResultsInnerUrl :: !(Maybe Text) -- ^ "url"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SearchWeb200ResponseResultsInner
instance A.FromJSON SearchWeb200ResponseResultsInner where
  parseJSON = A.withObject "SearchWeb200ResponseResultsInner" $ \o ->
    SearchWeb200ResponseResultsInner
      <$> (o .:? "title")
      <*> (o .:? "summary")
      <*> (o .:? "url")

-- | ToJSON SearchWeb200ResponseResultsInner
instance A.ToJSON SearchWeb200ResponseResultsInner where
  toJSON SearchWeb200ResponseResultsInner {..} =
   _omitNulls
      [ "title" .= searchWeb200ResponseResultsInnerTitle
      , "summary" .= searchWeb200ResponseResultsInnerSummary
      , "url" .= searchWeb200ResponseResultsInnerUrl
      ]


-- | Construct a value of type 'SearchWeb200ResponseResultsInner' (by applying it's required fields, if any)
mkSearchWeb200ResponseResultsInner
  :: SearchWeb200ResponseResultsInner
mkSearchWeb200ResponseResultsInner =
  SearchWeb200ResponseResultsInner
  { searchWeb200ResponseResultsInnerTitle = Nothing
  , searchWeb200ResponseResultsInnerSummary = Nothing
  , searchWeb200ResponseResultsInnerUrl = Nothing
  }

-- ** SingularizeWord200Response
-- | SingularizeWord200Response
data SingularizeWord200Response = SingularizeWord200Response
  { singularizeWord200ResponseOriginal :: !(Maybe Text) -- ^ "original"
  , singularizeWord200ResponseSingular :: !(Maybe Text) -- ^ "singular"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SingularizeWord200Response
instance A.FromJSON SingularizeWord200Response where
  parseJSON = A.withObject "SingularizeWord200Response" $ \o ->
    SingularizeWord200Response
      <$> (o .:? "original")
      <*> (o .:? "singular")

-- | ToJSON SingularizeWord200Response
instance A.ToJSON SingularizeWord200Response where
  toJSON SingularizeWord200Response {..} =
   _omitNulls
      [ "original" .= singularizeWord200ResponseOriginal
      , "singular" .= singularizeWord200ResponseSingular
      ]


-- | Construct a value of type 'SingularizeWord200Response' (by applying it's required fields, if any)
mkSingularizeWord200Response
  :: SingularizeWord200Response
mkSingularizeWord200Response =
  SingularizeWord200Response
  { singularizeWord200ResponseOriginal = Nothing
  , singularizeWord200ResponseSingular = Nothing
  }

-- ** StemText200Response
-- | StemText200Response
data StemText200Response = StemText200Response
  { stemText200ResponseOriginal :: !(Maybe Text) -- ^ "original"
  , stemText200ResponseStemmed :: !(Maybe Text) -- ^ "stemmed"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON StemText200Response
instance A.FromJSON StemText200Response where
  parseJSON = A.withObject "StemText200Response" $ \o ->
    StemText200Response
      <$> (o .:? "original")
      <*> (o .:? "stemmed")

-- | ToJSON StemText200Response
instance A.ToJSON StemText200Response where
  toJSON StemText200Response {..} =
   _omitNulls
      [ "original" .= stemText200ResponseOriginal
      , "stemmed" .= stemText200ResponseStemmed
      ]


-- | Construct a value of type 'StemText200Response' (by applying it's required fields, if any)
mkStemText200Response
  :: StemText200Response
mkStemText200Response =
  StemText200Response
  { stemText200ResponseOriginal = Nothing
  , stemText200ResponseStemmed = Nothing
  }

-- ** StoreKeyValueGET200Response
-- | StoreKeyValueGET200Response
data StoreKeyValueGET200Response = StoreKeyValueGET200Response
  { storeKeyValueGET200ResponseStatus :: !(Maybe Text) -- ^ "status"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON StoreKeyValueGET200Response
instance A.FromJSON StoreKeyValueGET200Response where
  parseJSON = A.withObject "StoreKeyValueGET200Response" $ \o ->
    StoreKeyValueGET200Response
      <$> (o .:? "status")

-- | ToJSON StoreKeyValueGET200Response
instance A.ToJSON StoreKeyValueGET200Response where
  toJSON StoreKeyValueGET200Response {..} =
   _omitNulls
      [ "status" .= storeKeyValueGET200ResponseStatus
      ]


-- | Construct a value of type 'StoreKeyValueGET200Response' (by applying it's required fields, if any)
mkStoreKeyValueGET200Response
  :: StoreKeyValueGET200Response
mkStoreKeyValueGET200Response =
  StoreKeyValueGET200Response
  { storeKeyValueGET200ResponseStatus = Nothing
  }

-- ** TagPartOfSpeech200Response
-- | TagPartOfSpeech200Response
data TagPartOfSpeech200Response = TagPartOfSpeech200Response
  { tagPartOfSpeech200ResponseTaggedText :: !(Maybe Text) -- ^ "tagged_text"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TagPartOfSpeech200Response
instance A.FromJSON TagPartOfSpeech200Response where
  parseJSON = A.withObject "TagPartOfSpeech200Response" $ \o ->
    TagPartOfSpeech200Response
      <$> (o .:? "tagged_text")

-- | ToJSON TagPartOfSpeech200Response
instance A.ToJSON TagPartOfSpeech200Response where
  toJSON TagPartOfSpeech200Response {..} =
   _omitNulls
      [ "tagged_text" .= tagPartOfSpeech200ResponseTaggedText
      ]


-- | Construct a value of type 'TagPartOfSpeech200Response' (by applying it's required fields, if any)
mkTagPartOfSpeech200Response
  :: TagPartOfSpeech200Response
mkTagPartOfSpeech200Response =
  TagPartOfSpeech200Response
  { tagPartOfSpeech200ResponseTaggedText = Nothing
  }

-- ** TopNews200Response
-- | TopNews200Response
data TopNews200Response = TopNews200Response
  { topNews200ResponseTopNews :: !(Maybe [TopNews200ResponseTopNewsInner]) -- ^ "top_news"
  , topNews200ResponseLanguage :: !(Maybe Text) -- ^ "language"
  , topNews200ResponseCountry :: !(Maybe Text) -- ^ "country"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TopNews200Response
instance A.FromJSON TopNews200Response where
  parseJSON = A.withObject "TopNews200Response" $ \o ->
    TopNews200Response
      <$> (o .:? "top_news")
      <*> (o .:? "language")
      <*> (o .:? "country")

-- | ToJSON TopNews200Response
instance A.ToJSON TopNews200Response where
  toJSON TopNews200Response {..} =
   _omitNulls
      [ "top_news" .= topNews200ResponseTopNews
      , "language" .= topNews200ResponseLanguage
      , "country" .= topNews200ResponseCountry
      ]


-- | Construct a value of type 'TopNews200Response' (by applying it's required fields, if any)
mkTopNews200Response
  :: TopNews200Response
mkTopNews200Response =
  TopNews200Response
  { topNews200ResponseTopNews = Nothing
  , topNews200ResponseLanguage = Nothing
  , topNews200ResponseCountry = Nothing
  }

-- ** TopNews200ResponseTopNewsInner
-- | TopNews200ResponseTopNewsInner
data TopNews200ResponseTopNewsInner = TopNews200ResponseTopNewsInner
  { topNews200ResponseTopNewsInnerNews :: !(Maybe [TopNews200ResponseTopNewsInnerNewsInner]) -- ^ "news"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TopNews200ResponseTopNewsInner
instance A.FromJSON TopNews200ResponseTopNewsInner where
  parseJSON = A.withObject "TopNews200ResponseTopNewsInner" $ \o ->
    TopNews200ResponseTopNewsInner
      <$> (o .:? "news")

-- | ToJSON TopNews200ResponseTopNewsInner
instance A.ToJSON TopNews200ResponseTopNewsInner where
  toJSON TopNews200ResponseTopNewsInner {..} =
   _omitNulls
      [ "news" .= topNews200ResponseTopNewsInnerNews
      ]


-- | Construct a value of type 'TopNews200ResponseTopNewsInner' (by applying it's required fields, if any)
mkTopNews200ResponseTopNewsInner
  :: TopNews200ResponseTopNewsInner
mkTopNews200ResponseTopNewsInner =
  TopNews200ResponseTopNewsInner
  { topNews200ResponseTopNewsInnerNews = Nothing
  }

-- ** TopNews200ResponseTopNewsInnerNewsInner
-- | TopNews200ResponseTopNewsInnerNewsInner
data TopNews200ResponseTopNewsInnerNewsInner = TopNews200ResponseTopNewsInnerNewsInner
  { topNews200ResponseTopNewsInnerNewsInnerSummary :: !(Maybe Text) -- ^ "summary"
  , topNews200ResponseTopNewsInnerNewsInnerImage :: !(Maybe Text) -- ^ "image"
  , topNews200ResponseTopNewsInnerNewsInnerId :: !(Maybe Int) -- ^ "id"
  , topNews200ResponseTopNewsInnerNewsInnerText :: !(Maybe Text) -- ^ "text"
  , topNews200ResponseTopNewsInnerNewsInnerTitle :: !(Maybe Text) -- ^ "title"
  , topNews200ResponseTopNewsInnerNewsInnerPublishDate :: !(Maybe Text) -- ^ "publish_date"
  , topNews200ResponseTopNewsInnerNewsInnerUrl :: !(Maybe Text) -- ^ "url"
  , topNews200ResponseTopNewsInnerNewsInnerAuthors :: !(Maybe [Text]) -- ^ "authors"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TopNews200ResponseTopNewsInnerNewsInner
instance A.FromJSON TopNews200ResponseTopNewsInnerNewsInner where
  parseJSON = A.withObject "TopNews200ResponseTopNewsInnerNewsInner" $ \o ->
    TopNews200ResponseTopNewsInnerNewsInner
      <$> (o .:? "summary")
      <*> (o .:? "image")
      <*> (o .:? "id")
      <*> (o .:? "text")
      <*> (o .:? "title")
      <*> (o .:? "publish_date")
      <*> (o .:? "url")
      <*> (o .:? "authors")

-- | ToJSON TopNews200ResponseTopNewsInnerNewsInner
instance A.ToJSON TopNews200ResponseTopNewsInnerNewsInner where
  toJSON TopNews200ResponseTopNewsInnerNewsInner {..} =
   _omitNulls
      [ "summary" .= topNews200ResponseTopNewsInnerNewsInnerSummary
      , "image" .= topNews200ResponseTopNewsInnerNewsInnerImage
      , "id" .= topNews200ResponseTopNewsInnerNewsInnerId
      , "text" .= topNews200ResponseTopNewsInnerNewsInnerText
      , "title" .= topNews200ResponseTopNewsInnerNewsInnerTitle
      , "publish_date" .= topNews200ResponseTopNewsInnerNewsInnerPublishDate
      , "url" .= topNews200ResponseTopNewsInnerNewsInnerUrl
      , "authors" .= topNews200ResponseTopNewsInnerNewsInnerAuthors
      ]


-- | Construct a value of type 'TopNews200ResponseTopNewsInnerNewsInner' (by applying it's required fields, if any)
mkTopNews200ResponseTopNewsInnerNewsInner
  :: TopNews200ResponseTopNewsInnerNewsInner
mkTopNews200ResponseTopNewsInnerNewsInner =
  TopNews200ResponseTopNewsInnerNewsInner
  { topNews200ResponseTopNewsInnerNewsInnerSummary = Nothing
  , topNews200ResponseTopNewsInnerNewsInnerImage = Nothing
  , topNews200ResponseTopNewsInnerNewsInnerId = Nothing
  , topNews200ResponseTopNewsInnerNewsInnerText = Nothing
  , topNews200ResponseTopNewsInnerNewsInnerTitle = Nothing
  , topNews200ResponseTopNewsInnerNewsInnerPublishDate = Nothing
  , topNews200ResponseTopNewsInnerNewsInnerUrl = Nothing
  , topNews200ResponseTopNewsInnerNewsInnerAuthors = Nothing
  }

-- ** VerifyEmailAddress200Response
-- | VerifyEmailAddress200Response
data VerifyEmailAddress200Response = VerifyEmailAddress200Response
  { verifyEmailAddress200ResponseEmail :: !(Maybe Text) -- ^ "email"
  , verifyEmailAddress200ResponseDomain :: !(Maybe Text) -- ^ "domain"
  , verifyEmailAddress200ResponseFirstName :: !(Maybe Text) -- ^ "first_name"
  , verifyEmailAddress200ResponseMiddleName :: !(Maybe Text) -- ^ "middle_name"
  , verifyEmailAddress200ResponseLastName :: !(Maybe Text) -- ^ "last_name"
  , verifyEmailAddress200ResponseFullName :: !(Maybe Text) -- ^ "full_name"
  , verifyEmailAddress200ResponseUsername :: !(Maybe Text) -- ^ "username"
  , verifyEmailAddress200ResponseImage :: !(Maybe Text) -- ^ "image"
  , verifyEmailAddress200ResponseResult :: !(Maybe Text) -- ^ "result"
  , verifyEmailAddress200ResponseDisposable :: !(Maybe Bool) -- ^ "disposable"
  , verifyEmailAddress200ResponseAcceptAll :: !(Maybe Bool) -- ^ "accept_all"
  , verifyEmailAddress200ResponseFreeProvider :: !(Maybe Bool) -- ^ "free_provider"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON VerifyEmailAddress200Response
instance A.FromJSON VerifyEmailAddress200Response where
  parseJSON = A.withObject "VerifyEmailAddress200Response" $ \o ->
    VerifyEmailAddress200Response
      <$> (o .:? "email")
      <*> (o .:? "domain")
      <*> (o .:? "first_name")
      <*> (o .:? "middle_name")
      <*> (o .:? "last_name")
      <*> (o .:? "full_name")
      <*> (o .:? "username")
      <*> (o .:? "image")
      <*> (o .:? "result")
      <*> (o .:? "disposable")
      <*> (o .:? "accept_all")
      <*> (o .:? "free_provider")

-- | ToJSON VerifyEmailAddress200Response
instance A.ToJSON VerifyEmailAddress200Response where
  toJSON VerifyEmailAddress200Response {..} =
   _omitNulls
      [ "email" .= verifyEmailAddress200ResponseEmail
      , "domain" .= verifyEmailAddress200ResponseDomain
      , "first_name" .= verifyEmailAddress200ResponseFirstName
      , "middle_name" .= verifyEmailAddress200ResponseMiddleName
      , "last_name" .= verifyEmailAddress200ResponseLastName
      , "full_name" .= verifyEmailAddress200ResponseFullName
      , "username" .= verifyEmailAddress200ResponseUsername
      , "image" .= verifyEmailAddress200ResponseImage
      , "result" .= verifyEmailAddress200ResponseResult
      , "disposable" .= verifyEmailAddress200ResponseDisposable
      , "accept_all" .= verifyEmailAddress200ResponseAcceptAll
      , "free_provider" .= verifyEmailAddress200ResponseFreeProvider
      ]


-- | Construct a value of type 'VerifyEmailAddress200Response' (by applying it's required fields, if any)
mkVerifyEmailAddress200Response
  :: VerifyEmailAddress200Response
mkVerifyEmailAddress200Response =
  VerifyEmailAddress200Response
  { verifyEmailAddress200ResponseEmail = Nothing
  , verifyEmailAddress200ResponseDomain = Nothing
  , verifyEmailAddress200ResponseFirstName = Nothing
  , verifyEmailAddress200ResponseMiddleName = Nothing
  , verifyEmailAddress200ResponseLastName = Nothing
  , verifyEmailAddress200ResponseFullName = Nothing
  , verifyEmailAddress200ResponseUsername = Nothing
  , verifyEmailAddress200ResponseImage = Nothing
  , verifyEmailAddress200ResponseResult = Nothing
  , verifyEmailAddress200ResponseDisposable = Nothing
  , verifyEmailAddress200ResponseAcceptAll = Nothing
  , verifyEmailAddress200ResponseFreeProvider = Nothing
  }




-- * Auth Methods

-- ** AuthApiKeyApiKey
data AuthApiKeyApiKey =
  AuthApiKeyApiKey Text -- ^ secret
  deriving (P.Eq, P.Show, P.Typeable)

instance AuthMethod AuthApiKeyApiKey where
  applyAuthMethod _ a@(AuthApiKeyApiKey secret) req =
    P.pure $
    if (P.typeOf a `P.elem` rAuthTypes req)
      then req `setQuery` toQuery ("api-key", Just secret)
           & L.over rAuthTypesL (P.filter (/= P.typeOf a))
      else req

-- ** AuthApiKeyHeaderApiKey
data AuthApiKeyHeaderApiKey =
  AuthApiKeyHeaderApiKey Text -- ^ secret
  deriving (P.Eq, P.Show, P.Typeable)

instance AuthMethod AuthApiKeyHeaderApiKey where
  applyAuthMethod _ a@(AuthApiKeyHeaderApiKey secret) req =
    P.pure $
    if (P.typeOf a `P.elem` rAuthTypes req)
      then req `setHeader` toHeader ("x-api-key", secret)
           & L.over rAuthTypesL (P.filter (/= P.typeOf a))
      else req


