{-
   API League

   API League is a Hub for World Class APIs.

   OpenAPI Version: 3.0.0
   API League API version: 1.0
   Contact: mail@apileague.com
   Generated by OpenAPI Generator (https://openapi-generator.tech)
-}

{-|
Module : APILeague.Model
-}

{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveFoldable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE DeriveTraversable #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE NamedFieldPuns #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE TupleSections #-}
{-# LANGUAGE TypeFamilies #-}
{-# OPTIONS_GHC -fno-warn-unused-matches -fno-warn-unused-binds -fno-warn-unused-imports #-}

module APILeague.Model where

import APILeague.Core
import APILeague.MimeTypes

import Data.Aeson ((.:),(.:!),(.:?),(.=))

import qualified Control.Arrow as P (left)
import qualified Data.Aeson as A
import qualified Data.ByteString as B
import qualified Data.ByteString.Base64 as B64
import qualified Data.ByteString.Char8 as BC
import qualified Data.ByteString.Lazy as BL
import qualified Data.Data as P (Typeable, TypeRep, typeOf, typeRep)
import qualified Data.Foldable as P
import qualified Data.HashMap.Lazy as HM
import qualified Data.Map as Map
import qualified Data.Maybe as P
import qualified Data.Set as Set
import qualified Data.Text as T
import qualified Data.Text.Encoding as T
import qualified Data.Time as TI
import qualified Lens.Micro as L
import qualified Web.FormUrlEncoded as WH
import qualified Web.HttpApiData as WH

import Control.Applicative ((<|>))
import Control.Applicative (Alternative)
import Data.Function ((&))
import Data.Monoid ((<>))
import Data.Text (Text)
import Prelude (($),(/=),(.),(<$>),(<*>),(>>=),(=<<),Maybe(..),Bool(..),Char,Double,FilePath,Float,Int,Integer,String,fmap,undefined,mempty,maybe,pure,Monad,Applicative,Functor)

import qualified Prelude as P



-- * Parameter newtypes


-- ** Analyze
newtype Analyze = Analyze { unAnalyze :: Bool } deriving (P.Eq, P.Show)

-- ** Authors
newtype Authors = Authors { unAuthors :: Text } deriving (P.Eq, P.Show)

-- ** Crop
newtype Crop = Crop { unCrop :: Bool } deriving (P.Eq, P.Show)

-- ** EarliestPublishDate
newtype EarliestPublishDate = EarliestPublishDate { unEarliestPublishDate :: Text } deriving (P.Eq, P.Show)

-- ** EarliestPublishYear
newtype EarliestPublishYear = EarliestPublishYear { unEarliestPublishYear :: Int } deriving (P.Eq, P.Show)

-- ** Entities
newtype Entities = Entities { unEntities :: Text } deriving (P.Eq, P.Show)

-- ** ExcludeTags
newtype ExcludeTags = ExcludeTags { unExcludeTags :: Text } deriving (P.Eq, P.Show)

-- ** FoodName
newtype FoodName = FoodName { unFoodName :: Text } deriving (P.Eq, P.Show)

-- ** Genres
newtype Genres = Genres { unGenres :: Text } deriving (P.Eq, P.Show)

-- ** GroupResults
newtype GroupResults = GroupResults { unGroupResults :: Bool } deriving (P.Eq, P.Show)

-- ** Height
newtype Height = Height { unHeight :: Int } deriving (P.Eq, P.Show)

-- ** Id
newtype Id = Id { unId :: Int } deriving (P.Eq, P.Show)

-- ** IncludeTags
newtype IncludeTags = IncludeTags { unIncludeTags :: Text } deriving (P.Eq, P.Show)

-- ** Isbn
newtype Isbn = Isbn { unIsbn :: Text } deriving (P.Eq, P.Show)

-- ** Key
newtype Key = Key { unKey :: Text } deriving (P.Eq, P.Show)

-- ** Keywords
newtype Keywords = Keywords { unKeywords :: Text } deriving (P.Eq, P.Show)

-- ** KeywordsInImage
newtype KeywordsInImage = KeywordsInImage { unKeywordsInImage :: Bool } deriving (P.Eq, P.Show)

-- ** Language
newtype Language = Language { unLanguage :: Text } deriving (P.Eq, P.Show)

-- ** LatestPublishDate
newtype LatestPublishDate = LatestPublishDate { unLatestPublishDate :: Text } deriving (P.Eq, P.Show)

-- ** LatestPublishYear
newtype LatestPublishYear = LatestPublishYear { unLatestPublishYear :: Int } deriving (P.Eq, P.Show)

-- ** LocationFilter
newtype LocationFilter = LocationFilter { unLocationFilter :: Text } deriving (P.Eq, P.Show)

-- ** MaxAgeDays
newtype MaxAgeDays = MaxAgeDays { unMaxAgeDays :: Int } deriving (P.Eq, P.Show)

-- ** MaxLength
newtype MaxLength = MaxLength { unMaxLength :: Double } deriving (P.Eq, P.Show)

-- ** MaxLengthInt
newtype MaxLengthInt = MaxLengthInt { unMaxLengthInt :: Int } deriving (P.Eq, P.Show)

-- ** MaxLines
newtype MaxLines = MaxLines { unMaxLines :: Int } deriving (P.Eq, P.Show)

-- ** MaxRating
newtype MaxRating = MaxRating { unMaxRating :: Double } deriving (P.Eq, P.Show)

-- ** MaxSentiment
newtype MaxSentiment = MaxSentiment { unMaxSentiment :: Double } deriving (P.Eq, P.Show)

-- ** MediaType
newtype MediaType = MediaType { unMediaType :: Text } deriving (P.Eq, P.Show)

-- ** MinLength
newtype MinLength = MinLength { unMinLength :: Int } deriving (P.Eq, P.Show)

-- ** MinLines
newtype MinLines = MinLines { unMinLines :: Int } deriving (P.Eq, P.Show)

-- ** MinRating
newtype MinRating = MinRating { unMinRating :: Double } deriving (P.Eq, P.Show)

-- ** MinSentiment
newtype MinSentiment = MinSentiment { unMinSentiment :: Double } deriving (P.Eq, P.Show)

-- ** NewsSources
newtype NewsSources = NewsSources { unNewsSources :: Text } deriving (P.Eq, P.Show)

-- ** Number
newtype Number = Number { unNumber :: Int } deriving (P.Eq, P.Show)

-- ** Oclc
newtype Oclc = Oclc { unOclc :: Text } deriving (P.Eq, P.Show)

-- ** Offset
newtype Offset = Offset { unOffset :: Int } deriving (P.Eq, P.Show)

-- ** ParamText
newtype ParamText = ParamText { unParamText :: Text } deriving (P.Eq, P.Show)

-- ** Query
newtype Query = Query { unQuery :: Text } deriving (P.Eq, P.Show)

-- ** Sort
newtype Sort = Sort { unSort :: Text } deriving (P.Eq, P.Show)

-- ** SortDirection
newtype SortDirection = SortDirection { unSortDirection :: Text } deriving (P.Eq, P.Show)

-- ** SourceAmount
newtype SourceAmount = SourceAmount { unSourceAmount :: Double } deriving (P.Eq, P.Show)

-- ** SourceCountries
newtype SourceCountries = SourceCountries { unSourceCountries :: Text } deriving (P.Eq, P.Show)

-- ** SourceUnit
newtype SourceUnit = SourceUnit { unSourceUnit :: Text } deriving (P.Eq, P.Show)

-- ** TargetUnit
newtype TargetUnit = TargetUnit { unTargetUnit :: Text } deriving (P.Eq, P.Show)

-- ** Title
newtype Title = Title { unTitle :: Text } deriving (P.Eq, P.Show)

-- ** Url
newtype Url = Url { unUrl :: Text } deriving (P.Eq, P.Show)

-- ** Value
newtype Value = Value { unValue :: Text } deriving (P.Eq, P.Show)

-- ** Width
newtype Width = Width { unWidth :: Int } deriving (P.Eq, P.Show)

-- ** Word
newtype Word = Word { unWord :: Text } deriving (P.Eq, P.Show)

-- * Models


-- ** ConvertUnits200Response
-- | ConvertUnits200Response
data ConvertUnits200Response = ConvertUnits200Response
  { convertUnits200ResponseTargetAmount :: !(Maybe Double) -- ^ "target_amount"
  , convertUnits200ResponseTargetUnit :: !(Maybe Text) -- ^ "target_unit"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ConvertUnits200Response
instance A.FromJSON ConvertUnits200Response where
  parseJSON = A.withObject "ConvertUnits200Response" $ \o ->
    ConvertUnits200Response
      <$> (o .:? "target_amount")
      <*> (o .:? "target_unit")

-- | ToJSON ConvertUnits200Response
instance A.ToJSON ConvertUnits200Response where
  toJSON ConvertUnits200Response {..} =
   _omitNulls
      [ "target_amount" .= convertUnits200ResponseTargetAmount
      , "target_unit" .= convertUnits200ResponseTargetUnit
      ]


-- | Construct a value of type 'ConvertUnits200Response' (by applying it's required fields, if any)
mkConvertUnits200Response
  :: ConvertUnits200Response
mkConvertUnits200Response =
  ConvertUnits200Response
  { convertUnits200ResponseTargetAmount = Nothing
  , convertUnits200ResponseTargetUnit = Nothing
  }

-- ** CorrectSpelling200Response
-- | CorrectSpelling200Response
data CorrectSpelling200Response = CorrectSpelling200Response
  { correctSpelling200ResponseCorrectedText :: !(Maybe Text) -- ^ "corrected_text"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CorrectSpelling200Response
instance A.FromJSON CorrectSpelling200Response where
  parseJSON = A.withObject "CorrectSpelling200Response" $ \o ->
    CorrectSpelling200Response
      <$> (o .:? "corrected_text")

-- | ToJSON CorrectSpelling200Response
instance A.ToJSON CorrectSpelling200Response where
  toJSON CorrectSpelling200Response {..} =
   _omitNulls
      [ "corrected_text" .= correctSpelling200ResponseCorrectedText
      ]


-- | Construct a value of type 'CorrectSpelling200Response' (by applying it's required fields, if any)
mkCorrectSpelling200Response
  :: CorrectSpelling200Response
mkCorrectSpelling200Response =
  CorrectSpelling200Response
  { correctSpelling200ResponseCorrectedText = Nothing
  }

-- ** DetectLanguage200ResponseInner
-- | DetectLanguage200ResponseInner
data DetectLanguage200ResponseInner = DetectLanguage200ResponseInner
  { detectLanguage200ResponseInnerLanguage :: !(Maybe Text) -- ^ "language"
  , detectLanguage200ResponseInnerConfidence :: !(Maybe Double) -- ^ "confidence"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON DetectLanguage200ResponseInner
instance A.FromJSON DetectLanguage200ResponseInner where
  parseJSON = A.withObject "DetectLanguage200ResponseInner" $ \o ->
    DetectLanguage200ResponseInner
      <$> (o .:? "language")
      <*> (o .:? "confidence")

-- | ToJSON DetectLanguage200ResponseInner
instance A.ToJSON DetectLanguage200ResponseInner where
  toJSON DetectLanguage200ResponseInner {..} =
   _omitNulls
      [ "language" .= detectLanguage200ResponseInnerLanguage
      , "confidence" .= detectLanguage200ResponseInnerConfidence
      ]


-- | Construct a value of type 'DetectLanguage200ResponseInner' (by applying it's required fields, if any)
mkDetectLanguage200ResponseInner
  :: DetectLanguage200ResponseInner
mkDetectLanguage200ResponseInner =
  DetectLanguage200ResponseInner
  { detectLanguage200ResponseInnerLanguage = Nothing
  , detectLanguage200ResponseInnerConfidence = Nothing
  }

-- ** DetectMainImageColor200ResponseInner
-- | DetectMainImageColor200ResponseInner
data DetectMainImageColor200ResponseInner = DetectMainImageColor200ResponseInner
  { detectMainImageColor200ResponseInnerSpecificColor :: !(Maybe Text) -- ^ "specific_color"
  , detectMainImageColor200ResponseInnerMainColor :: !(Maybe Text) -- ^ "main_color"
  , detectMainImageColor200ResponseInnerHexCode :: !(Maybe Text) -- ^ "hex_code"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON DetectMainImageColor200ResponseInner
instance A.FromJSON DetectMainImageColor200ResponseInner where
  parseJSON = A.withObject "DetectMainImageColor200ResponseInner" $ \o ->
    DetectMainImageColor200ResponseInner
      <$> (o .:? "specific_color")
      <*> (o .:? "main_color")
      <*> (o .:? "hex_code")

-- | ToJSON DetectMainImageColor200ResponseInner
instance A.ToJSON DetectMainImageColor200ResponseInner where
  toJSON DetectMainImageColor200ResponseInner {..} =
   _omitNulls
      [ "specific_color" .= detectMainImageColor200ResponseInnerSpecificColor
      , "main_color" .= detectMainImageColor200ResponseInnerMainColor
      , "hex_code" .= detectMainImageColor200ResponseInnerHexCode
      ]


-- | Construct a value of type 'DetectMainImageColor200ResponseInner' (by applying it's required fields, if any)
mkDetectMainImageColor200ResponseInner
  :: DetectMainImageColor200ResponseInner
mkDetectMainImageColor200ResponseInner =
  DetectMainImageColor200ResponseInner
  { detectMainImageColor200ResponseInnerSpecificColor = Nothing
  , detectMainImageColor200ResponseInnerMainColor = Nothing
  , detectMainImageColor200ResponseInnerHexCode = Nothing
  }

-- ** DetectSentiment200Response
-- | DetectSentiment200Response
data DetectSentiment200Response = DetectSentiment200Response
  { detectSentiment200ResponseDocument :: !(Maybe DetectSentiment200ResponseDocument) -- ^ "document"
  , detectSentiment200ResponseSentences :: !(Maybe [DetectSentiment200ResponseSentencesInner]) -- ^ "sentences"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON DetectSentiment200Response
instance A.FromJSON DetectSentiment200Response where
  parseJSON = A.withObject "DetectSentiment200Response" $ \o ->
    DetectSentiment200Response
      <$> (o .:? "document")
      <*> (o .:? "sentences")

-- | ToJSON DetectSentiment200Response
instance A.ToJSON DetectSentiment200Response where
  toJSON DetectSentiment200Response {..} =
   _omitNulls
      [ "document" .= detectSentiment200ResponseDocument
      , "sentences" .= detectSentiment200ResponseSentences
      ]


-- | Construct a value of type 'DetectSentiment200Response' (by applying it's required fields, if any)
mkDetectSentiment200Response
  :: DetectSentiment200Response
mkDetectSentiment200Response =
  DetectSentiment200Response
  { detectSentiment200ResponseDocument = Nothing
  , detectSentiment200ResponseSentences = Nothing
  }

-- ** DetectSentiment200ResponseDocument
-- | DetectSentiment200ResponseDocument
data DetectSentiment200ResponseDocument = DetectSentiment200ResponseDocument
  { detectSentiment200ResponseDocumentSentiment :: !(Maybe Text) -- ^ "sentiment"
  , detectSentiment200ResponseDocumentConfidence :: !(Maybe Int) -- ^ "confidence"
  , detectSentiment200ResponseDocumentAverageConfidence :: !(Maybe Int) -- ^ "average_confidence"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON DetectSentiment200ResponseDocument
instance A.FromJSON DetectSentiment200ResponseDocument where
  parseJSON = A.withObject "DetectSentiment200ResponseDocument" $ \o ->
    DetectSentiment200ResponseDocument
      <$> (o .:? "sentiment")
      <*> (o .:? "confidence")
      <*> (o .:? "average_confidence")

-- | ToJSON DetectSentiment200ResponseDocument
instance A.ToJSON DetectSentiment200ResponseDocument where
  toJSON DetectSentiment200ResponseDocument {..} =
   _omitNulls
      [ "sentiment" .= detectSentiment200ResponseDocumentSentiment
      , "confidence" .= detectSentiment200ResponseDocumentConfidence
      , "average_confidence" .= detectSentiment200ResponseDocumentAverageConfidence
      ]


-- | Construct a value of type 'DetectSentiment200ResponseDocument' (by applying it's required fields, if any)
mkDetectSentiment200ResponseDocument
  :: DetectSentiment200ResponseDocument
mkDetectSentiment200ResponseDocument =
  DetectSentiment200ResponseDocument
  { detectSentiment200ResponseDocumentSentiment = Nothing
  , detectSentiment200ResponseDocumentConfidence = Nothing
  , detectSentiment200ResponseDocumentAverageConfidence = Nothing
  }

-- ** DetectSentiment200ResponseSentencesInner
-- | DetectSentiment200ResponseSentencesInner
data DetectSentiment200ResponseSentencesInner = DetectSentiment200ResponseSentencesInner
  { detectSentiment200ResponseSentencesInnerLength :: !(Maybe Int) -- ^ "length"
  , detectSentiment200ResponseSentencesInnerSentiment :: !(Maybe Text) -- ^ "sentiment"
  , detectSentiment200ResponseSentencesInnerOffset :: !(Maybe Int) -- ^ "offset"
  , detectSentiment200ResponseSentencesInnerConfidence :: !(Maybe Int) -- ^ "confidence"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON DetectSentiment200ResponseSentencesInner
instance A.FromJSON DetectSentiment200ResponseSentencesInner where
  parseJSON = A.withObject "DetectSentiment200ResponseSentencesInner" $ \o ->
    DetectSentiment200ResponseSentencesInner
      <$> (o .:? "length")
      <*> (o .:? "sentiment")
      <*> (o .:? "offset")
      <*> (o .:? "confidence")

-- | ToJSON DetectSentiment200ResponseSentencesInner
instance A.ToJSON DetectSentiment200ResponseSentencesInner where
  toJSON DetectSentiment200ResponseSentencesInner {..} =
   _omitNulls
      [ "length" .= detectSentiment200ResponseSentencesInnerLength
      , "sentiment" .= detectSentiment200ResponseSentencesInnerSentiment
      , "offset" .= detectSentiment200ResponseSentencesInnerOffset
      , "confidence" .= detectSentiment200ResponseSentencesInnerConfidence
      ]


-- | Construct a value of type 'DetectSentiment200ResponseSentencesInner' (by applying it's required fields, if any)
mkDetectSentiment200ResponseSentencesInner
  :: DetectSentiment200ResponseSentencesInner
mkDetectSentiment200ResponseSentencesInner =
  DetectSentiment200ResponseSentencesInner
  { detectSentiment200ResponseSentencesInnerLength = Nothing
  , detectSentiment200ResponseSentencesInnerSentiment = Nothing
  , detectSentiment200ResponseSentencesInnerOffset = Nothing
  , detectSentiment200ResponseSentencesInnerConfidence = Nothing
  }

-- ** ExtractAuthors200Response
-- | ExtractAuthors200Response
data ExtractAuthors200Response = ExtractAuthors200Response
  { extractAuthors200ResponseAuthors :: !(Maybe [ExtractAuthors200ResponseAuthorsInner]) -- ^ "authors"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ExtractAuthors200Response
instance A.FromJSON ExtractAuthors200Response where
  parseJSON = A.withObject "ExtractAuthors200Response" $ \o ->
    ExtractAuthors200Response
      <$> (o .:? "authors")

-- | ToJSON ExtractAuthors200Response
instance A.ToJSON ExtractAuthors200Response where
  toJSON ExtractAuthors200Response {..} =
   _omitNulls
      [ "authors" .= extractAuthors200ResponseAuthors
      ]


-- | Construct a value of type 'ExtractAuthors200Response' (by applying it's required fields, if any)
mkExtractAuthors200Response
  :: ExtractAuthors200Response
mkExtractAuthors200Response =
  ExtractAuthors200Response
  { extractAuthors200ResponseAuthors = Nothing
  }

-- ** ExtractAuthors200ResponseAuthorsInner
-- | ExtractAuthors200ResponseAuthorsInner
data ExtractAuthors200ResponseAuthorsInner = ExtractAuthors200ResponseAuthorsInner
  { extractAuthors200ResponseAuthorsInnerLink :: !(Maybe Text) -- ^ "link"
  , extractAuthors200ResponseAuthorsInnerName :: !(Maybe Text) -- ^ "name"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ExtractAuthors200ResponseAuthorsInner
instance A.FromJSON ExtractAuthors200ResponseAuthorsInner where
  parseJSON = A.withObject "ExtractAuthors200ResponseAuthorsInner" $ \o ->
    ExtractAuthors200ResponseAuthorsInner
      <$> (o .:? "link")
      <*> (o .:? "name")

-- | ToJSON ExtractAuthors200ResponseAuthorsInner
instance A.ToJSON ExtractAuthors200ResponseAuthorsInner where
  toJSON ExtractAuthors200ResponseAuthorsInner {..} =
   _omitNulls
      [ "link" .= extractAuthors200ResponseAuthorsInnerLink
      , "name" .= extractAuthors200ResponseAuthorsInnerName
      ]


-- | Construct a value of type 'ExtractAuthors200ResponseAuthorsInner' (by applying it's required fields, if any)
mkExtractAuthors200ResponseAuthorsInner
  :: ExtractAuthors200ResponseAuthorsInner
mkExtractAuthors200ResponseAuthorsInner =
  ExtractAuthors200ResponseAuthorsInner
  { extractAuthors200ResponseAuthorsInnerLink = Nothing
  , extractAuthors200ResponseAuthorsInnerName = Nothing
  }

-- ** ExtractContentFromAWebPage200Response
-- | ExtractContentFromAWebPage200Response
data ExtractContentFromAWebPage200Response = ExtractContentFromAWebPage200Response
  { extractContentFromAWebPage200ResponseTitle :: !(Maybe Text) -- ^ "title"
  , extractContentFromAWebPage200ResponseMainText :: !(Maybe Text) -- ^ "main_text"
  , extractContentFromAWebPage200ResponseMainHtml :: !(Maybe Text) -- ^ "main_html"
  , extractContentFromAWebPage200ResponseImages :: !(Maybe [Text]) -- ^ "images"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ExtractContentFromAWebPage200Response
instance A.FromJSON ExtractContentFromAWebPage200Response where
  parseJSON = A.withObject "ExtractContentFromAWebPage200Response" $ \o ->
    ExtractContentFromAWebPage200Response
      <$> (o .:? "title")
      <*> (o .:? "main_text")
      <*> (o .:? "main_html")
      <*> (o .:? "images")

-- | ToJSON ExtractContentFromAWebPage200Response
instance A.ToJSON ExtractContentFromAWebPage200Response where
  toJSON ExtractContentFromAWebPage200Response {..} =
   _omitNulls
      [ "title" .= extractContentFromAWebPage200ResponseTitle
      , "main_text" .= extractContentFromAWebPage200ResponseMainText
      , "main_html" .= extractContentFromAWebPage200ResponseMainHtml
      , "images" .= extractContentFromAWebPage200ResponseImages
      ]


-- | Construct a value of type 'ExtractContentFromAWebPage200Response' (by applying it's required fields, if any)
mkExtractContentFromAWebPage200Response
  :: ExtractContentFromAWebPage200Response
mkExtractContentFromAWebPage200Response =
  ExtractContentFromAWebPage200Response
  { extractContentFromAWebPage200ResponseTitle = Nothing
  , extractContentFromAWebPage200ResponseMainText = Nothing
  , extractContentFromAWebPage200ResponseMainHtml = Nothing
  , extractContentFromAWebPage200ResponseImages = Nothing
  }

-- ** ExtractDates200Response
-- | ExtractDates200Response
data ExtractDates200Response = ExtractDates200Response
  { extractDates200ResponseDates :: !(Maybe [ExtractDates200ResponseDatesInner]) -- ^ "dates"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ExtractDates200Response
instance A.FromJSON ExtractDates200Response where
  parseJSON = A.withObject "ExtractDates200Response" $ \o ->
    ExtractDates200Response
      <$> (o .:? "dates")

-- | ToJSON ExtractDates200Response
instance A.ToJSON ExtractDates200Response where
  toJSON ExtractDates200Response {..} =
   _omitNulls
      [ "dates" .= extractDates200ResponseDates
      ]


-- | Construct a value of type 'ExtractDates200Response' (by applying it's required fields, if any)
mkExtractDates200Response
  :: ExtractDates200Response
mkExtractDates200Response =
  ExtractDates200Response
  { extractDates200ResponseDates = Nothing
  }

-- ** ExtractDates200ResponseDatesInner
-- | ExtractDates200ResponseDatesInner
data ExtractDates200ResponseDatesInner = ExtractDates200ResponseDatesInner
  { extractDates200ResponseDatesInnerStartPosition :: !(Maybe Int) -- ^ "start_position"
  , extractDates200ResponseDatesInnerDate :: !(Maybe Text) -- ^ "date"
  , extractDates200ResponseDatesInnerNormalizedDate :: !(Maybe Double) -- ^ "normalized_date"
  , extractDates200ResponseDatesInnerTag :: !(Maybe Text) -- ^ "tag"
  , extractDates200ResponseDatesInnerEndPosition :: !(Maybe Int) -- ^ "end_position"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ExtractDates200ResponseDatesInner
instance A.FromJSON ExtractDates200ResponseDatesInner where
  parseJSON = A.withObject "ExtractDates200ResponseDatesInner" $ \o ->
    ExtractDates200ResponseDatesInner
      <$> (o .:? "start_position")
      <*> (o .:? "date")
      <*> (o .:? "normalized_date")
      <*> (o .:? "tag")
      <*> (o .:? "end_position")

-- | ToJSON ExtractDates200ResponseDatesInner
instance A.ToJSON ExtractDates200ResponseDatesInner where
  toJSON ExtractDates200ResponseDatesInner {..} =
   _omitNulls
      [ "start_position" .= extractDates200ResponseDatesInnerStartPosition
      , "date" .= extractDates200ResponseDatesInnerDate
      , "normalized_date" .= extractDates200ResponseDatesInnerNormalizedDate
      , "tag" .= extractDates200ResponseDatesInnerTag
      , "end_position" .= extractDates200ResponseDatesInnerEndPosition
      ]


-- | Construct a value of type 'ExtractDates200ResponseDatesInner' (by applying it's required fields, if any)
mkExtractDates200ResponseDatesInner
  :: ExtractDates200ResponseDatesInner
mkExtractDates200ResponseDatesInner =
  ExtractDates200ResponseDatesInner
  { extractDates200ResponseDatesInnerStartPosition = Nothing
  , extractDates200ResponseDatesInnerDate = Nothing
  , extractDates200ResponseDatesInnerNormalizedDate = Nothing
  , extractDates200ResponseDatesInnerTag = Nothing
  , extractDates200ResponseDatesInnerEndPosition = Nothing
  }

-- ** ExtractEntities200Response
-- | ExtractEntities200Response
data ExtractEntities200Response = ExtractEntities200Response
  { extractEntities200ResponseEntities :: !(Maybe [ExtractEntities200ResponseEntitiesInner]) -- ^ "entities"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ExtractEntities200Response
instance A.FromJSON ExtractEntities200Response where
  parseJSON = A.withObject "ExtractEntities200Response" $ \o ->
    ExtractEntities200Response
      <$> (o .:? "entities")

-- | ToJSON ExtractEntities200Response
instance A.ToJSON ExtractEntities200Response where
  toJSON ExtractEntities200Response {..} =
   _omitNulls
      [ "entities" .= extractEntities200ResponseEntities
      ]


-- | Construct a value of type 'ExtractEntities200Response' (by applying it's required fields, if any)
mkExtractEntities200Response
  :: ExtractEntities200Response
mkExtractEntities200Response =
  ExtractEntities200Response
  { extractEntities200ResponseEntities = Nothing
  }

-- ** ExtractEntities200ResponseEntitiesInner
-- | ExtractEntities200ResponseEntitiesInner
data ExtractEntities200ResponseEntitiesInner = ExtractEntities200ResponseEntitiesInner
  { extractEntities200ResponseEntitiesInnerStartPosition :: !(Maybe Int) -- ^ "start_position"
  , extractEntities200ResponseEntitiesInnerImage :: !(Maybe Text) -- ^ "image"
  , extractEntities200ResponseEntitiesInnerType :: !(Maybe Text) -- ^ "type"
  , extractEntities200ResponseEntitiesInnerValue :: !(Maybe Text) -- ^ "value"
  , extractEntities200ResponseEntitiesInnerEndPosition :: !(Maybe Int) -- ^ "end_position"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ExtractEntities200ResponseEntitiesInner
instance A.FromJSON ExtractEntities200ResponseEntitiesInner where
  parseJSON = A.withObject "ExtractEntities200ResponseEntitiesInner" $ \o ->
    ExtractEntities200ResponseEntitiesInner
      <$> (o .:? "start_position")
      <*> (o .:? "image")
      <*> (o .:? "type")
      <*> (o .:? "value")
      <*> (o .:? "end_position")

-- | ToJSON ExtractEntities200ResponseEntitiesInner
instance A.ToJSON ExtractEntities200ResponseEntitiesInner where
  toJSON ExtractEntities200ResponseEntitiesInner {..} =
   _omitNulls
      [ "start_position" .= extractEntities200ResponseEntitiesInnerStartPosition
      , "image" .= extractEntities200ResponseEntitiesInnerImage
      , "type" .= extractEntities200ResponseEntitiesInnerType
      , "value" .= extractEntities200ResponseEntitiesInnerValue
      , "end_position" .= extractEntities200ResponseEntitiesInnerEndPosition
      ]


-- | Construct a value of type 'ExtractEntities200ResponseEntitiesInner' (by applying it's required fields, if any)
mkExtractEntities200ResponseEntitiesInner
  :: ExtractEntities200ResponseEntitiesInner
mkExtractEntities200ResponseEntitiesInner =
  ExtractEntities200ResponseEntitiesInner
  { extractEntities200ResponseEntitiesInnerStartPosition = Nothing
  , extractEntities200ResponseEntitiesInnerImage = Nothing
  , extractEntities200ResponseEntitiesInnerType = Nothing
  , extractEntities200ResponseEntitiesInnerValue = Nothing
  , extractEntities200ResponseEntitiesInnerEndPosition = Nothing
  }

-- ** ExtractNews200Response
-- | ExtractNews200Response
data ExtractNews200Response = ExtractNews200Response
  { extractNews200ResponseTitle :: !(Maybe Text) -- ^ "title"
  , extractNews200ResponseText :: !(Maybe Text) -- ^ "text"
  , extractNews200ResponseUrl :: !(Maybe Text) -- ^ "url"
  , extractNews200ResponseImage :: !(Maybe Text) -- ^ "image"
  , extractNews200ResponsePublishDate :: !(Maybe Text) -- ^ "publish_date"
  , extractNews200ResponseAuthor :: !(Maybe Text) -- ^ "author"
  , extractNews200ResponseLanguage :: !(Maybe Text) -- ^ "language"
  , extractNews200ResponseSourceCountry :: !(Maybe Text) -- ^ "source_country"
  , extractNews200ResponseSentiment :: !(Maybe Double) -- ^ "sentiment"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ExtractNews200Response
instance A.FromJSON ExtractNews200Response where
  parseJSON = A.withObject "ExtractNews200Response" $ \o ->
    ExtractNews200Response
      <$> (o .:? "title")
      <*> (o .:? "text")
      <*> (o .:? "url")
      <*> (o .:? "image")
      <*> (o .:? "publish_date")
      <*> (o .:? "author")
      <*> (o .:? "language")
      <*> (o .:? "source_country")
      <*> (o .:? "sentiment")

-- | ToJSON ExtractNews200Response
instance A.ToJSON ExtractNews200Response where
  toJSON ExtractNews200Response {..} =
   _omitNulls
      [ "title" .= extractNews200ResponseTitle
      , "text" .= extractNews200ResponseText
      , "url" .= extractNews200ResponseUrl
      , "image" .= extractNews200ResponseImage
      , "publish_date" .= extractNews200ResponsePublishDate
      , "author" .= extractNews200ResponseAuthor
      , "language" .= extractNews200ResponseLanguage
      , "source_country" .= extractNews200ResponseSourceCountry
      , "sentiment" .= extractNews200ResponseSentiment
      ]


-- | Construct a value of type 'ExtractNews200Response' (by applying it's required fields, if any)
mkExtractNews200Response
  :: ExtractNews200Response
mkExtractNews200Response =
  ExtractNews200Response
  { extractNews200ResponseTitle = Nothing
  , extractNews200ResponseText = Nothing
  , extractNews200ResponseUrl = Nothing
  , extractNews200ResponseImage = Nothing
  , extractNews200ResponsePublishDate = Nothing
  , extractNews200ResponseAuthor = Nothing
  , extractNews200ResponseLanguage = Nothing
  , extractNews200ResponseSourceCountry = Nothing
  , extractNews200ResponseSentiment = Nothing
  }

-- ** ExtractPublishDate200Response
-- | ExtractPublishDate200Response
data ExtractPublishDate200Response = ExtractPublishDate200Response
  { extractPublishDate200ResponsePublishDate :: !(Maybe Text) -- ^ "publish_date"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ExtractPublishDate200Response
instance A.FromJSON ExtractPublishDate200Response where
  parseJSON = A.withObject "ExtractPublishDate200Response" $ \o ->
    ExtractPublishDate200Response
      <$> (o .:? "publish_date")

-- | ToJSON ExtractPublishDate200Response
instance A.ToJSON ExtractPublishDate200Response where
  toJSON ExtractPublishDate200Response {..} =
   _omitNulls
      [ "publish_date" .= extractPublishDate200ResponsePublishDate
      ]


-- | Construct a value of type 'ExtractPublishDate200Response' (by applying it's required fields, if any)
mkExtractPublishDate200Response
  :: ExtractPublishDate200Response
mkExtractPublishDate200Response =
  ExtractPublishDate200Response
  { extractPublishDate200ResponsePublishDate = Nothing
  }

-- ** FindSimilarBooks200Response
-- | FindSimilarBooks200Response
data FindSimilarBooks200Response = FindSimilarBooks200Response
  { findSimilarBooks200ResponseSimilarBooks :: !(Maybe [SearchBooks200ResponseBooksInner]) -- ^ "similar_books"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON FindSimilarBooks200Response
instance A.FromJSON FindSimilarBooks200Response where
  parseJSON = A.withObject "FindSimilarBooks200Response" $ \o ->
    FindSimilarBooks200Response
      <$> (o .:? "similar_books")

-- | ToJSON FindSimilarBooks200Response
instance A.ToJSON FindSimilarBooks200Response where
  toJSON FindSimilarBooks200Response {..} =
   _omitNulls
      [ "similar_books" .= findSimilarBooks200ResponseSimilarBooks
      ]


-- | Construct a value of type 'FindSimilarBooks200Response' (by applying it's required fields, if any)
mkFindSimilarBooks200Response
  :: FindSimilarBooks200Response
mkFindSimilarBooks200Response =
  FindSimilarBooks200Response
  { findSimilarBooks200ResponseSimilarBooks = Nothing
  }

-- ** GenerateNonsenseWord200Response
-- | GenerateNonsenseWord200Response
data GenerateNonsenseWord200Response = GenerateNonsenseWord200Response
  { generateNonsenseWord200ResponseWord :: !(Maybe Text) -- ^ "word"
  , generateNonsenseWord200ResponseRating :: !(Maybe Double) -- ^ "rating"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GenerateNonsenseWord200Response
instance A.FromJSON GenerateNonsenseWord200Response where
  parseJSON = A.withObject "GenerateNonsenseWord200Response" $ \o ->
    GenerateNonsenseWord200Response
      <$> (o .:? "word")
      <*> (o .:? "rating")

-- | ToJSON GenerateNonsenseWord200Response
instance A.ToJSON GenerateNonsenseWord200Response where
  toJSON GenerateNonsenseWord200Response {..} =
   _omitNulls
      [ "word" .= generateNonsenseWord200ResponseWord
      , "rating" .= generateNonsenseWord200ResponseRating
      ]


-- | Construct a value of type 'GenerateNonsenseWord200Response' (by applying it's required fields, if any)
mkGenerateNonsenseWord200Response
  :: GenerateNonsenseWord200Response
mkGenerateNonsenseWord200Response =
  GenerateNonsenseWord200Response
  { generateNonsenseWord200ResponseWord = Nothing
  , generateNonsenseWord200ResponseRating = Nothing
  }

-- ** ListWordSynonyms200Response
-- | ListWordSynonyms200Response
data ListWordSynonyms200Response = ListWordSynonyms200Response
  { listWordSynonyms200ResponseSynonyms :: !(Maybe [Text]) -- ^ "synonyms"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ListWordSynonyms200Response
instance A.FromJSON ListWordSynonyms200Response where
  parseJSON = A.withObject "ListWordSynonyms200Response" $ \o ->
    ListWordSynonyms200Response
      <$> (o .:? "synonyms")

-- | ToJSON ListWordSynonyms200Response
instance A.ToJSON ListWordSynonyms200Response where
  toJSON ListWordSynonyms200Response {..} =
   _omitNulls
      [ "synonyms" .= listWordSynonyms200ResponseSynonyms
      ]


-- | Construct a value of type 'ListWordSynonyms200Response' (by applying it's required fields, if any)
mkListWordSynonyms200Response
  :: ListWordSynonyms200Response
mkListWordSynonyms200Response =
  ListWordSynonyms200Response
  { listWordSynonyms200ResponseSynonyms = Nothing
  }

-- ** PartOfSpeechTagging200Response
-- | PartOfSpeechTagging200Response
data PartOfSpeechTagging200Response = PartOfSpeechTagging200Response
  { partOfSpeechTagging200ResponseTaggedText :: !(Maybe Text) -- ^ "tagged_text"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PartOfSpeechTagging200Response
instance A.FromJSON PartOfSpeechTagging200Response where
  parseJSON = A.withObject "PartOfSpeechTagging200Response" $ \o ->
    PartOfSpeechTagging200Response
      <$> (o .:? "tagged_text")

-- | ToJSON PartOfSpeechTagging200Response
instance A.ToJSON PartOfSpeechTagging200Response where
  toJSON PartOfSpeechTagging200Response {..} =
   _omitNulls
      [ "tagged_text" .= partOfSpeechTagging200ResponseTaggedText
      ]


-- | Construct a value of type 'PartOfSpeechTagging200Response' (by applying it's required fields, if any)
mkPartOfSpeechTagging200Response
  :: PartOfSpeechTagging200Response
mkPartOfSpeechTagging200Response =
  PartOfSpeechTagging200Response
  { partOfSpeechTagging200ResponseTaggedText = Nothing
  }

-- ** PluralizeWord200Response
-- | PluralizeWord200Response
data PluralizeWord200Response = PluralizeWord200Response
  { pluralizeWord200ResponseOriginal :: !(Maybe Text) -- ^ "original"
  , pluralizeWord200ResponsePlural :: !(Maybe Text) -- ^ "plural"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PluralizeWord200Response
instance A.FromJSON PluralizeWord200Response where
  parseJSON = A.withObject "PluralizeWord200Response" $ \o ->
    PluralizeWord200Response
      <$> (o .:? "original")
      <*> (o .:? "plural")

-- | ToJSON PluralizeWord200Response
instance A.ToJSON PluralizeWord200Response where
  toJSON PluralizeWord200Response {..} =
   _omitNulls
      [ "original" .= pluralizeWord200ResponseOriginal
      , "plural" .= pluralizeWord200ResponsePlural
      ]


-- | Construct a value of type 'PluralizeWord200Response' (by applying it's required fields, if any)
mkPluralizeWord200Response
  :: PluralizeWord200Response
mkPluralizeWord200Response =
  PluralizeWord200Response
  { pluralizeWord200ResponseOriginal = Nothing
  , pluralizeWord200ResponsePlural = Nothing
  }

-- ** RandomMeme200Response
-- | RandomMeme200Response
data RandomMeme200Response = RandomMeme200Response
  { randomMeme200ResponseDescription :: !(Maybe Text) -- ^ "description"
  , randomMeme200ResponseUrl :: !(Maybe Text) -- ^ "url"
  , randomMeme200ResponseType :: !(Maybe Text) -- ^ "type"
  , randomMeme200ResponseWidth :: !(Maybe Int) -- ^ "width"
  , randomMeme200ResponseHeight :: !(Maybe Int) -- ^ "height"
  , randomMeme200ResponseRatio :: !(Maybe Double) -- ^ "ratio"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RandomMeme200Response
instance A.FromJSON RandomMeme200Response where
  parseJSON = A.withObject "RandomMeme200Response" $ \o ->
    RandomMeme200Response
      <$> (o .:? "description")
      <*> (o .:? "url")
      <*> (o .:? "type")
      <*> (o .:? "width")
      <*> (o .:? "height")
      <*> (o .:? "ratio")

-- | ToJSON RandomMeme200Response
instance A.ToJSON RandomMeme200Response where
  toJSON RandomMeme200Response {..} =
   _omitNulls
      [ "description" .= randomMeme200ResponseDescription
      , "url" .= randomMeme200ResponseUrl
      , "type" .= randomMeme200ResponseType
      , "width" .= randomMeme200ResponseWidth
      , "height" .= randomMeme200ResponseHeight
      , "ratio" .= randomMeme200ResponseRatio
      ]


-- | Construct a value of type 'RandomMeme200Response' (by applying it's required fields, if any)
mkRandomMeme200Response
  :: RandomMeme200Response
mkRandomMeme200Response =
  RandomMeme200Response
  { randomMeme200ResponseDescription = Nothing
  , randomMeme200ResponseUrl = Nothing
  , randomMeme200ResponseType = Nothing
  , randomMeme200ResponseWidth = Nothing
  , randomMeme200ResponseHeight = Nothing
  , randomMeme200ResponseRatio = Nothing
  }

-- ** RandomPoem200Response
-- | RandomPoem200Response
data RandomPoem200Response = RandomPoem200Response
  { randomPoem200ResponseTitle :: !(Maybe Text) -- ^ "title"
  , randomPoem200ResponseAuthor :: !(Maybe Text) -- ^ "author"
  , randomPoem200ResponsePoem :: !(Maybe Text) -- ^ "poem"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RandomPoem200Response
instance A.FromJSON RandomPoem200Response where
  parseJSON = A.withObject "RandomPoem200Response" $ \o ->
    RandomPoem200Response
      <$> (o .:? "title")
      <*> (o .:? "author")
      <*> (o .:? "poem")

-- | ToJSON RandomPoem200Response
instance A.ToJSON RandomPoem200Response where
  toJSON RandomPoem200Response {..} =
   _omitNulls
      [ "title" .= randomPoem200ResponseTitle
      , "author" .= randomPoem200ResponseAuthor
      , "poem" .= randomPoem200ResponsePoem
      ]


-- | Construct a value of type 'RandomPoem200Response' (by applying it's required fields, if any)
mkRandomPoem200Response
  :: RandomPoem200Response
mkRandomPoem200Response =
  RandomPoem200Response
  { randomPoem200ResponseTitle = Nothing
  , randomPoem200ResponseAuthor = Nothing
  , randomPoem200ResponsePoem = Nothing
  }

-- ** RandomQuote200Response
-- | RandomQuote200Response
data RandomQuote200Response = RandomQuote200Response
  { randomQuote200ResponseAuthor :: !(Maybe Text) -- ^ "author"
  , randomQuote200ResponseQuote :: !(Maybe Text) -- ^ "quote"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RandomQuote200Response
instance A.FromJSON RandomQuote200Response where
  parseJSON = A.withObject "RandomQuote200Response" $ \o ->
    RandomQuote200Response
      <$> (o .:? "author")
      <*> (o .:? "quote")

-- | ToJSON RandomQuote200Response
instance A.ToJSON RandomQuote200Response where
  toJSON RandomQuote200Response {..} =
   _omitNulls
      [ "author" .= randomQuote200ResponseAuthor
      , "quote" .= randomQuote200ResponseQuote
      ]


-- | Construct a value of type 'RandomQuote200Response' (by applying it's required fields, if any)
mkRandomQuote200Response
  :: RandomQuote200Response
mkRandomQuote200Response =
  RandomQuote200Response
  { randomQuote200ResponseAuthor = Nothing
  , randomQuote200ResponseQuote = Nothing
  }

-- ** RandomTrivia200Response
-- | RandomTrivia200Response
data RandomTrivia200Response = RandomTrivia200Response
  { randomTrivia200ResponseTrivia :: !(Maybe Text) -- ^ "trivia"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RandomTrivia200Response
instance A.FromJSON RandomTrivia200Response where
  parseJSON = A.withObject "RandomTrivia200Response" $ \o ->
    RandomTrivia200Response
      <$> (o .:? "trivia")

-- | ToJSON RandomTrivia200Response
instance A.ToJSON RandomTrivia200Response where
  toJSON RandomTrivia200Response {..} =
   _omitNulls
      [ "trivia" .= randomTrivia200ResponseTrivia
      ]


-- | Construct a value of type 'RandomTrivia200Response' (by applying it's required fields, if any)
mkRandomTrivia200Response
  :: RandomTrivia200Response
mkRandomTrivia200Response =
  RandomTrivia200Response
  { randomTrivia200ResponseTrivia = Nothing
  }

-- ** ReadKeyValueFromStore200Response
-- | ReadKeyValueFromStore200Response
data ReadKeyValueFromStore200Response = ReadKeyValueFromStore200Response
  { readKeyValueFromStore200ResponseValue :: !(Maybe Text) -- ^ "value"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ReadKeyValueFromStore200Response
instance A.FromJSON ReadKeyValueFromStore200Response where
  parseJSON = A.withObject "ReadKeyValueFromStore200Response" $ \o ->
    ReadKeyValueFromStore200Response
      <$> (o .:? "value")

-- | ToJSON ReadKeyValueFromStore200Response
instance A.ToJSON ReadKeyValueFromStore200Response where
  toJSON ReadKeyValueFromStore200Response {..} =
   _omitNulls
      [ "value" .= readKeyValueFromStore200ResponseValue
      ]


-- | Construct a value of type 'ReadKeyValueFromStore200Response' (by applying it's required fields, if any)
mkReadKeyValueFromStore200Response
  :: ReadKeyValueFromStore200Response
mkReadKeyValueFromStore200Response =
  ReadKeyValueFromStore200Response
  { readKeyValueFromStore200ResponseValue = Nothing
  }

-- ** ScoreReadability200Response
-- | ScoreReadability200Response
data ScoreReadability200Response = ScoreReadability200Response
  { scoreReadability200ResponseReadability :: !(Maybe ScoreText200ResponseReadability) -- ^ "readability"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ScoreReadability200Response
instance A.FromJSON ScoreReadability200Response where
  parseJSON = A.withObject "ScoreReadability200Response" $ \o ->
    ScoreReadability200Response
      <$> (o .:? "readability")

-- | ToJSON ScoreReadability200Response
instance A.ToJSON ScoreReadability200Response where
  toJSON ScoreReadability200Response {..} =
   _omitNulls
      [ "readability" .= scoreReadability200ResponseReadability
      ]


-- | Construct a value of type 'ScoreReadability200Response' (by applying it's required fields, if any)
mkScoreReadability200Response
  :: ScoreReadability200Response
mkScoreReadability200Response =
  ScoreReadability200Response
  { scoreReadability200ResponseReadability = Nothing
  }

-- ** ScoreText200Response
-- | ScoreText200Response
data ScoreText200Response = ScoreText200Response
  { scoreText200ResponseNumberOfWords :: !(Maybe Int) -- ^ "number_of_words"
  , scoreText200ResponseNumberOfSentences :: !(Maybe Int) -- ^ "number_of_sentences"
  , scoreText200ResponseReadability :: !(Maybe ScoreText200ResponseReadability) -- ^ "readability"
  , scoreText200ResponseSkimmability :: !(Maybe ScoreText200ResponseSkimmability) -- ^ "skimmability"
  , scoreText200ResponseInterestingness :: !(Maybe ScoreText200ResponseInterestingness) -- ^ "interestingness"
  , scoreText200ResponseStyle :: !(Maybe ScoreText200ResponseStyle) -- ^ "style"
  , scoreText200ResponseTotalScore :: !(Maybe Double) -- ^ "total_score"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ScoreText200Response
instance A.FromJSON ScoreText200Response where
  parseJSON = A.withObject "ScoreText200Response" $ \o ->
    ScoreText200Response
      <$> (o .:? "number_of_words")
      <*> (o .:? "number_of_sentences")
      <*> (o .:? "readability")
      <*> (o .:? "skimmability")
      <*> (o .:? "interestingness")
      <*> (o .:? "style")
      <*> (o .:? "total_score")

-- | ToJSON ScoreText200Response
instance A.ToJSON ScoreText200Response where
  toJSON ScoreText200Response {..} =
   _omitNulls
      [ "number_of_words" .= scoreText200ResponseNumberOfWords
      , "number_of_sentences" .= scoreText200ResponseNumberOfSentences
      , "readability" .= scoreText200ResponseReadability
      , "skimmability" .= scoreText200ResponseSkimmability
      , "interestingness" .= scoreText200ResponseInterestingness
      , "style" .= scoreText200ResponseStyle
      , "total_score" .= scoreText200ResponseTotalScore
      ]


-- | Construct a value of type 'ScoreText200Response' (by applying it's required fields, if any)
mkScoreText200Response
  :: ScoreText200Response
mkScoreText200Response =
  ScoreText200Response
  { scoreText200ResponseNumberOfWords = Nothing
  , scoreText200ResponseNumberOfSentences = Nothing
  , scoreText200ResponseReadability = Nothing
  , scoreText200ResponseSkimmability = Nothing
  , scoreText200ResponseInterestingness = Nothing
  , scoreText200ResponseStyle = Nothing
  , scoreText200ResponseTotalScore = Nothing
  }

-- ** ScoreText200ResponseInterestingness
-- | ScoreText200ResponseInterestingness
data ScoreText200ResponseInterestingness = ScoreText200ResponseInterestingness
  { scoreText200ResponseInterestingnessMainscores :: !(Maybe ScoreText200ResponseSkimmabilityMainscores) -- ^ "mainscores"
  , scoreText200ResponseInterestingnessSubscores :: !(Maybe ScoreText200ResponseInterestingnessSubscores) -- ^ "subscores"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ScoreText200ResponseInterestingness
instance A.FromJSON ScoreText200ResponseInterestingness where
  parseJSON = A.withObject "ScoreText200ResponseInterestingness" $ \o ->
    ScoreText200ResponseInterestingness
      <$> (o .:? "mainscores")
      <*> (o .:? "subscores")

-- | ToJSON ScoreText200ResponseInterestingness
instance A.ToJSON ScoreText200ResponseInterestingness where
  toJSON ScoreText200ResponseInterestingness {..} =
   _omitNulls
      [ "mainscores" .= scoreText200ResponseInterestingnessMainscores
      , "subscores" .= scoreText200ResponseInterestingnessSubscores
      ]


-- | Construct a value of type 'ScoreText200ResponseInterestingness' (by applying it's required fields, if any)
mkScoreText200ResponseInterestingness
  :: ScoreText200ResponseInterestingness
mkScoreText200ResponseInterestingness =
  ScoreText200ResponseInterestingness
  { scoreText200ResponseInterestingnessMainscores = Nothing
  , scoreText200ResponseInterestingnessSubscores = Nothing
  }

-- ** ScoreText200ResponseInterestingnessSubscores
-- | ScoreText200ResponseInterestingnessSubscores
data ScoreText200ResponseInterestingnessSubscores = ScoreText200ResponseInterestingnessSubscores
  { scoreText200ResponseInterestingnessSubscoresTitleRatingScore :: !(Maybe [Int]) -- ^ "title_rating_score"
  , scoreText200ResponseInterestingnessSubscoresQuoteScore :: !(Maybe [Int]) -- ^ "quote_score"
  , scoreText200ResponseInterestingnessSubscoresLengthScore :: !(Maybe [Int]) -- ^ "length_score"
  , scoreText200ResponseInterestingnessSubscoresLinkScore :: !(Maybe [Int]) -- ^ "link_score"
  , scoreText200ResponseInterestingnessSubscoresGoogleHitsScore :: !(Maybe [Int]) -- ^ "google_hits_score"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ScoreText200ResponseInterestingnessSubscores
instance A.FromJSON ScoreText200ResponseInterestingnessSubscores where
  parseJSON = A.withObject "ScoreText200ResponseInterestingnessSubscores" $ \o ->
    ScoreText200ResponseInterestingnessSubscores
      <$> (o .:? "title_rating_score")
      <*> (o .:? "quote_score")
      <*> (o .:? "length_score")
      <*> (o .:? "link_score")
      <*> (o .:? "google_hits_score")

-- | ToJSON ScoreText200ResponseInterestingnessSubscores
instance A.ToJSON ScoreText200ResponseInterestingnessSubscores where
  toJSON ScoreText200ResponseInterestingnessSubscores {..} =
   _omitNulls
      [ "title_rating_score" .= scoreText200ResponseInterestingnessSubscoresTitleRatingScore
      , "quote_score" .= scoreText200ResponseInterestingnessSubscoresQuoteScore
      , "length_score" .= scoreText200ResponseInterestingnessSubscoresLengthScore
      , "link_score" .= scoreText200ResponseInterestingnessSubscoresLinkScore
      , "google_hits_score" .= scoreText200ResponseInterestingnessSubscoresGoogleHitsScore
      ]


-- | Construct a value of type 'ScoreText200ResponseInterestingnessSubscores' (by applying it's required fields, if any)
mkScoreText200ResponseInterestingnessSubscores
  :: ScoreText200ResponseInterestingnessSubscores
mkScoreText200ResponseInterestingnessSubscores =
  ScoreText200ResponseInterestingnessSubscores
  { scoreText200ResponseInterestingnessSubscoresTitleRatingScore = Nothing
  , scoreText200ResponseInterestingnessSubscoresQuoteScore = Nothing
  , scoreText200ResponseInterestingnessSubscoresLengthScore = Nothing
  , scoreText200ResponseInterestingnessSubscoresLinkScore = Nothing
  , scoreText200ResponseInterestingnessSubscoresGoogleHitsScore = Nothing
  }

-- ** ScoreText200ResponseReadability
-- | ScoreText200ResponseReadability
data ScoreText200ResponseReadability = ScoreText200ResponseReadability
  { scoreText200ResponseReadabilityMainscores :: !(Maybe ScoreText200ResponseReadabilityMainscores) -- ^ "mainscores"
  , scoreText200ResponseReadabilitySubscores :: !(Maybe ScoreText200ResponseReadabilitySubscores) -- ^ "subscores"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ScoreText200ResponseReadability
instance A.FromJSON ScoreText200ResponseReadability where
  parseJSON = A.withObject "ScoreText200ResponseReadability" $ \o ->
    ScoreText200ResponseReadability
      <$> (o .:? "mainscores")
      <*> (o .:? "subscores")

-- | ToJSON ScoreText200ResponseReadability
instance A.ToJSON ScoreText200ResponseReadability where
  toJSON ScoreText200ResponseReadability {..} =
   _omitNulls
      [ "mainscores" .= scoreText200ResponseReadabilityMainscores
      , "subscores" .= scoreText200ResponseReadabilitySubscores
      ]


-- | Construct a value of type 'ScoreText200ResponseReadability' (by applying it's required fields, if any)
mkScoreText200ResponseReadability
  :: ScoreText200ResponseReadability
mkScoreText200ResponseReadability =
  ScoreText200ResponseReadability
  { scoreText200ResponseReadabilityMainscores = Nothing
  , scoreText200ResponseReadabilitySubscores = Nothing
  }

-- ** ScoreText200ResponseReadabilityMainscores
-- | ScoreText200ResponseReadabilityMainscores
data ScoreText200ResponseReadabilityMainscores = ScoreText200ResponseReadabilityMainscores
  { scoreText200ResponseReadabilityMainscoresTotalPossible :: !(Maybe Int) -- ^ "total_possible"
  , scoreText200ResponseReadabilityMainscoresTotal :: !(Maybe Int) -- ^ "total"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ScoreText200ResponseReadabilityMainscores
instance A.FromJSON ScoreText200ResponseReadabilityMainscores where
  parseJSON = A.withObject "ScoreText200ResponseReadabilityMainscores" $ \o ->
    ScoreText200ResponseReadabilityMainscores
      <$> (o .:? "total_possible")
      <*> (o .:? "total")

-- | ToJSON ScoreText200ResponseReadabilityMainscores
instance A.ToJSON ScoreText200ResponseReadabilityMainscores where
  toJSON ScoreText200ResponseReadabilityMainscores {..} =
   _omitNulls
      [ "total_possible" .= scoreText200ResponseReadabilityMainscoresTotalPossible
      , "total" .= scoreText200ResponseReadabilityMainscoresTotal
      ]


-- | Construct a value of type 'ScoreText200ResponseReadabilityMainscores' (by applying it's required fields, if any)
mkScoreText200ResponseReadabilityMainscores
  :: ScoreText200ResponseReadabilityMainscores
mkScoreText200ResponseReadabilityMainscores =
  ScoreText200ResponseReadabilityMainscores
  { scoreText200ResponseReadabilityMainscoresTotalPossible = Nothing
  , scoreText200ResponseReadabilityMainscoresTotal = Nothing
  }

-- ** ScoreText200ResponseReadabilitySubscores
-- | ScoreText200ResponseReadabilitySubscores
data ScoreText200ResponseReadabilitySubscores = ScoreText200ResponseReadabilitySubscores
  { scoreText200ResponseReadabilitySubscoresReadingTimeSeconds :: !(Maybe Int) -- ^ "reading_time_seconds"
  , scoreText200ResponseReadabilitySubscoresForcast :: !(Maybe Double) -- ^ "forcast"
  , scoreText200ResponseReadabilitySubscoresFlesch :: !(Maybe Double) -- ^ "flesch"
  , scoreText200ResponseReadabilitySubscoresSmog :: !(Maybe Double) -- ^ "smog"
  , scoreText200ResponseReadabilitySubscoresAri :: !(Maybe Double) -- ^ "ari"
  , scoreText200ResponseReadabilitySubscoresLix :: !(Maybe Double) -- ^ "lix"
  , scoreText200ResponseReadabilitySubscoresColemanLiau :: !(Maybe Double) -- ^ "coleman_liau"
  , scoreText200ResponseReadabilitySubscoresKincaid :: !(Maybe Double) -- ^ "kincaid"
  , scoreText200ResponseReadabilitySubscoresFog :: !(Maybe Double) -- ^ "fog"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ScoreText200ResponseReadabilitySubscores
instance A.FromJSON ScoreText200ResponseReadabilitySubscores where
  parseJSON = A.withObject "ScoreText200ResponseReadabilitySubscores" $ \o ->
    ScoreText200ResponseReadabilitySubscores
      <$> (o .:? "reading_time_seconds")
      <*> (o .:? "forcast")
      <*> (o .:? "flesch")
      <*> (o .:? "smog")
      <*> (o .:? "ari")
      <*> (o .:? "lix")
      <*> (o .:? "coleman_liau")
      <*> (o .:? "kincaid")
      <*> (o .:? "fog")

-- | ToJSON ScoreText200ResponseReadabilitySubscores
instance A.ToJSON ScoreText200ResponseReadabilitySubscores where
  toJSON ScoreText200ResponseReadabilitySubscores {..} =
   _omitNulls
      [ "reading_time_seconds" .= scoreText200ResponseReadabilitySubscoresReadingTimeSeconds
      , "forcast" .= scoreText200ResponseReadabilitySubscoresForcast
      , "flesch" .= scoreText200ResponseReadabilitySubscoresFlesch
      , "smog" .= scoreText200ResponseReadabilitySubscoresSmog
      , "ari" .= scoreText200ResponseReadabilitySubscoresAri
      , "lix" .= scoreText200ResponseReadabilitySubscoresLix
      , "coleman_liau" .= scoreText200ResponseReadabilitySubscoresColemanLiau
      , "kincaid" .= scoreText200ResponseReadabilitySubscoresKincaid
      , "fog" .= scoreText200ResponseReadabilitySubscoresFog
      ]


-- | Construct a value of type 'ScoreText200ResponseReadabilitySubscores' (by applying it's required fields, if any)
mkScoreText200ResponseReadabilitySubscores
  :: ScoreText200ResponseReadabilitySubscores
mkScoreText200ResponseReadabilitySubscores =
  ScoreText200ResponseReadabilitySubscores
  { scoreText200ResponseReadabilitySubscoresReadingTimeSeconds = Nothing
  , scoreText200ResponseReadabilitySubscoresForcast = Nothing
  , scoreText200ResponseReadabilitySubscoresFlesch = Nothing
  , scoreText200ResponseReadabilitySubscoresSmog = Nothing
  , scoreText200ResponseReadabilitySubscoresAri = Nothing
  , scoreText200ResponseReadabilitySubscoresLix = Nothing
  , scoreText200ResponseReadabilitySubscoresColemanLiau = Nothing
  , scoreText200ResponseReadabilitySubscoresKincaid = Nothing
  , scoreText200ResponseReadabilitySubscoresFog = Nothing
  }

-- ** ScoreText200ResponseSkimmability
-- | ScoreText200ResponseSkimmability
data ScoreText200ResponseSkimmability = ScoreText200ResponseSkimmability
  { scoreText200ResponseSkimmabilityMainscores :: !(Maybe ScoreText200ResponseSkimmabilityMainscores) -- ^ "mainscores"
  , scoreText200ResponseSkimmabilitySubscores :: !(Maybe ScoreText200ResponseSkimmabilitySubscores) -- ^ "subscores"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ScoreText200ResponseSkimmability
instance A.FromJSON ScoreText200ResponseSkimmability where
  parseJSON = A.withObject "ScoreText200ResponseSkimmability" $ \o ->
    ScoreText200ResponseSkimmability
      <$> (o .:? "mainscores")
      <*> (o .:? "subscores")

-- | ToJSON ScoreText200ResponseSkimmability
instance A.ToJSON ScoreText200ResponseSkimmability where
  toJSON ScoreText200ResponseSkimmability {..} =
   _omitNulls
      [ "mainscores" .= scoreText200ResponseSkimmabilityMainscores
      , "subscores" .= scoreText200ResponseSkimmabilitySubscores
      ]


-- | Construct a value of type 'ScoreText200ResponseSkimmability' (by applying it's required fields, if any)
mkScoreText200ResponseSkimmability
  :: ScoreText200ResponseSkimmability
mkScoreText200ResponseSkimmability =
  ScoreText200ResponseSkimmability
  { scoreText200ResponseSkimmabilityMainscores = Nothing
  , scoreText200ResponseSkimmabilitySubscores = Nothing
  }

-- ** ScoreText200ResponseSkimmabilityMainscores
-- | ScoreText200ResponseSkimmabilityMainscores
data ScoreText200ResponseSkimmabilityMainscores = ScoreText200ResponseSkimmabilityMainscores
  { scoreText200ResponseSkimmabilityMainscoresTotalPossible :: !(Maybe Int) -- ^ "total_possible"
  , scoreText200ResponseSkimmabilityMainscoresTotal :: !(Maybe Double) -- ^ "total"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ScoreText200ResponseSkimmabilityMainscores
instance A.FromJSON ScoreText200ResponseSkimmabilityMainscores where
  parseJSON = A.withObject "ScoreText200ResponseSkimmabilityMainscores" $ \o ->
    ScoreText200ResponseSkimmabilityMainscores
      <$> (o .:? "total_possible")
      <*> (o .:? "total")

-- | ToJSON ScoreText200ResponseSkimmabilityMainscores
instance A.ToJSON ScoreText200ResponseSkimmabilityMainscores where
  toJSON ScoreText200ResponseSkimmabilityMainscores {..} =
   _omitNulls
      [ "total_possible" .= scoreText200ResponseSkimmabilityMainscoresTotalPossible
      , "total" .= scoreText200ResponseSkimmabilityMainscoresTotal
      ]


-- | Construct a value of type 'ScoreText200ResponseSkimmabilityMainscores' (by applying it's required fields, if any)
mkScoreText200ResponseSkimmabilityMainscores
  :: ScoreText200ResponseSkimmabilityMainscores
mkScoreText200ResponseSkimmabilityMainscores =
  ScoreText200ResponseSkimmabilityMainscores
  { scoreText200ResponseSkimmabilityMainscoresTotalPossible = Nothing
  , scoreText200ResponseSkimmabilityMainscoresTotal = Nothing
  }

-- ** ScoreText200ResponseSkimmabilitySubscores
-- | ScoreText200ResponseSkimmabilitySubscores
data ScoreText200ResponseSkimmabilitySubscores = ScoreText200ResponseSkimmabilitySubscores
  { scoreText200ResponseSkimmabilitySubscoresBulletPointRatioScore :: !(Maybe [Int]) -- ^ "bullet_point_ratio_score"
  , scoreText200ResponseSkimmabilitySubscoresImageScore :: !(Maybe [Int]) -- ^ "image_score"
  , scoreText200ResponseSkimmabilitySubscoresHighlightedWordRatioScore :: !(Maybe [Int]) -- ^ "highlighted_word_ratio_score"
  , scoreText200ResponseSkimmabilitySubscoresVideoScore :: !(Maybe [Int]) -- ^ "video_score"
  , scoreText200ResponseSkimmabilitySubscoresParagraphScore :: !(Maybe [Int]) -- ^ "paragraph_score"
  , scoreText200ResponseSkimmabilitySubscoresParagraphHeadlineRatioScore :: !(Maybe [Int]) -- ^ "paragraph_headline_ratio_score"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ScoreText200ResponseSkimmabilitySubscores
instance A.FromJSON ScoreText200ResponseSkimmabilitySubscores where
  parseJSON = A.withObject "ScoreText200ResponseSkimmabilitySubscores" $ \o ->
    ScoreText200ResponseSkimmabilitySubscores
      <$> (o .:? "bullet_point_ratio_score")
      <*> (o .:? "image_score")
      <*> (o .:? "highlighted_word_ratio_score")
      <*> (o .:? "video_score")
      <*> (o .:? "paragraph_score")
      <*> (o .:? "paragraph_headline_ratio_score")

-- | ToJSON ScoreText200ResponseSkimmabilitySubscores
instance A.ToJSON ScoreText200ResponseSkimmabilitySubscores where
  toJSON ScoreText200ResponseSkimmabilitySubscores {..} =
   _omitNulls
      [ "bullet_point_ratio_score" .= scoreText200ResponseSkimmabilitySubscoresBulletPointRatioScore
      , "image_score" .= scoreText200ResponseSkimmabilitySubscoresImageScore
      , "highlighted_word_ratio_score" .= scoreText200ResponseSkimmabilitySubscoresHighlightedWordRatioScore
      , "video_score" .= scoreText200ResponseSkimmabilitySubscoresVideoScore
      , "paragraph_score" .= scoreText200ResponseSkimmabilitySubscoresParagraphScore
      , "paragraph_headline_ratio_score" .= scoreText200ResponseSkimmabilitySubscoresParagraphHeadlineRatioScore
      ]


-- | Construct a value of type 'ScoreText200ResponseSkimmabilitySubscores' (by applying it's required fields, if any)
mkScoreText200ResponseSkimmabilitySubscores
  :: ScoreText200ResponseSkimmabilitySubscores
mkScoreText200ResponseSkimmabilitySubscores =
  ScoreText200ResponseSkimmabilitySubscores
  { scoreText200ResponseSkimmabilitySubscoresBulletPointRatioScore = Nothing
  , scoreText200ResponseSkimmabilitySubscoresImageScore = Nothing
  , scoreText200ResponseSkimmabilitySubscoresHighlightedWordRatioScore = Nothing
  , scoreText200ResponseSkimmabilitySubscoresVideoScore = Nothing
  , scoreText200ResponseSkimmabilitySubscoresParagraphScore = Nothing
  , scoreText200ResponseSkimmabilitySubscoresParagraphHeadlineRatioScore = Nothing
  }

-- ** ScoreText200ResponseStyle
-- | ScoreText200ResponseStyle
data ScoreText200ResponseStyle = ScoreText200ResponseStyle
  { scoreText200ResponseStyleMainscores :: !(Maybe ScoreText200ResponseReadabilityMainscores) -- ^ "mainscores"
  , scoreText200ResponseStyleSubscores :: !(Maybe ScoreText200ResponseStyleSubscores) -- ^ "subscores"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ScoreText200ResponseStyle
instance A.FromJSON ScoreText200ResponseStyle where
  parseJSON = A.withObject "ScoreText200ResponseStyle" $ \o ->
    ScoreText200ResponseStyle
      <$> (o .:? "mainscores")
      <*> (o .:? "subscores")

-- | ToJSON ScoreText200ResponseStyle
instance A.ToJSON ScoreText200ResponseStyle where
  toJSON ScoreText200ResponseStyle {..} =
   _omitNulls
      [ "mainscores" .= scoreText200ResponseStyleMainscores
      , "subscores" .= scoreText200ResponseStyleSubscores
      ]


-- | Construct a value of type 'ScoreText200ResponseStyle' (by applying it's required fields, if any)
mkScoreText200ResponseStyle
  :: ScoreText200ResponseStyle
mkScoreText200ResponseStyle =
  ScoreText200ResponseStyle
  { scoreText200ResponseStyleMainscores = Nothing
  , scoreText200ResponseStyleSubscores = Nothing
  }

-- ** ScoreText200ResponseStyleSubscores
-- | ScoreText200ResponseStyleSubscores
data ScoreText200ResponseStyleSubscores = ScoreText200ResponseStyleSubscores
  { scoreText200ResponseStyleSubscoresAbbreviationScore :: !(Maybe [Int]) -- ^ "abbreviation_score"
  , scoreText200ResponseStyleSubscoresStyleScore :: !(Maybe [Int]) -- ^ "style_score"
  , scoreText200ResponseStyleSubscoresSpellingScore :: !(Maybe [Int]) -- ^ "spelling_score"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ScoreText200ResponseStyleSubscores
instance A.FromJSON ScoreText200ResponseStyleSubscores where
  parseJSON = A.withObject "ScoreText200ResponseStyleSubscores" $ \o ->
    ScoreText200ResponseStyleSubscores
      <$> (o .:? "abbreviation_score")
      <*> (o .:? "style_score")
      <*> (o .:? "spelling_score")

-- | ToJSON ScoreText200ResponseStyleSubscores
instance A.ToJSON ScoreText200ResponseStyleSubscores where
  toJSON ScoreText200ResponseStyleSubscores {..} =
   _omitNulls
      [ "abbreviation_score" .= scoreText200ResponseStyleSubscoresAbbreviationScore
      , "style_score" .= scoreText200ResponseStyleSubscoresStyleScore
      , "spelling_score" .= scoreText200ResponseStyleSubscoresSpellingScore
      ]


-- | Construct a value of type 'ScoreText200ResponseStyleSubscores' (by applying it's required fields, if any)
mkScoreText200ResponseStyleSubscores
  :: ScoreText200ResponseStyleSubscores
mkScoreText200ResponseStyleSubscores =
  ScoreText200ResponseStyleSubscores
  { scoreText200ResponseStyleSubscoresAbbreviationScore = Nothing
  , scoreText200ResponseStyleSubscoresStyleScore = Nothing
  , scoreText200ResponseStyleSubscoresSpellingScore = Nothing
  }

-- ** SearchBooks200Response
-- | SearchBooks200Response
data SearchBooks200Response = SearchBooks200Response
  { searchBooks200ResponseAvailable :: !(Maybe Int) -- ^ "available"
  , searchBooks200ResponseNumber :: !(Maybe Int) -- ^ "number"
  , searchBooks200ResponseOffset :: !(Maybe Int) -- ^ "offset"
  , searchBooks200ResponseBooks :: !(Maybe [SearchBooks200ResponseBooksInner]) -- ^ "books"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SearchBooks200Response
instance A.FromJSON SearchBooks200Response where
  parseJSON = A.withObject "SearchBooks200Response" $ \o ->
    SearchBooks200Response
      <$> (o .:? "available")
      <*> (o .:? "number")
      <*> (o .:? "offset")
      <*> (o .:? "books")

-- | ToJSON SearchBooks200Response
instance A.ToJSON SearchBooks200Response where
  toJSON SearchBooks200Response {..} =
   _omitNulls
      [ "available" .= searchBooks200ResponseAvailable
      , "number" .= searchBooks200ResponseNumber
      , "offset" .= searchBooks200ResponseOffset
      , "books" .= searchBooks200ResponseBooks
      ]


-- | Construct a value of type 'SearchBooks200Response' (by applying it's required fields, if any)
mkSearchBooks200Response
  :: SearchBooks200Response
mkSearchBooks200Response =
  SearchBooks200Response
  { searchBooks200ResponseAvailable = Nothing
  , searchBooks200ResponseNumber = Nothing
  , searchBooks200ResponseOffset = Nothing
  , searchBooks200ResponseBooks = Nothing
  }

-- ** SearchBooks200ResponseBooksInner
-- | SearchBooks200ResponseBooksInner
data SearchBooks200ResponseBooksInner = SearchBooks200ResponseBooksInner
  { searchBooks200ResponseBooksInnerTitle :: !(Maybe Text) -- ^ "title"
  , searchBooks200ResponseBooksInnerImage :: !(Maybe Text) -- ^ "image"
  , searchBooks200ResponseBooksInnerId :: !(Maybe Int) -- ^ "id"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SearchBooks200ResponseBooksInner
instance A.FromJSON SearchBooks200ResponseBooksInner where
  parseJSON = A.withObject "SearchBooks200ResponseBooksInner" $ \o ->
    SearchBooks200ResponseBooksInner
      <$> (o .:? "title")
      <*> (o .:? "image")
      <*> (o .:? "id")

-- | ToJSON SearchBooks200ResponseBooksInner
instance A.ToJSON SearchBooks200ResponseBooksInner where
  toJSON SearchBooks200ResponseBooksInner {..} =
   _omitNulls
      [ "title" .= searchBooks200ResponseBooksInnerTitle
      , "image" .= searchBooks200ResponseBooksInnerImage
      , "id" .= searchBooks200ResponseBooksInnerId
      ]


-- | Construct a value of type 'SearchBooks200ResponseBooksInner' (by applying it's required fields, if any)
mkSearchBooks200ResponseBooksInner
  :: SearchBooks200ResponseBooksInner
mkSearchBooks200ResponseBooksInner =
  SearchBooks200ResponseBooksInner
  { searchBooks200ResponseBooksInnerTitle = Nothing
  , searchBooks200ResponseBooksInnerImage = Nothing
  , searchBooks200ResponseBooksInnerId = Nothing
  }

-- ** SearchGifs200Response
-- | SearchGifs200Response
data SearchGifs200Response = SearchGifs200Response
  { searchGifs200ResponseImages :: !(Maybe [SearchGifs200ResponseImagesInner]) -- ^ "images"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SearchGifs200Response
instance A.FromJSON SearchGifs200Response where
  parseJSON = A.withObject "SearchGifs200Response" $ \o ->
    SearchGifs200Response
      <$> (o .:? "images")

-- | ToJSON SearchGifs200Response
instance A.ToJSON SearchGifs200Response where
  toJSON SearchGifs200Response {..} =
   _omitNulls
      [ "images" .= searchGifs200ResponseImages
      ]


-- | Construct a value of type 'SearchGifs200Response' (by applying it's required fields, if any)
mkSearchGifs200Response
  :: SearchGifs200Response
mkSearchGifs200Response =
  SearchGifs200Response
  { searchGifs200ResponseImages = Nothing
  }

-- ** SearchGifs200ResponseImagesInner
-- | SearchGifs200ResponseImagesInner
data SearchGifs200ResponseImagesInner = SearchGifs200ResponseImagesInner
  { searchGifs200ResponseImagesInnerWidth :: !(Maybe Int) -- ^ "width"
  , searchGifs200ResponseImagesInnerUrl :: !(Maybe Text) -- ^ "url"
  , searchGifs200ResponseImagesInnerHeight :: !(Maybe Int) -- ^ "height"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SearchGifs200ResponseImagesInner
instance A.FromJSON SearchGifs200ResponseImagesInner where
  parseJSON = A.withObject "SearchGifs200ResponseImagesInner" $ \o ->
    SearchGifs200ResponseImagesInner
      <$> (o .:? "width")
      <*> (o .:? "url")
      <*> (o .:? "height")

-- | ToJSON SearchGifs200ResponseImagesInner
instance A.ToJSON SearchGifs200ResponseImagesInner where
  toJSON SearchGifs200ResponseImagesInner {..} =
   _omitNulls
      [ "width" .= searchGifs200ResponseImagesInnerWidth
      , "url" .= searchGifs200ResponseImagesInnerUrl
      , "height" .= searchGifs200ResponseImagesInnerHeight
      ]


-- | Construct a value of type 'SearchGifs200ResponseImagesInner' (by applying it's required fields, if any)
mkSearchGifs200ResponseImagesInner
  :: SearchGifs200ResponseImagesInner
mkSearchGifs200ResponseImagesInner =
  SearchGifs200ResponseImagesInner
  { searchGifs200ResponseImagesInnerWidth = Nothing
  , searchGifs200ResponseImagesInnerUrl = Nothing
  , searchGifs200ResponseImagesInnerHeight = Nothing
  }

-- ** SearchJokes200Response
-- | SearchJokes200Response
data SearchJokes200Response = SearchJokes200Response
  { searchJokes200ResponseJokes :: !(Maybe [SearchJokes200ResponseJokesInner]) -- ^ "jokes"
  , searchJokes200ResponseAvailable :: !(Maybe Int) -- ^ "available"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SearchJokes200Response
instance A.FromJSON SearchJokes200Response where
  parseJSON = A.withObject "SearchJokes200Response" $ \o ->
    SearchJokes200Response
      <$> (o .:? "jokes")
      <*> (o .:? "available")

-- | ToJSON SearchJokes200Response
instance A.ToJSON SearchJokes200Response where
  toJSON SearchJokes200Response {..} =
   _omitNulls
      [ "jokes" .= searchJokes200ResponseJokes
      , "available" .= searchJokes200ResponseAvailable
      ]


-- | Construct a value of type 'SearchJokes200Response' (by applying it's required fields, if any)
mkSearchJokes200Response
  :: SearchJokes200Response
mkSearchJokes200Response =
  SearchJokes200Response
  { searchJokes200ResponseJokes = Nothing
  , searchJokes200ResponseAvailable = Nothing
  }

-- ** SearchJokes200ResponseJokesInner
-- | SearchJokes200ResponseJokesInner
data SearchJokes200ResponseJokesInner = SearchJokes200ResponseJokesInner
  { searchJokes200ResponseJokesInnerJoke :: !(Maybe Text) -- ^ "joke"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SearchJokes200ResponseJokesInner
instance A.FromJSON SearchJokes200ResponseJokesInner where
  parseJSON = A.withObject "SearchJokes200ResponseJokesInner" $ \o ->
    SearchJokes200ResponseJokesInner
      <$> (o .:? "joke")

-- | ToJSON SearchJokes200ResponseJokesInner
instance A.ToJSON SearchJokes200ResponseJokesInner where
  toJSON SearchJokes200ResponseJokesInner {..} =
   _omitNulls
      [ "joke" .= searchJokes200ResponseJokesInnerJoke
      ]


-- | Construct a value of type 'SearchJokes200ResponseJokesInner' (by applying it's required fields, if any)
mkSearchJokes200ResponseJokesInner
  :: SearchJokes200ResponseJokesInner
mkSearchJokes200ResponseJokesInner =
  SearchJokes200ResponseJokesInner
  { searchJokes200ResponseJokesInnerJoke = Nothing
  }

-- ** SearchMemes200Response
-- | SearchMemes200Response
data SearchMemes200Response = SearchMemes200Response
  { searchMemes200ResponseMemes :: !(Maybe [SearchMemes200ResponseMemesInner]) -- ^ "memes"
  , searchMemes200ResponseAvailable :: !(Maybe Int) -- ^ "available"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SearchMemes200Response
instance A.FromJSON SearchMemes200Response where
  parseJSON = A.withObject "SearchMemes200Response" $ \o ->
    SearchMemes200Response
      <$> (o .:? "memes")
      <*> (o .:? "available")

-- | ToJSON SearchMemes200Response
instance A.ToJSON SearchMemes200Response where
  toJSON SearchMemes200Response {..} =
   _omitNulls
      [ "memes" .= searchMemes200ResponseMemes
      , "available" .= searchMemes200ResponseAvailable
      ]


-- | Construct a value of type 'SearchMemes200Response' (by applying it's required fields, if any)
mkSearchMemes200Response
  :: SearchMemes200Response
mkSearchMemes200Response =
  SearchMemes200Response
  { searchMemes200ResponseMemes = Nothing
  , searchMemes200ResponseAvailable = Nothing
  }

-- ** SearchMemes200ResponseMemesInner
-- | SearchMemes200ResponseMemesInner
data SearchMemes200ResponseMemesInner = SearchMemes200ResponseMemesInner
  { searchMemes200ResponseMemesInnerType :: !(Maybe Text) -- ^ "type"
  , searchMemes200ResponseMemesInnerDescription :: !(Maybe Text) -- ^ "description"
  , searchMemes200ResponseMemesInnerUrl :: !(Maybe Text) -- ^ "url"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SearchMemes200ResponseMemesInner
instance A.FromJSON SearchMemes200ResponseMemesInner where
  parseJSON = A.withObject "SearchMemes200ResponseMemesInner" $ \o ->
    SearchMemes200ResponseMemesInner
      <$> (o .:? "type")
      <*> (o .:? "description")
      <*> (o .:? "url")

-- | ToJSON SearchMemes200ResponseMemesInner
instance A.ToJSON SearchMemes200ResponseMemesInner where
  toJSON SearchMemes200ResponseMemesInner {..} =
   _omitNulls
      [ "type" .= searchMemes200ResponseMemesInnerType
      , "description" .= searchMemes200ResponseMemesInnerDescription
      , "url" .= searchMemes200ResponseMemesInnerUrl
      ]


-- | Construct a value of type 'SearchMemes200ResponseMemesInner' (by applying it's required fields, if any)
mkSearchMemes200ResponseMemesInner
  :: SearchMemes200ResponseMemesInner
mkSearchMemes200ResponseMemesInner =
  SearchMemes200ResponseMemesInner
  { searchMemes200ResponseMemesInnerType = Nothing
  , searchMemes200ResponseMemesInnerDescription = Nothing
  , searchMemes200ResponseMemesInnerUrl = Nothing
  }

-- ** SearchNews200Response
-- | SearchNews200Response
data SearchNews200Response = SearchNews200Response
  { searchNews200ResponseOffset :: !(Maybe Int) -- ^ "offset"
  , searchNews200ResponseNumber :: !(Maybe Int) -- ^ "number"
  , searchNews200ResponseAvailable :: !(Maybe Int) -- ^ "available"
  , searchNews200ResponseNews :: !(Maybe [SearchNews200ResponseNewsInner]) -- ^ "news"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SearchNews200Response
instance A.FromJSON SearchNews200Response where
  parseJSON = A.withObject "SearchNews200Response" $ \o ->
    SearchNews200Response
      <$> (o .:? "offset")
      <*> (o .:? "number")
      <*> (o .:? "available")
      <*> (o .:? "news")

-- | ToJSON SearchNews200Response
instance A.ToJSON SearchNews200Response where
  toJSON SearchNews200Response {..} =
   _omitNulls
      [ "offset" .= searchNews200ResponseOffset
      , "number" .= searchNews200ResponseNumber
      , "available" .= searchNews200ResponseAvailable
      , "news" .= searchNews200ResponseNews
      ]


-- | Construct a value of type 'SearchNews200Response' (by applying it's required fields, if any)
mkSearchNews200Response
  :: SearchNews200Response
mkSearchNews200Response =
  SearchNews200Response
  { searchNews200ResponseOffset = Nothing
  , searchNews200ResponseNumber = Nothing
  , searchNews200ResponseAvailable = Nothing
  , searchNews200ResponseNews = Nothing
  }

-- ** SearchNews200ResponseNewsInner
-- | SearchNews200ResponseNewsInner
data SearchNews200ResponseNewsInner = SearchNews200ResponseNewsInner
  { searchNews200ResponseNewsInnerSummary :: !(Maybe Text) -- ^ "summary"
  , searchNews200ResponseNewsInnerImage :: !(Maybe Text) -- ^ "image"
  , searchNews200ResponseNewsInnerSentiment :: !(Maybe Double) -- ^ "sentiment"
  , searchNews200ResponseNewsInnerSourceCountry :: !(Maybe Text) -- ^ "source_country"
  , searchNews200ResponseNewsInnerLanguage :: !(Maybe Text) -- ^ "language"
  , searchNews200ResponseNewsInnerId :: !(Maybe Int) -- ^ "id"
  , searchNews200ResponseNewsInnerText :: !(Maybe Text) -- ^ "text"
  , searchNews200ResponseNewsInnerTitle :: !(Maybe Text) -- ^ "title"
  , searchNews200ResponseNewsInnerPublishDate :: !(Maybe Text) -- ^ "publish_date"
  , searchNews200ResponseNewsInnerUrl :: !(Maybe Text) -- ^ "url"
  , searchNews200ResponseNewsInnerAuthors :: !(Maybe [Text]) -- ^ "authors"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SearchNews200ResponseNewsInner
instance A.FromJSON SearchNews200ResponseNewsInner where
  parseJSON = A.withObject "SearchNews200ResponseNewsInner" $ \o ->
    SearchNews200ResponseNewsInner
      <$> (o .:? "summary")
      <*> (o .:? "image")
      <*> (o .:? "sentiment")
      <*> (o .:? "source_country")
      <*> (o .:? "language")
      <*> (o .:? "id")
      <*> (o .:? "text")
      <*> (o .:? "title")
      <*> (o .:? "publish_date")
      <*> (o .:? "url")
      <*> (o .:? "authors")

-- | ToJSON SearchNews200ResponseNewsInner
instance A.ToJSON SearchNews200ResponseNewsInner where
  toJSON SearchNews200ResponseNewsInner {..} =
   _omitNulls
      [ "summary" .= searchNews200ResponseNewsInnerSummary
      , "image" .= searchNews200ResponseNewsInnerImage
      , "sentiment" .= searchNews200ResponseNewsInnerSentiment
      , "source_country" .= searchNews200ResponseNewsInnerSourceCountry
      , "language" .= searchNews200ResponseNewsInnerLanguage
      , "id" .= searchNews200ResponseNewsInnerId
      , "text" .= searchNews200ResponseNewsInnerText
      , "title" .= searchNews200ResponseNewsInnerTitle
      , "publish_date" .= searchNews200ResponseNewsInnerPublishDate
      , "url" .= searchNews200ResponseNewsInnerUrl
      , "authors" .= searchNews200ResponseNewsInnerAuthors
      ]


-- | Construct a value of type 'SearchNews200ResponseNewsInner' (by applying it's required fields, if any)
mkSearchNews200ResponseNewsInner
  :: SearchNews200ResponseNewsInner
mkSearchNews200ResponseNewsInner =
  SearchNews200ResponseNewsInner
  { searchNews200ResponseNewsInnerSummary = Nothing
  , searchNews200ResponseNewsInnerImage = Nothing
  , searchNews200ResponseNewsInnerSentiment = Nothing
  , searchNews200ResponseNewsInnerSourceCountry = Nothing
  , searchNews200ResponseNewsInnerLanguage = Nothing
  , searchNews200ResponseNewsInnerId = Nothing
  , searchNews200ResponseNewsInnerText = Nothing
  , searchNews200ResponseNewsInnerTitle = Nothing
  , searchNews200ResponseNewsInnerPublishDate = Nothing
  , searchNews200ResponseNewsInnerUrl = Nothing
  , searchNews200ResponseNewsInnerAuthors = Nothing
  }

-- ** SearchRoyaltyFreeImages200Response
-- | SearchRoyaltyFreeImages200Response
data SearchRoyaltyFreeImages200Response = SearchRoyaltyFreeImages200Response
  { searchRoyaltyFreeImages200ResponseImages :: !(Maybe [SearchRoyaltyFreeImages200ResponseImagesInner]) -- ^ "images"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SearchRoyaltyFreeImages200Response
instance A.FromJSON SearchRoyaltyFreeImages200Response where
  parseJSON = A.withObject "SearchRoyaltyFreeImages200Response" $ \o ->
    SearchRoyaltyFreeImages200Response
      <$> (o .:? "images")

-- | ToJSON SearchRoyaltyFreeImages200Response
instance A.ToJSON SearchRoyaltyFreeImages200Response where
  toJSON SearchRoyaltyFreeImages200Response {..} =
   _omitNulls
      [ "images" .= searchRoyaltyFreeImages200ResponseImages
      ]


-- | Construct a value of type 'SearchRoyaltyFreeImages200Response' (by applying it's required fields, if any)
mkSearchRoyaltyFreeImages200Response
  :: SearchRoyaltyFreeImages200Response
mkSearchRoyaltyFreeImages200Response =
  SearchRoyaltyFreeImages200Response
  { searchRoyaltyFreeImages200ResponseImages = Nothing
  }

-- ** SearchRoyaltyFreeImages200ResponseImagesInner
-- | SearchRoyaltyFreeImages200ResponseImagesInner
data SearchRoyaltyFreeImages200ResponseImagesInner = SearchRoyaltyFreeImages200ResponseImagesInner
  { searchRoyaltyFreeImages200ResponseImagesInnerWidth :: !(Maybe Int) -- ^ "width"
  , searchRoyaltyFreeImages200ResponseImagesInnerLicense :: !(Maybe SearchRoyaltyFreeImages200ResponseImagesInnerLicense) -- ^ "license"
  , searchRoyaltyFreeImages200ResponseImagesInnerThumbnail :: !(Maybe Text) -- ^ "thumbnail"
  , searchRoyaltyFreeImages200ResponseImagesInnerId :: !(Maybe Text) -- ^ "id"
  , searchRoyaltyFreeImages200ResponseImagesInnerUrl :: !(Maybe Text) -- ^ "url"
  , searchRoyaltyFreeImages200ResponseImagesInnerHeight :: !(Maybe Int) -- ^ "height"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SearchRoyaltyFreeImages200ResponseImagesInner
instance A.FromJSON SearchRoyaltyFreeImages200ResponseImagesInner where
  parseJSON = A.withObject "SearchRoyaltyFreeImages200ResponseImagesInner" $ \o ->
    SearchRoyaltyFreeImages200ResponseImagesInner
      <$> (o .:? "width")
      <*> (o .:? "license")
      <*> (o .:? "thumbnail")
      <*> (o .:? "id")
      <*> (o .:? "url")
      <*> (o .:? "height")

-- | ToJSON SearchRoyaltyFreeImages200ResponseImagesInner
instance A.ToJSON SearchRoyaltyFreeImages200ResponseImagesInner where
  toJSON SearchRoyaltyFreeImages200ResponseImagesInner {..} =
   _omitNulls
      [ "width" .= searchRoyaltyFreeImages200ResponseImagesInnerWidth
      , "license" .= searchRoyaltyFreeImages200ResponseImagesInnerLicense
      , "thumbnail" .= searchRoyaltyFreeImages200ResponseImagesInnerThumbnail
      , "id" .= searchRoyaltyFreeImages200ResponseImagesInnerId
      , "url" .= searchRoyaltyFreeImages200ResponseImagesInnerUrl
      , "height" .= searchRoyaltyFreeImages200ResponseImagesInnerHeight
      ]


-- | Construct a value of type 'SearchRoyaltyFreeImages200ResponseImagesInner' (by applying it's required fields, if any)
mkSearchRoyaltyFreeImages200ResponseImagesInner
  :: SearchRoyaltyFreeImages200ResponseImagesInner
mkSearchRoyaltyFreeImages200ResponseImagesInner =
  SearchRoyaltyFreeImages200ResponseImagesInner
  { searchRoyaltyFreeImages200ResponseImagesInnerWidth = Nothing
  , searchRoyaltyFreeImages200ResponseImagesInnerLicense = Nothing
  , searchRoyaltyFreeImages200ResponseImagesInnerThumbnail = Nothing
  , searchRoyaltyFreeImages200ResponseImagesInnerId = Nothing
  , searchRoyaltyFreeImages200ResponseImagesInnerUrl = Nothing
  , searchRoyaltyFreeImages200ResponseImagesInnerHeight = Nothing
  }

-- ** SearchRoyaltyFreeImages200ResponseImagesInnerLicense
-- | SearchRoyaltyFreeImages200ResponseImagesInnerLicense
data SearchRoyaltyFreeImages200ResponseImagesInnerLicense = SearchRoyaltyFreeImages200ResponseImagesInnerLicense
  { searchRoyaltyFreeImages200ResponseImagesInnerLicenseName :: !(Maybe Text) -- ^ "name"
  , searchRoyaltyFreeImages200ResponseImagesInnerLicenseLink :: !(Maybe Text) -- ^ "link"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SearchRoyaltyFreeImages200ResponseImagesInnerLicense
instance A.FromJSON SearchRoyaltyFreeImages200ResponseImagesInnerLicense where
  parseJSON = A.withObject "SearchRoyaltyFreeImages200ResponseImagesInnerLicense" $ \o ->
    SearchRoyaltyFreeImages200ResponseImagesInnerLicense
      <$> (o .:? "name")
      <*> (o .:? "link")

-- | ToJSON SearchRoyaltyFreeImages200ResponseImagesInnerLicense
instance A.ToJSON SearchRoyaltyFreeImages200ResponseImagesInnerLicense where
  toJSON SearchRoyaltyFreeImages200ResponseImagesInnerLicense {..} =
   _omitNulls
      [ "name" .= searchRoyaltyFreeImages200ResponseImagesInnerLicenseName
      , "link" .= searchRoyaltyFreeImages200ResponseImagesInnerLicenseLink
      ]


-- | Construct a value of type 'SearchRoyaltyFreeImages200ResponseImagesInnerLicense' (by applying it's required fields, if any)
mkSearchRoyaltyFreeImages200ResponseImagesInnerLicense
  :: SearchRoyaltyFreeImages200ResponseImagesInnerLicense
mkSearchRoyaltyFreeImages200ResponseImagesInnerLicense =
  SearchRoyaltyFreeImages200ResponseImagesInnerLicense
  { searchRoyaltyFreeImages200ResponseImagesInnerLicenseName = Nothing
  , searchRoyaltyFreeImages200ResponseImagesInnerLicenseLink = Nothing
  }

-- ** SearchWeb200Response
-- | SearchWeb200Response
data SearchWeb200Response = SearchWeb200Response
  { searchWeb200ResponseResults :: !(Maybe [SearchWeb200ResponseResultsInner]) -- ^ "results"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SearchWeb200Response
instance A.FromJSON SearchWeb200Response where
  parseJSON = A.withObject "SearchWeb200Response" $ \o ->
    SearchWeb200Response
      <$> (o .:? "results")

-- | ToJSON SearchWeb200Response
instance A.ToJSON SearchWeb200Response where
  toJSON SearchWeb200Response {..} =
   _omitNulls
      [ "results" .= searchWeb200ResponseResults
      ]


-- | Construct a value of type 'SearchWeb200Response' (by applying it's required fields, if any)
mkSearchWeb200Response
  :: SearchWeb200Response
mkSearchWeb200Response =
  SearchWeb200Response
  { searchWeb200ResponseResults = Nothing
  }

-- ** SearchWeb200ResponseResultsInner
-- | SearchWeb200ResponseResultsInner
data SearchWeb200ResponseResultsInner = SearchWeb200ResponseResultsInner
  { searchWeb200ResponseResultsInnerTitle :: !(Maybe Text) -- ^ "title"
  , searchWeb200ResponseResultsInnerSummary :: !(Maybe Text) -- ^ "summary"
  , searchWeb200ResponseResultsInnerUrl :: !(Maybe Text) -- ^ "url"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SearchWeb200ResponseResultsInner
instance A.FromJSON SearchWeb200ResponseResultsInner where
  parseJSON = A.withObject "SearchWeb200ResponseResultsInner" $ \o ->
    SearchWeb200ResponseResultsInner
      <$> (o .:? "title")
      <*> (o .:? "summary")
      <*> (o .:? "url")

-- | ToJSON SearchWeb200ResponseResultsInner
instance A.ToJSON SearchWeb200ResponseResultsInner where
  toJSON SearchWeb200ResponseResultsInner {..} =
   _omitNulls
      [ "title" .= searchWeb200ResponseResultsInnerTitle
      , "summary" .= searchWeb200ResponseResultsInnerSummary
      , "url" .= searchWeb200ResponseResultsInnerUrl
      ]


-- | Construct a value of type 'SearchWeb200ResponseResultsInner' (by applying it's required fields, if any)
mkSearchWeb200ResponseResultsInner
  :: SearchWeb200ResponseResultsInner
mkSearchWeb200ResponseResultsInner =
  SearchWeb200ResponseResultsInner
  { searchWeb200ResponseResultsInnerTitle = Nothing
  , searchWeb200ResponseResultsInnerSummary = Nothing
  , searchWeb200ResponseResultsInnerUrl = Nothing
  }

-- ** SingularizeWord200Response
-- | SingularizeWord200Response
data SingularizeWord200Response = SingularizeWord200Response
  { singularizeWord200ResponseOriginal :: !(Maybe Text) -- ^ "original"
  , singularizeWord200ResponseSingular :: !(Maybe Text) -- ^ "singular"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SingularizeWord200Response
instance A.FromJSON SingularizeWord200Response where
  parseJSON = A.withObject "SingularizeWord200Response" $ \o ->
    SingularizeWord200Response
      <$> (o .:? "original")
      <*> (o .:? "singular")

-- | ToJSON SingularizeWord200Response
instance A.ToJSON SingularizeWord200Response where
  toJSON SingularizeWord200Response {..} =
   _omitNulls
      [ "original" .= singularizeWord200ResponseOriginal
      , "singular" .= singularizeWord200ResponseSingular
      ]


-- | Construct a value of type 'SingularizeWord200Response' (by applying it's required fields, if any)
mkSingularizeWord200Response
  :: SingularizeWord200Response
mkSingularizeWord200Response =
  SingularizeWord200Response
  { singularizeWord200ResponseOriginal = Nothing
  , singularizeWord200ResponseSingular = Nothing
  }

-- ** StoreKeyValueGET200Response
-- | StoreKeyValueGET200Response
data StoreKeyValueGET200Response = StoreKeyValueGET200Response
  { storeKeyValueGET200ResponseStatus :: !(Maybe Text) -- ^ "status"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON StoreKeyValueGET200Response
instance A.FromJSON StoreKeyValueGET200Response where
  parseJSON = A.withObject "StoreKeyValueGET200Response" $ \o ->
    StoreKeyValueGET200Response
      <$> (o .:? "status")

-- | ToJSON StoreKeyValueGET200Response
instance A.ToJSON StoreKeyValueGET200Response where
  toJSON StoreKeyValueGET200Response {..} =
   _omitNulls
      [ "status" .= storeKeyValueGET200ResponseStatus
      ]


-- | Construct a value of type 'StoreKeyValueGET200Response' (by applying it's required fields, if any)
mkStoreKeyValueGET200Response
  :: StoreKeyValueGET200Response
mkStoreKeyValueGET200Response =
  StoreKeyValueGET200Response
  { storeKeyValueGET200ResponseStatus = Nothing
  }

-- ** TextStemming200Response
-- | TextStemming200Response
data TextStemming200Response = TextStemming200Response
  { textStemming200ResponseOriginal :: !(Maybe Text) -- ^ "original"
  , textStemming200ResponseStemmed :: !(Maybe Text) -- ^ "stemmed"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TextStemming200Response
instance A.FromJSON TextStemming200Response where
  parseJSON = A.withObject "TextStemming200Response" $ \o ->
    TextStemming200Response
      <$> (o .:? "original")
      <*> (o .:? "stemmed")

-- | ToJSON TextStemming200Response
instance A.ToJSON TextStemming200Response where
  toJSON TextStemming200Response {..} =
   _omitNulls
      [ "original" .= textStemming200ResponseOriginal
      , "stemmed" .= textStemming200ResponseStemmed
      ]


-- | Construct a value of type 'TextStemming200Response' (by applying it's required fields, if any)
mkTextStemming200Response
  :: TextStemming200Response
mkTextStemming200Response =
  TextStemming200Response
  { textStemming200ResponseOriginal = Nothing
  , textStemming200ResponseStemmed = Nothing
  }




-- * Auth Methods

-- ** AuthApiKeyApiKey
data AuthApiKeyApiKey =
  AuthApiKeyApiKey Text -- ^ secret
  deriving (P.Eq, P.Show, P.Typeable)

instance AuthMethod AuthApiKeyApiKey where
  applyAuthMethod _ a@(AuthApiKeyApiKey secret) req =
    P.pure $
    if (P.typeOf a `P.elem` rAuthTypes req)
      then req `setQuery` toQuery ("api-key", Just secret)
           & L.over rAuthTypesL (P.filter (/= P.typeOf a))
      else req

-- ** AuthApiKeyHeaderApiKey
data AuthApiKeyHeaderApiKey =
  AuthApiKeyHeaderApiKey Text -- ^ secret
  deriving (P.Eq, P.Show, P.Typeable)

instance AuthMethod AuthApiKeyHeaderApiKey where
  applyAuthMethod _ a@(AuthApiKeyHeaderApiKey secret) req =
    P.pure $
    if (P.typeOf a `P.elem` rAuthTypes req)
      then req `setHeader` toHeader ("x-api-key", secret)
           & L.over rAuthTypesL (P.filter (/= P.typeOf a))
      else req


